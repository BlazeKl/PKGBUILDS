
From cdc9b0c079ab9001800e97d2b6303f743f8c2175 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 27 Jun 2019 22:30:17 -0500
Subject: [PATCH] ntoskrnl.exe: IoInvalidateDeviceRelations() receives the
 parent PDO.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
---
 dlls/ntoskrnl.exe/ntoskrnl.c         |  8 ++-
 dlls/ntoskrnl.exe/ntoskrnl_private.h |  6 ++
 dlls/ntoskrnl.exe/pnp.c              | 86 ++++++++++++++++++++++++----
 dlls/winebus.sys/bus.h               |  1 +
 dlls/winebus.sys/bus_iohid.c         |  2 +-
 dlls/winebus.sys/bus_sdl.c           |  2 +-
 dlls/winebus.sys/bus_udev.c          |  2 +-
 dlls/winebus.sys/main.c              | 11 ++--
 8 files changed, 97 insertions(+), 21 deletions(-)

diff --git a/dlls/ntoskrnl.exe/ntoskrnl.c b/dlls/ntoskrnl.exe/ntoskrnl.c
index 92f9afab33..620f9572da 100644
--- a/dlls/ntoskrnl.exe/ntoskrnl.c
+++ b/dlls/ntoskrnl.exe/ntoskrnl.c
@@ -1469,6 +1469,7 @@ NTSTATUS WINAPI IoCreateDevice( DRIVER_OBJECT *driver, ULONG ext_size,
 {
     static const WCHAR auto_format[] = {'\\','D','e','v','i','c','e','\\','%','0','8','x',0};
     NTSTATUS status;
+    struct wine_device *wine_device;
     DEVICE_OBJECT *device;
     HANDLE manager = get_device_manager();
     static unsigned int auto_idx = 0;
@@ -1477,11 +1478,12 @@ NTSTATUS WINAPI IoCreateDevice( DRIVER_OBJECT *driver, ULONG ext_size,
     TRACE( "(%p, %u, %s, %u, %x, %u, %p)\n",
            driver, ext_size, debugstr_us(name), type, characteristics, exclusive, ret_device );
 
-    if (!(device = alloc_kernel_object( IoDeviceObjectType, NULL, sizeof(DEVICE_OBJECT) + ext_size, 1 )))
+    if (!(wine_device = alloc_kernel_object( IoDeviceObjectType, NULL, sizeof(struct wine_device) + ext_size, 1 )))
         return STATUS_NO_MEMORY;
+    device = &wine_device->device_obj;
 
     device->DriverObject    = driver;
-    device->DeviceExtension = device + 1;
+    device->DeviceExtension = wine_device + 1;
     device->DeviceType      = type;
     device->StackSize       = 1;
 
@@ -1547,9 +1549,11 @@ void WINAPI IoDeleteDevice( DEVICE_OBJECT *device )
 
     if (status == STATUS_SUCCESS)
     {
+        struct wine_device *wine_device = CONTAINING_RECORD(device, struct wine_device, device_obj);
         DEVICE_OBJECT **prev = &device->DriverObject->DeviceObject;
         while (*prev && *prev != device) prev = &(*prev)->NextDevice;
         if (*prev) *prev = (*prev)->NextDevice;
+        ExFreePool( wine_device->children );
         ObDereferenceObject( device );
     }
 }
diff --git a/dlls/ntoskrnl.exe/ntoskrnl_private.h b/dlls/ntoskrnl.exe/ntoskrnl_private.h
index b5244ef164..256e945e6f 100644
--- a/dlls/ntoskrnl.exe/ntoskrnl_private.h
+++ b/dlls/ntoskrnl.exe/ntoskrnl_private.h
@@ -86,4 +86,10 @@ static const WCHAR servicesW[] = {'\\','R','e','g','i','s','t','r','y',
                                   '\\','C','u','r','r','e','n','t','C','o','n','t','r','o','l','S','e','t',
                                   '\\','S','e','r','v','i','c','e','s',
                                   '\\',0};
+
+struct wine_device
+{
+    DEVICE_OBJECT device_obj;
+    DEVICE_RELATIONS *children;
+};
 #endif
diff --git a/dlls/ntoskrnl.exe/pnp.c b/dlls/ntoskrnl.exe/pnp.c
index 30865a05dc..c618885d42 100644
--- a/dlls/ntoskrnl.exe/pnp.c
+++ b/dlls/ntoskrnl.exe/pnp.c
@@ -316,25 +316,18 @@ static void start_device( DEVICE_OBJECT *device, HDEVINFO set, SP_DEVINFO_DATA *
     }
 }
 
-static void handle_bus_relations( DEVICE_OBJECT *device )
+static void enumerate_new_device( DEVICE_OBJECT *device, HDEVINFO set )
 {
     static const WCHAR infpathW[] = {'I','n','f','P','a','t','h',0};
 
     SP_DEVINFO_DATA sp_device = {sizeof(sp_device)};
     WCHAR device_instance_id[MAX_DEVICE_ID_LEN];
     BOOL need_driver = TRUE;
-    HDEVINFO set;
     HKEY key;
 
-    /* We could (should?) do a full IRP_MN_QUERY_DEVICE_RELATIONS query,
-     * but we don't have to, we have the DEVICE_OBJECT of the new device
-     * so we can simply handle the process here */
-
     if (get_device_instance_id( device, device_instance_id ))
         return;
 
-    set = SetupDiCreateDeviceInfoList( NULL, NULL );
-
     if (!SetupDiCreateDeviceInfoW( set, device_instance_id, &GUID_NULL, NULL, NULL, 0, &sp_device )
             && !SetupDiOpenDeviceInfoW( set, device_instance_id, NULL, 0, &sp_device ))
     {
@@ -362,19 +355,92 @@ static void handle_bus_relations( DEVICE_OBJECT *device )
     }
 
     start_device( device, set, &sp_device );
-
-    SetupDiDestroyDeviceInfoList( set );
 }
 
 static void remove_device( DEVICE_OBJECT *device )
 {
+    struct wine_device *wine_device = CONTAINING_RECORD(device, struct wine_device, device_obj);
+
     TRACE("Removing device %p.\n", device);
 
+    if (wine_device->children)
+    {
+        ULONG i;
+        for (i = 0; i < wine_device->children->Count; ++i)
+            remove_device( wine_device->children->Objects[i] );
+    }
+
     send_power_irp( device, PowerDeviceD3 );
     send_pnp_irp( device, IRP_MN_SURPRISE_REMOVAL );
     send_pnp_irp( device, IRP_MN_REMOVE_DEVICE );
 }
 
+static BOOL device_in_list( const DEVICE_RELATIONS *list, const DEVICE_OBJECT *device )
+{
+    ULONG i;
+    for (i = 0; i < list->Count; ++i)
+    {
+        if (list->Objects[i] == device)
+            return TRUE;
+    }
+    return FALSE;
+}
+
+static void handle_bus_relations( DEVICE_OBJECT *parent )
+{
+    struct wine_device *wine_parent = CONTAINING_RECORD(parent, struct wine_device, device_obj);
+    SP_DEVINFO_DATA sp_device = {sizeof(sp_device)};
+    DEVICE_RELATIONS *relations;
+    IO_STATUS_BLOCK irp_status;
+    IO_STACK_LOCATION *irpsp;
+    NTSTATUS status;
+    HDEVINFO set;
+    IRP *irp;
+    ULONG i;
+
+    TRACE( "(%p)\n", parent );
+
+    set = SetupDiCreateDeviceInfoList( NULL, NULL );
+
+    parent = IoGetAttachedDevice( parent );
+
+    if (!(irp = IoBuildSynchronousFsdRequest( IRP_MJ_PNP, parent, NULL, 0, NULL, NULL, &irp_status )))
+    {
+        SetupDiDestroyDeviceInfoList( set );
+        return;
+    }
+
+    irpsp = IoGetNextIrpStackLocation( irp );
+    irpsp->MinorFunction = IRP_MN_QUERY_DEVICE_RELATIONS;
+    irpsp->Parameters.QueryDeviceRelations.Type = BusRelations;
+    if ((status = send_device_irp( parent, irp, (ULONG_PTR *)&relations )))
+    {
+        ERR("Failed to enumerate child devices, status %#x.\n", status);
+        SetupDiDestroyDeviceInfoList( set );
+        return;
+    }
+
+    TRACE("Got %u devices.\n", relations->Count);
+
+    for (i = 0; i < relations->Count; ++i)
+    {
+        DEVICE_OBJECT *child = relations->Objects[i];
+
+        TRACE("%p, %p\n", wine_parent, wine_parent->children);
+
+        if (!wine_parent->children || !device_in_list( wine_parent->children, child ))
+        {
+            TRACE("Adding new device %p.\n", child);
+            enumerate_new_device( child, set );
+        }
+    }
+
+    ExFreePool( wine_parent->children );
+    wine_parent->children = relations;
+
+    SetupDiDestroyDeviceInfoList( set );
+}
+
 /***********************************************************************
  *           IoInvalidateDeviceRelations (NTOSKRNL.EXE.@)
  */
diff --git a/dlls/winebus.sys/bus.h b/dlls/winebus.sys/bus.h
index de8ddf7ad9..a250878489 100644
--- a/dlls/winebus.sys/bus.h
+++ b/dlls/winebus.sys/bus.h
@@ -54,3 +54,4 @@ DWORD check_bus_option(const UNICODE_STRING *option, DWORD default_value) DECLSP
 BOOL is_xbox_gamepad(WORD vid, WORD pid) DECLSPEC_HIDDEN;
 
 HANDLE driver_key DECLSPEC_HIDDEN;
+DEVICE_OBJECT *bus_pdo DECLSPEC_HIDDEN;
diff --git a/dlls/winebus.sys/bus_iohid.c b/dlls/winebus.sys/bus_iohid.c
index 7933374007..e992db8376 100644
--- a/dlls/winebus.sys/bus_iohid.c
+++ b/dlls/winebus.sys/bus_iohid.c
@@ -357,7 +357,7 @@ static void handle_DeviceMatchingCallback(void *context, IOReturn result, void *
         struct platform_private *private = impl_from_DEVICE_OBJECT(device);
         private->device = IOHIDDevice;
         private->buffer = NULL;
-        IoInvalidateDeviceRelations(device, BusRelations);
+        IoInvalidateDeviceRelations(bus_pdo, BusRelations);
     }
 }
 
diff --git a/dlls/winebus.sys/bus_sdl.c b/dlls/winebus.sys/bus_sdl.c
index d24e21cff8..781deda767 100644
--- a/dlls/winebus.sys/bus_sdl.c
+++ b/dlls/winebus.sys/bus_sdl.c
@@ -988,7 +988,7 @@ static void try_add_device(SDL_JoystickID index)
             HeapFree(GetProcessHeap(), 0, serial);
             return;
         }
-        IoInvalidateDeviceRelations(device, BusRelations);
+        IoInvalidateDeviceRelations(bus_pdo, BusRelations);
     }
     else
     {
diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index 08ad8765af..9a3df9ea6b 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -1241,7 +1241,7 @@ static void try_add_device(struct udev_device *dev)
                 return;
             }
 #endif
-        IoInvalidateDeviceRelations(device, BusRelations);
+        IoInvalidateDeviceRelations(bus_pdo, BusRelations);
     }
     else
     {
diff --git a/dlls/winebus.sys/main.c b/dlls/winebus.sys/main.c
index b96e38c538..26200bde3e 100644
--- a/dlls/winebus.sys/main.c
+++ b/dlls/winebus.sys/main.c
@@ -73,7 +73,8 @@ static DRIVER_OBJECT *driver_obj;
 static DEVICE_OBJECT *mouse_obj;
 
 /* The root-enumerated device stack. */
-static DEVICE_OBJECT *bus_pdo, *bus_fdo;
+DEVICE_OBJECT *bus_pdo;
+static DEVICE_OBJECT *bus_fdo;
 
 HANDLE driver_key;
 
@@ -482,6 +483,9 @@ static NTSTATUS fdo_pnp_dispatch(DEVICE_OBJECT *device, IRP *irp)
 
     switch (irpsp->MinorFunction)
     {
+    case IRP_MN_QUERY_DEVICE_RELATIONS:
+        irp->IoStatus.u.Status = handle_IRP_MN_QUERY_DEVICE_RELATIONS(irp);
+        break;
     case IRP_MN_START_DEVICE:
         if (check_bus_option(&SDL_enabled, 1))
         {
@@ -521,11 +525,6 @@ static NTSTATUS pdo_pnp_dispatch(DEVICE_OBJECT *device, IRP *irp)
 
     switch (irpsp->MinorFunction)
     {
-        case IRP_MN_QUERY_DEVICE_RELATIONS:
-            TRACE("IRP_MN_QUERY_DEVICE_RELATIONS\n");
-            status = handle_IRP_MN_QUERY_DEVICE_RELATIONS(irp);
-            irp->IoStatus.u.Status = status;
-            break;
         case IRP_MN_QUERY_ID:
             TRACE("IRP_MN_QUERY_ID\n");
             status = handle_IRP_MN_QUERY_ID(device, irp);
-- 
2.17.1

From cf2328c46895754b40bf6017d2c300f7a153d0c4 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 27 Jun 2019 22:30:16 -0500
Subject: [PATCH] winebus.sys: Initialize and teardown the HID backends while
 the bus FDO is still extant.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
---
 dlls/winebus.sys/main.c | 30 +++++++++++++++---------------
 1 file changed, 15 insertions(+), 15 deletions(-)

diff --git a/dlls/winebus.sys/main.c b/dlls/winebus.sys/main.c
index d9ceb83760..b96e38c538 100644
--- a/dlls/winebus.sys/main.c
+++ b/dlls/winebus.sys/main.c
@@ -475,16 +475,31 @@ static NTSTATUS handle_IRP_MN_QUERY_ID(DEVICE_OBJECT *device, IRP *irp)
 
 static NTSTATUS fdo_pnp_dispatch(DEVICE_OBJECT *device, IRP *irp)
 {
+    static const WCHAR SDL_enabledW[] = {'E','n','a','b','l','e',' ','S','D','L',0};
+    static const UNICODE_STRING SDL_enabled = {sizeof(SDL_enabledW) - sizeof(WCHAR), sizeof(SDL_enabledW), (WCHAR*)SDL_enabledW};
     IO_STACK_LOCATION *irpsp = IoGetCurrentIrpStackLocation(irp);
     NTSTATUS ret;
 
     switch (irpsp->MinorFunction)
     {
     case IRP_MN_START_DEVICE:
+        if (check_bus_option(&SDL_enabled, 1))
+        {
+            if (sdl_driver_init() == STATUS_SUCCESS)
+                return STATUS_SUCCESS;
+        }
+        udev_driver_init();
+        iohid_driver_init();
+        irp->IoStatus.u.Status = STATUS_SUCCESS;
+        break;
     case IRP_MN_SURPRISE_REMOVAL:
         irp->IoStatus.u.Status = STATUS_SUCCESS;
         break;
     case IRP_MN_REMOVE_DEVICE:
+        udev_driver_unload();
+        iohid_driver_unload();
+        sdl_driver_unload();
+
         irp->IoStatus.u.Status = STATUS_SUCCESS;
         IoSkipCurrentIrpStackLocation(irp);
         ret = IoCallDriver(bus_pdo, irp);
@@ -829,9 +844,6 @@ static NTSTATUS WINAPI driver_add_device(DRIVER_OBJECT *driver, DEVICE_OBJECT *p
 
 static void WINAPI driver_unload(DRIVER_OBJECT *driver)
 {
-    udev_driver_unload();
-    iohid_driver_unload();
-    sdl_driver_unload();
     NtClose(driver_key);
 }
 
@@ -907,8 +919,6 @@ static void mouse_device_create(void)
 
 NTSTATUS WINAPI DriverEntry( DRIVER_OBJECT *driver, UNICODE_STRING *path )
 {
-    static const WCHAR SDL_enabledW[] = {'E','n','a','b','l','e',' ','S','D','L',0};
-    static const UNICODE_STRING SDL_enabled = {sizeof(SDL_enabledW) - sizeof(WCHAR), sizeof(SDL_enabledW), (WCHAR*)SDL_enabledW};
     OBJECT_ATTRIBUTES attr = {0};
     NTSTATUS ret;
 
@@ -927,15 +937,5 @@ NTSTATUS WINAPI DriverEntry( DRIVER_OBJECT *driver, UNICODE_STRING *path )
     driver->DriverExtension->AddDevice = driver_add_device;
     driver->DriverUnload = driver_unload;
 
-    mouse_device_create();
-
-    if (check_bus_option(&SDL_enabled, 1))
-    {
-        if (sdl_driver_init() == STATUS_SUCCESS)
-            return STATUS_SUCCESS;
-    }
-    udev_driver_init();
-    iohid_driver_init();
-
     return STATUS_SUCCESS;
 }
-- 
2.17.1

From f80abf3ac3b0ddc4937a50217c654af38a839560 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 27 Jun 2019 22:30:13 -0500
Subject: [PATCH] winebus.sys: Implement AddDevice().

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
---
 dlls/winebus.sys/main.c | 66 ++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 65 insertions(+), 1 deletion(-)

diff --git a/dlls/winebus.sys/main.c b/dlls/winebus.sys/main.c
index 89ea65bba6..d9ceb83760 100644
--- a/dlls/winebus.sys/main.c
+++ b/dlls/winebus.sys/main.c
@@ -69,8 +69,12 @@ static const WORD PID_XBOX_CONTROLLERS[] =  {
 
 static DRIVER_OBJECT *driver_obj;
 
+
 static DEVICE_OBJECT *mouse_obj;
 
+/* The root-enumerated device stack. */
+static DEVICE_OBJECT *bus_pdo, *bus_fdo;
+
 HANDLE driver_key;
 
 struct pnp_device
@@ -469,7 +473,33 @@ static NTSTATUS handle_IRP_MN_QUERY_ID(DEVICE_OBJECT *device, IRP *irp)
     return status;
 }
 
-static NTSTATUS WINAPI common_pnp_dispatch(DEVICE_OBJECT *device, IRP *irp)
+static NTSTATUS fdo_pnp_dispatch(DEVICE_OBJECT *device, IRP *irp)
+{
+    IO_STACK_LOCATION *irpsp = IoGetCurrentIrpStackLocation(irp);
+    NTSTATUS ret;
+
+    switch (irpsp->MinorFunction)
+    {
+    case IRP_MN_START_DEVICE:
+    case IRP_MN_SURPRISE_REMOVAL:
+        irp->IoStatus.u.Status = STATUS_SUCCESS;
+        break;
+    case IRP_MN_REMOVE_DEVICE:
+        irp->IoStatus.u.Status = STATUS_SUCCESS;
+        IoSkipCurrentIrpStackLocation(irp);
+        ret = IoCallDriver(bus_pdo, irp);
+        IoDetachDevice(bus_pdo);
+        IoDeleteDevice(device);
+        return ret;
+    default:
+        FIXME("Unhandled minor function %#x.\n", irpsp->MinorFunction);
+    }
+
+    IoSkipCurrentIrpStackLocation(irp);
+    return IoCallDriver(bus_pdo, irp);
+}
+
+static NTSTATUS pdo_pnp_dispatch(DEVICE_OBJECT *device, IRP *irp)
 {
     NTSTATUS status = irp->IoStatus.u.Status;
     IO_STACK_LOCATION *irpsp = IoGetCurrentIrpStackLocation(irp);
@@ -498,6 +528,13 @@ static NTSTATUS WINAPI common_pnp_dispatch(DEVICE_OBJECT *device, IRP *irp)
     return status;
 }
 
+static NTSTATUS WINAPI common_pnp_dispatch(DEVICE_OBJECT *device, IRP *irp)
+{
+    if (device == bus_fdo)
+        return fdo_pnp_dispatch(device, irp);
+    return pdo_pnp_dispatch(device, irp);
+}
+
 static NTSTATUS deliver_last_report(struct device_extension *ext, DWORD buffer_length, BYTE* buffer, ULONG_PTR *out_length)
 {
     if (buffer_length < ext->last_report_size)
@@ -522,6 +559,12 @@ static NTSTATUS WINAPI hid_internal_dispatch(DEVICE_OBJECT *device, IRP *irp)
 
     TRACE("(%p, %p)\n", device, irp);
 
+    if (device == bus_fdo)
+    {
+        IoSkipCurrentIrpStackLocation(irp);
+        return IoCallDriver(bus_pdo, irp);
+    }
+
     switch (irpsp->Parameters.DeviceIoControl.IoControlCode)
     {
         case IOCTL_HID_GET_DEVICE_ATTRIBUTES:
@@ -764,6 +807,26 @@ BOOL is_xbox_gamepad(WORD vid, WORD pid)
     return FALSE;
 }
 
+static NTSTATUS WINAPI driver_add_device(DRIVER_OBJECT *driver, DEVICE_OBJECT *pdo)
+{
+    NTSTATUS ret;
+
+    TRACE("driver %p, pdo %p.\n", driver, pdo);
+
+    if ((ret = IoCreateDevice(driver, 0, NULL, FILE_DEVICE_BUS_EXTENDER, 0, FALSE, &bus_fdo)))
+    {
+        ERR("Failed to create FDO, status %#x.\n", ret);
+        return ret;
+    }
+
+    IoAttachDeviceToDeviceStack(bus_fdo, pdo);
+    bus_pdo = pdo;
+
+    bus_fdo->Flags &= ~DO_DEVICE_INITIALIZING;
+
+    return STATUS_SUCCESS;
+}
+
 static void WINAPI driver_unload(DRIVER_OBJECT *driver)
 {
     udev_driver_unload();
@@ -861,6 +924,7 @@ NTSTATUS WINAPI DriverEntry( DRIVER_OBJECT *driver, UNICODE_STRING *path )
 
     driver->MajorFunction[IRP_MJ_PNP] = common_pnp_dispatch;
     driver->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = hid_internal_dispatch;
+    driver->DriverExtension->AddDevice = driver_add_device;
     driver->DriverUnload = driver_unload;
 
     mouse_device_create();
-- 
2.17.1

From 4612f7cbb5fffdacf013eb447e5330c0a2da22d3 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Thu, 27 Jun 2019 22:30:12 -0500
Subject: [PATCH] winebus.inf: Add new INF file and copy it to the INF
 directory.

Signed-off-by: Zebediah Figura <z.figura12@gmail.com>
---
 configure             |  1 +
 configure.ac          |  1 +
 loader/Makefile.in    |  1 +
 loader/wine.inf.in    |  1 +
 loader/winebus.inf.in | 22 ++++++++++++++++++++++
 5 files changed, 26 insertions(+)
 create mode 100644 loader/winebus.inf.in

diff --git a/configure b/configure
index f1de2c4052..11ff21f917 100755
--- a/configure
+++ b/configure
@@ -21032,6 +21032,7 @@ else
 fonts \
 loader/l_intl.nls \
 loader/wine.inf \
+loader/winebus.inf \
 loader/winehid.inf \
 programs/msidb/msidb \
 programs/msiexec/msiexec \
diff --git a/configure.ac b/configure.ac
index a7c45ace73..c1c992cd89 100644
--- a/configure.ac
+++ b/configure.ac
@@ -4035,6 +4035,7 @@ else
 fonts \
 loader/l_intl.nls \
 loader/wine.inf \
+loader/winebus.inf \
 loader/winehid.inf \
 programs/msidb/msidb \
 programs/msiexec/msiexec \
diff --git a/loader/Makefile.in b/loader/Makefile.in
index 3ada656408..11a476103c 100644
--- a/loader/Makefile.in
+++ b/loader/Makefile.in
@@ -10,6 +10,7 @@ SOURCES = \
 	wine.man.in \
 	wine.pl.UTF-8.man.in \
 	wine_info.plist.in \
+	winebus.inf.in \
 	winehid.inf.in
 
 PROGRAMS = $(WINELOADER_PROGRAMS)
diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index c3d3b770b5..63f8cb064e 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -3691,4 +3691,5 @@ inf_section = 17
 l_intl.nls
 
 [inf_section]
+winebus.inf
 winehid.inf
diff --git a/loader/winebus.inf.in b/loader/winebus.inf.in
new file mode 100644
index 0000000000..3950c3dfc4
--- /dev/null
+++ b/loader/winebus.inf.in
@@ -0,0 +1,22 @@
+[Version]
+Signature="$CHICAGO$"
+ClassGuid={4d36e97d-e325-11ce-bfc1-08002be10318}
+Class=System
+
+[Manufacturer]
+Wine=mfg_section
+
+[mfg_section]
+Wine HID bus driver=device_section,root\winebus
+
+[device_section.Services]
+AddService = winebus,0x2,svc_section
+
+[svc_section]
+Description="Wine HID bus driver"
+DisplayName="Wine HID bus"
+ServiceBinary="%12%\winebus.sys"
+LoadOrderGroup="WinePlugPlay"
+ServiceType=1
+StartType=3
+ErrorControl=1
-- 
2.17.1


