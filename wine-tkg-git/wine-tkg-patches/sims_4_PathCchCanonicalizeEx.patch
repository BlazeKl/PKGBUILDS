diff --git a/dlls/api-ms-win-core-path-l1-1-0/api-ms-win-core-path-l1-1-0.spec b/dlls/api-ms-win-core-path-l1-1-0/api-ms-win-core-path-l1-1-0.spec
index 0524e7c304..796b57f457 100644
--- a/dlls/api-ms-win-core-path-l1-1-0/api-ms-win-core-path-l1-1-0.spec
+++ b/dlls/api-ms-win-core-path-l1-1-0/api-ms-win-core-path-l1-1-0.spec
@@ -1,22 +1,22 @@
-@ stub PathAllocCanonicalize
-@ stub PathAllocCombine
+@ stdcall PathAllocCanonicalize(wstr long ptr) kernelbase.PathAllocCanonicalize
+@ stdcall PathAllocCombine(wstr wstr long ptr) kernelbase.PathAllocCombine
 @ stdcall PathCchAddBackslash(wstr long) kernelbase.PathCchAddBackslash
 @ stdcall PathCchAddBackslashEx(wstr long ptr ptr) kernelbase.PathCchAddBackslashEx
 @ stdcall PathCchAddExtension(wstr long wstr) kernelbase.PathCchAddExtension
 @ stub PathCchAppend
-@ stub PathCchAppendEx
-@ stub PathCchCanonicalize
-@ stub PathCchCanonicalizeEx
-@ stub PathCchCombine
-@ stub PathCchCombineEx
+@ stdcall PathCchAppendEx(wstr long wstr long) kernelbase.PathCchAppendEx
+@ stdcall PathCchCanonicalize(ptr long wstr) kernelbase.PathCchCanonicalize
+@ stdcall PathCchCanonicalizeEx(ptr long wstr long) kernelbase.PathCchCanonicalizeEx
+@ stdcall PathCchCombine(ptr long wstr wstr) kernelbase.PathCchCombine
+@ stdcall PathCchCombineEx(ptr long wstr wstr long) kernelbase.PathCchCombineEx
 @ stdcall PathCchFindExtension(wstr long ptr) kernelbase.PathCchFindExtension
-@ stub PathCchIsRoot
-@ stub PathCchRemoveBackslash
-@ stub PathCchRemoveBackslashEx
+@ stdcall PathCchIsRoot(wstr) kernelbase.PathCchIsRoot
+@ stdcall PathCchRemoveBackslash(wstr long) kernelbase.PathCchRemoveBackslash
+@ stdcall PathCchRemoveBackslashEx(wstr long ptr ptr) kernelbase.PathCchRemoveBackslashEx
 @ stdcall PathCchRemoveExtension(wstr long) kernelbase.PathCchRemoveExtension
-@ stub PathCchRemoveFileSpec
+@ stdcall PathCchRemoveFileSpec(wstr long) kernelbase.PathCchRemoveFileSpec
 @ stdcall PathCchRenameExtension(wstr long wstr) kernelbase.PathCchRenameExtension
-@ stub PathCchSkipRoot
-@ stub PathCchStripPrefix
-@ stub PathCchStripToRoot
-@ stub PathIsUNCEx
+@ stdcall PathCchSkipRoot(wstr ptr) kernelbase.PathCchSkipRoot
+@ stdcall PathCchStripPrefix(wstr long) kernelbase.PathCchStripPrefix
+@ stdcall PathCchStripToRoot(wstr long) kernelbase.PathCchStripToRoot
+@ stdcall PathIsUNCEx(wstr ptr) kernelbase.PathIsUNCEx
diff --git a/dlls/kernelbase/kernelbase.spec b/dlls/kernelbase/kernelbase.spec
index 286dae0001..04023e31b6 100644
--- a/dlls/kernelbase/kernelbase.spec
+++ b/dlls/kernelbase/kernelbase.spec
@@ -1023,8 +1023,8 @@
 @ stdcall PathAddBackslashW(wstr) shlwapi.PathAddBackslashW
 @ stdcall PathAddExtensionA(str str) shlwapi.PathAddExtensionA
 @ stdcall PathAddExtensionW(wstr wstr) shlwapi.PathAddExtensionW
-# @ stub PathAllocCanonicalize
-# @ stub PathAllocCombine
+@ stdcall PathAllocCanonicalize(wstr long ptr)
+@ stdcall PathAllocCombine(wstr wstr long ptr)
 @ stdcall PathAppendA(str str) shlwapi.PathAppendA
 @ stdcall PathAppendW(wstr wstr) shlwapi.PathAppendW
 @ stdcall PathCanonicalizeA(ptr str) shlwapi.PathCanonicalizeA
@@ -1033,21 +1033,21 @@
 @ stdcall PathCchAddBackslashEx(wstr long ptr ptr)
 @ stdcall PathCchAddExtension(wstr long wstr)
 # @ stub PathCchAppend
-# @ stub PathCchAppendEx
-# @ stub PathCchCanonicalize
-# @ stub PathCchCanonicalizeEx
-# @ stub PathCchCombine
-# @ stub PathCchCombineEx
+@ stdcall PathCchAppendEx(wstr long wstr long)
+@ stdcall PathCchCanonicalize(ptr long wstr)
+@ stdcall PathCchCanonicalizeEx(ptr long wstr long)
+@ stdcall PathCchCombine(ptr long wstr wstr)
+@ stdcall PathCchCombineEx(ptr long wstr wstr long)
 @ stdcall PathCchFindExtension(wstr long ptr)
-# @ stub PathCchIsRoot
-# @ stub PathCchRemoveBackslash
-# @ stub PathCchRemoveBackslashEx
+@ stdcall PathCchIsRoot(wstr)
+@ stdcall PathCchRemoveBackslash(wstr long)
+@ stdcall PathCchRemoveBackslashEx(wstr long ptr ptr)
 @ stdcall PathCchRemoveExtension(wstr long)
-# @ stub PathCchRemoveFileSpec
+@ stdcall PathCchRemoveFileSpec(wstr long)
 @ stdcall PathCchRenameExtension(wstr long wstr)
-# @ stub PathCchSkipRoot
-# @ stub PathCchStripPrefix
-# @ stub PathCchStripToRoot
+@ stdcall PathCchSkipRoot(wstr ptr)
+@ stdcall PathCchStripPrefix(wstr long)
+@ stdcall PathCchStripToRoot(wstr long)
 @ stdcall PathCombineA(ptr str str) shlwapi.PathCombineA
 @ stdcall PathCombineW(ptr wstr wstr) shlwapi.PathCombineW
 @ stdcall PathCommonPrefixA(str str ptr) shlwapi.PathCommonPrefixA
@@ -1082,7 +1082,7 @@
 @ stdcall PathIsSameRootA(str str) shlwapi.PathIsSameRootA
 @ stdcall PathIsSameRootW(wstr wstr) shlwapi.PathIsSameRootW
 @ stdcall PathIsUNCA(str) shlwapi.PathIsUNCA
-# @ stub PathIsUNCEx
+@ stdcall PathIsUNCEx(wstr ptr)
 @ stdcall PathIsUNCServerA(str) shlwapi.PathIsUNCServerA
 @ stdcall PathIsUNCServerShareA(str) shlwapi.PathIsUNCServerShareA
 @ stdcall PathIsUNCServerShareW(wstr) shlwapi.PathIsUNCServerShareW
diff --git a/dlls/kernelbase/path.c b/dlls/kernelbase/path.c
index 047017eb47..22eeb7e594 100644
--- a/dlls/kernelbase/path.c
+++ b/dlls/kernelbase/path.c
@@ -38,6 +38,341 @@ static SIZE_T strnlenW(const WCHAR *string, SIZE_T maxlen)
     return i;
 }
 
+static BOOL is_prefixed_unc(const WCHAR *string)
+{
+    static const WCHAR prefixed_unc[] = {'\\', '\\', '?', '\\', 'U', 'N', 'C', '\\'};
+    return !memicmpW(string, prefixed_unc, ARRAY_SIZE(prefixed_unc));
+}
+
+static BOOL is_prefixed_disk(const WCHAR *string)
+{
+    static const WCHAR prefix[] = {'\\', '\\', '?', '\\'};
+    return !memcmp(string, prefix, sizeof(prefix)) && isalphaW(string[4]) && string[5] == ':';
+}
+
+static BOOL is_prefixed_volume(const WCHAR *string)
+{
+    static const WCHAR prefixed_volume[] = {'\\', '\\', '?', '\\', 'V', 'o', 'l', 'u', 'm', 'e'};
+    const WCHAR *guid;
+    INT ret;
+    INT i = 0;
+
+    ret = memicmpW(string, prefixed_volume, ARRAY_SIZE(prefixed_volume));
+    if (ret) return FALSE;
+
+    guid = string + ARRAY_SIZE(prefixed_volume);
+
+    while (i <= 37)
+    {
+        switch (i)
+        {
+        case 0:
+            if (guid[i] != '{') return FALSE;
+            break;
+        case 9:
+        case 14:
+        case 19:
+        case 24:
+            if (guid[i] != '-') return FALSE;
+            break;
+        case 37:
+            if (guid[i] != '}') return FALSE;
+            break;
+        default:
+            if (!isalnumW(guid[i])) return FALSE;
+            break;
+        }
+        i++;
+    }
+
+    return TRUE;
+}
+
+/* Get the next character beyond end of the segment.
+   Return TRUE if the last segment ends with a backslash */
+static BOOL get_next_segment(const WCHAR *next, const WCHAR **next_segment)
+{
+    while (*next && *next != '\\') next++;
+    if (*next == '\\')
+    {
+        *next_segment = next + 1;
+        return TRUE;
+    }
+    else
+    {
+        *next_segment = next;
+        return FALSE;
+    }
+}
+
+/* Find the last character of the root in a path, if there is one, without any segments */
+static const WCHAR *get_root_end(const WCHAR *path)
+{
+    /* Find path root */
+    if (is_prefixed_volume(path))
+        return path[48] == '\\' ? path + 48 : path + 47;
+    else if (is_prefixed_unc(path))
+        return path + 7;
+    else if (is_prefixed_disk(path))
+        return path[6] == '\\' ? path + 6 : path + 5;
+    /* \\ */
+    else if (path[0] == '\\' && path[1] == '\\')
+        return path + 1;
+    /* \ */
+    else if (path[0] == '\\')
+        return path;
+    /* X:\ */
+    else if (isalphaW(path[0]) && path[1] == ':')
+        return path[2] == '\\' ? path + 2 : path + 1;
+    else
+        return NULL;
+}
+
+HRESULT WINAPI PathAllocCanonicalize(const WCHAR *path_in, DWORD flags, WCHAR **path_out)
+{
+    WCHAR *buffer, *dst;
+    const WCHAR *src;
+    const WCHAR *root_end;
+    SIZE_T buffer_size, length;
+
+    TRACE("%s %#x %p\n", debugstr_w(path_in), flags, path_out);
+
+    if (!path_in || !path_out
+        || ((flags & PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS) && (flags & PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS))
+        || (flags & (PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS | PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS)
+            && !(flags & PATHCCH_ALLOW_LONG_PATHS))
+        || ((flags & PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH) && (flags & PATHCCH_ALLOW_LONG_PATHS)))
+    {
+        if (path_out) *path_out = NULL;
+        return E_INVALIDARG;
+    }
+
+    length = strlenW(path_in);
+    if ((length + 1 > MAX_PATH && !(flags & (PATHCCH_ALLOW_LONG_PATHS | PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH)))
+        || (length + 1 > PATHCCH_MAX_CCH))
+    {
+        *path_out = NULL;
+        return HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
+    }
+
+    /* PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH implies PATHCCH_DO_NOT_NORMALIZE_SEGMENTS */
+    if (flags & PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH) flags |= PATHCCH_DO_NOT_NORMALIZE_SEGMENTS;
+
+    /* path length + possible \\?\ addition + possible \ addition + NUL */
+    buffer_size = (length + 6) * sizeof(WCHAR);
+    buffer = LocalAlloc(LMEM_ZEROINIT, buffer_size);
+    if (!buffer)
+    {
+        *path_out = NULL;
+        return E_OUTOFMEMORY;
+    }
+
+    src = path_in;
+    dst = buffer;
+
+    root_end = get_root_end(path_in);
+    if (root_end) root_end = buffer + (root_end - path_in);
+
+    /* Copy path root */
+    if (root_end)
+    {
+        memcpy(dst, src, (root_end - buffer + 1) * sizeof(WCHAR));
+        src += root_end - buffer + 1;
+        if(PathCchStripPrefix(dst, length + 6) == S_OK)
+        {
+            /* Fill in \ in X:\ if the \ is missing */
+            if(isalphaW(dst[0]) && dst[1] == ':' && dst[2]!= '\\')
+            {
+                dst[2] = '\\';
+                dst[3] = 0;
+            }
+            dst = buffer + strlenW(buffer);
+            root_end = dst;
+        }
+        else
+            dst += root_end - buffer + 1;
+    }
+
+    while (*src)
+    {
+        if (src[0] == '.')
+        {
+            if (src[1] == '.')
+            {
+                /* Keep one . after * */
+                if (dst > buffer && dst[-1] == '*')
+                {
+                    *dst++ = *src++;
+                    continue;
+                }
+
+                /* Keep the . if one of the following is true:
+                 * 1. PATHCCH_DO_NOT_NORMALIZE_SEGMENTS
+                 * 2. in form of a..b,
+                 */
+                if (dst > buffer
+                    && (((flags & PATHCCH_DO_NOT_NORMALIZE_SEGMENTS) && dst[-1] != '\\')
+                        || (dst[-1] != '\\' && src[2] != '\\' && src[2])))
+                {
+                    *dst++ = *src++;
+                    *dst++ = *src++;
+                    continue;
+                }
+
+                /* Remove the \ before .. if the \ is not part of root */
+                if (dst > buffer && dst[-1] == '\\' && (!root_end || dst - 1 > root_end))
+                {
+                    *--dst = '\0';
+                    /* Remove characters until a \ is encountered */
+                    while (dst > buffer)
+                    {
+                        if (dst[-1] == '\\')
+                        {
+                            *--dst = 0;
+                            break;
+                        }
+                        else
+                            *--dst = 0;
+                    }
+                }
+                /* Remove the extra \ after .. if the \ before .. wasn't deleted */
+                else if (src[2] == '\\')
+                    src++;
+
+                src += 2;
+            }
+            else
+            {
+                /* Keep the . if one of the following is true:
+                 * 1. PATHCCH_DO_NOT_NORMALIZE_SEGMENTS
+                 * 2. in form of a.b, which is used in domain names
+                 * 3. *.
+                 */
+                if (dst > buffer
+                    && ((flags & PATHCCH_DO_NOT_NORMALIZE_SEGMENTS && dst[-1] != '\\')
+                        || (dst[-1] != '\\' && src[1] != '\\' && src[1]) || (dst[-1] == '*')))
+                {
+                    *dst++ = *src++;
+                    continue;
+                }
+
+                /* Remove the \ before . if the \ is not part of root */
+                if (dst > buffer && dst[-1] == '\\' && (!root_end || dst - 1 > root_end)) dst--;
+                /* Remove the extra \ after . if the \ before . wasn't deleted */
+                else if (src[1] == '\\')
+                    src++;
+
+                src++;
+            }
+
+            /* If X:\ is not complete, then complete it */
+            if (isalphaW(buffer[0]) && buffer[1] == ':' && buffer[2] != '\\')
+            {
+                root_end = buffer + 2;
+                dst = buffer + 3;
+                buffer[2] = '\\';
+                /* If next character is \, use the \ to fill in */
+                if (src[0] == '\\') src++;
+            }
+        }
+        /* Copy over */
+        else
+            *dst++ = *src++;
+    }
+    /* End the path */
+    *dst = 0;
+
+    /* If result path is empty, fill in \ */
+    if (!*buffer)
+    {
+        buffer[0] = '\\';
+        buffer[1] = 0;
+    }
+
+    /* Extend the path if needed */
+    length = strlenW(buffer);
+    if (((length + 1 > MAX_PATH && isalphaW(buffer[0]) && buffer[1] == ':')
+         || (isalphaW(buffer[0]) && buffer[1] == ':' && flags & PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH))
+        && !(flags & PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS))
+    {
+        memmove(buffer + 4, buffer, (length + 1) * sizeof(WCHAR));
+        buffer[0] = '\\';
+        buffer[1] = '\\';
+        buffer[2] = '?';
+        buffer[3] = '\\';
+    }
+
+    /* Add a trailing backslash to the path if needed */
+    if (flags & PATHCCH_ENSURE_TRAILING_SLASH)
+        PathCchAddBackslash(buffer, buffer_size);
+
+    *path_out = buffer;
+    return S_OK;
+}
+
+HRESULT WINAPI PathAllocCombine(const WCHAR *path1, const WCHAR *path2, DWORD flags, WCHAR **out)
+{
+    SIZE_T length1, size2;
+    WCHAR *new_path1;
+    BOOL from_path2 = FALSE;
+    HRESULT hr;
+
+    TRACE("%s %s %#x %p\n", wine_dbgstr_w(path1), wine_dbgstr_w(path2), flags, out);
+
+    if ((!path1 && !path2) || !out)
+    {
+        if (out) *out = NULL;
+        return E_INVALIDARG;
+    }
+
+    if (!path1 || !path2)
+    {
+        hr = PathAllocCanonicalize(path1 ? path1 : path2, flags, out);
+        return FAILED(hr) ? hr : S_OK;
+    }
+
+    /* If path2 is fully qualified, use path2 only */
+    if (path2 && ((isalphaW(path2[0]) && path2[1] == ':') || (path2[0] == '\\' && path2[1] == '\\')))
+    {
+        path1 = path2;
+        path2 = NULL;
+        from_path2 = TRUE;
+    }
+
+    size2 = path2 ? strlenW(path2) : 0;
+    /* path1 length + path2 length + possible backslash + NULL */
+    length1 = strlenW(path1) + size2 + 2;
+
+    new_path1 = HeapAlloc(GetProcessHeap(), 0, length1 * sizeof(WCHAR));
+    if(!new_path1)
+    {
+        *out = NULL;
+        return E_OUTOFMEMORY;
+    }
+
+    lstrcpyW(new_path1, path1);
+    PathCchStripPrefix(new_path1, length1);
+    if (from_path2) PathCchAddBackslashEx(new_path1, length1, NULL, NULL);
+
+    if (path2 && path2[0])
+    {
+        PathCchAddBackslashEx(new_path1, length1, NULL, NULL);
+
+        if (path2[0] == '\\' && path2[1] != '\\')
+        {
+            PathCchStripToRoot(new_path1, length1);
+            PathCchAddBackslashEx(new_path1, length1, NULL, NULL);
+            lstrcatW(new_path1, path2 + 1);
+        }
+        else
+            lstrcatW(new_path1, path2);
+    }
+
+    hr = PathAllocCanonicalize(new_path1, flags, out);
+    HeapFree(GetProcessHeap(), 0, new_path1);
+    return FAILED(hr) ? hr : S_OK;
+}
+
 HRESULT WINAPI PathCchAddBackslash(WCHAR *path, SIZE_T size)
 {
     return PathCchAddBackslashEx(path, size, NULL, NULL);
@@ -119,6 +454,120 @@ HRESULT WINAPI PathCchAddExtension(WCHAR *path, SIZE_T size, const WCHAR *extens
     return S_OK;
 }
 
+HRESULT WINAPI PathCchAppendEx(WCHAR *path1, SIZE_T size, const WCHAR *path2, DWORD flags)
+{
+    HRESULT hr;
+    WCHAR *result;
+
+    TRACE("%s %lu %s %#x\n", wine_dbgstr_w(path1), size, wine_dbgstr_w(path2), flags);
+
+    if (!path1 || !size) return E_INVALIDARG;
+
+    /* Create a temporary buffer for result because we need to keep path1 unchanged if error occurs.
+     * And PathCchCombineEx writes empty result if there is error so we can't just use path1 as output
+     * buffer for PathCchCombineEx */
+    result = HeapAlloc(GetProcessHeap(), 0, size * sizeof(WCHAR));
+    if (!result) return E_OUTOFMEMORY;
+
+    /* Avoid the single backslash behavior with PathCchCombineEx when appending */
+    if (path2 && path2[0] == '\\' && path2[1] != '\\') path2++;
+
+    hr = PathCchCombineEx(result, size, path1, path2, flags);
+    if (SUCCEEDED(hr)) memcpy(path1, result, size * sizeof(WCHAR));
+
+    HeapFree(GetProcessHeap(), 0, result);
+    return FAILED(hr) ? hr : S_OK;
+}
+
+HRESULT WINAPI PathCchCanonicalize(WCHAR *out, SIZE_T size, const WCHAR *in)
+{
+    TRACE("%p %lu %s\n", out, size, wine_dbgstr_w(in));
+
+    /* Not X:\ and path > MAX_PATH - 4, return HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE) */
+    if (strlenW(in) > MAX_PATH - 4 && !(isalphaW(in[0]) && in[1] == ':' && in[2] == '\\'))
+        return HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
+
+    return PathCchCanonicalizeEx(out, size, in, PATHCCH_NONE);
+}
+
+HRESULT WINAPI PathCchCanonicalizeEx(WCHAR *out, SIZE_T size, const WCHAR *in, DWORD flags)
+{
+    WCHAR *buffer;
+    SIZE_T length;
+    HRESULT hr;
+
+    TRACE("%p %lu %s %#x\n", out, size, wine_dbgstr_w(in), flags);
+
+    if (!size) return E_INVALIDARG;
+
+    hr = PathAllocCanonicalize(in, flags, &buffer);
+    if (FAILED(hr)) return hr;
+
+    length = strlenW(buffer);
+    if (size < length + 1)
+    {
+        /* No root and path > MAX_PATH - 4, return HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE) */
+        if (length > MAX_PATH - 4 && !(in[0] == '\\' || (isalphaW(in[0]) && in[1] == ':' && in[2] == '\\')))
+            hr = HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
+        else
+            hr = STRSAFE_E_INSUFFICIENT_BUFFER;
+    }
+
+    if (SUCCEEDED(hr))
+    {
+        memcpy(out, buffer, (length + 1) * sizeof(WCHAR));
+
+        /* Fill a backslash at the end of X: */
+        if (isalphaW(out[0]) && out[1] == ':' && !out[2] && size > 3)
+        {
+            out[2] = '\\';
+            out[3] = 0;
+        }
+    }
+
+    LocalFree(buffer);
+    return hr;
+}
+
+HRESULT WINAPI PathCchCombine(WCHAR *out, SIZE_T size, const WCHAR *path1, const WCHAR *path2)
+{
+    TRACE("%p %s %s\n", out, wine_dbgstr_w(path1), wine_dbgstr_w(path2));
+
+    return PathCchCombineEx(out, size, path1, path2, PATHCCH_NONE);
+}
+
+HRESULT WINAPI PathCchCombineEx(WCHAR *out, SIZE_T size, const WCHAR *path1, const WCHAR *path2, DWORD flags)
+{
+    HRESULT hr;
+    WCHAR *buffer;
+    SIZE_T length;
+
+    TRACE("%p %s %s %#x\n", out, wine_dbgstr_w(path1), wine_dbgstr_w(path2), flags);
+
+    if (!out || !size || size > PATHCCH_MAX_CCH) return E_INVALIDARG;
+
+    hr = PathAllocCombine(path1, path2, flags, &buffer);
+    if (FAILED(hr))
+    {
+        out[0] = 0;
+        return hr;
+    }
+
+    length = strlenW(buffer);
+    if (length + 1 > size)
+    {
+        out[0] = 0;
+        HeapFree(GetProcessHeap(), 0, buffer);
+        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
+    }
+    else
+    {
+        memcpy(out, buffer, (length + 1) * sizeof(WCHAR));
+        HeapFree(GetProcessHeap(), 0, buffer);
+        return S_OK;
+    }
+}
+
 HRESULT WINAPI PathCchFindExtension(const WCHAR *path, SIZE_T size, const WCHAR **extension)
 {
     const WCHAR *lastpoint = NULL;
@@ -152,6 +601,93 @@ HRESULT WINAPI PathCchFindExtension(const WCHAR *path, SIZE_T size, const WCHAR
     return S_OK;
 }
 
+BOOL WINAPI PathCchIsRoot(const WCHAR *path)
+{
+    const WCHAR *root_end;
+    const WCHAR *next;
+    BOOL is_unc;
+
+    TRACE("%s\n", wine_dbgstr_w(path));
+
+    if (!path || !*path) return FALSE;
+
+    root_end = get_root_end(path);
+    if (!root_end) return FALSE;
+
+    if ((is_unc = is_prefixed_unc(path)) || (path[0] == '\\' && path[1] == '\\' && path[2] != '?'))
+    {
+        next = root_end + 1;
+        /* No extra segments */
+        if ((is_unc && !*next) || (!is_unc && !*next)) return TRUE;
+
+        /* Has first segment with an ending backslash but no remaining characters */
+        if (get_next_segment(next, &next) && !*next) return FALSE;
+        /* Has first segment with no ending backslash */
+        else if (!*next)
+            return TRUE;
+        /* Has first segment with an ending backslash and has remaining characters*/
+        else
+        {
+            next++;
+            /* Second segment must have no backslash and no remaining characters */
+            return !get_next_segment(next, &next) && !*next;
+        }
+    }
+    else if (*root_end == '\\' && !root_end[1])
+        return TRUE;
+    else
+        return FALSE;
+}
+
+HRESULT WINAPI PathCchRemoveBackslash(WCHAR *path, SIZE_T path_size)
+{
+    WCHAR *path_end;
+    SIZE_T free_size;
+
+    TRACE("%s %lu\n", debugstr_w(path), path_size);
+
+    return PathCchRemoveBackslashEx(path, path_size, &path_end, &free_size);
+}
+
+HRESULT WINAPI PathCchRemoveBackslashEx(WCHAR *path, SIZE_T path_size, WCHAR **path_end, SIZE_T *free_size)
+{
+    const WCHAR *root_end;
+    SIZE_T path_length;
+
+    TRACE("%s %lu %p %p\n", debugstr_w(path), path_size, path_end, free_size);
+
+    if (!path_size || !path_end || !free_size)
+    {
+        if (path_end) *path_end = NULL;
+        if (free_size) *free_size = 0;
+        return E_INVALIDARG;
+    }
+
+    path_length = strnlenW(path, path_size);
+    if (path_length == path_size && !path[path_length]) return E_INVALIDARG;
+
+    root_end = get_root_end(path);
+    if (path_length > 0 && path[path_length - 1] == '\\')
+    {
+        *path_end = path + path_length - 1;
+        *free_size = path_size - path_length + 1;
+        /* If the last character is beyond end of root */
+        if (!root_end || path + path_length - 1 > root_end)
+        {
+            path[path_length - 1] = 0;
+            return S_OK;
+        }
+        else
+            return S_FALSE;
+    }
+    else
+    {
+        *path_end = path + path_length;
+        *free_size = path_size - path_length;
+        return S_FALSE;
+    }
+}
+
 HRESULT WINAPI PathCchRemoveExtension(WCHAR *path, SIZE_T size)
 {
     const WCHAR *extension;
@@ -171,6 +707,43 @@ HRESULT WINAPI PathCchRemoveExtension(WCHAR *path, SIZE_T size)
     return next == extension ? S_FALSE : S_OK;
 }
 
+HRESULT WINAPI PathCchRemoveFileSpec(WCHAR *path, SIZE_T size)
+{
+    const WCHAR *root_end = NULL;
+    SIZE_T length;
+    WCHAR *last;
+
+    TRACE("%s %lu\n", wine_dbgstr_w(path), size);
+
+    if (!path || !size || size > PATHCCH_MAX_CCH) return E_INVALIDARG;
+
+    if (PathCchIsRoot(path)) return S_FALSE;
+
+    PathCchSkipRoot(path, &root_end);
+
+    /* The backslash at the end of UNC and \\* are not considered part of root in this case */
+    if (root_end && root_end > path && root_end[-1] == '\\'
+        && (is_prefixed_unc(path) || (path[0] == '\\' && path[1] == '\\' && path[2] != '?')))
+        root_end--;
+
+    length = strlenW(path);
+    last = path + length - 1;
+    while (last >= path && (!root_end || last >= root_end))
+    {
+        if (last - path >= size) return E_INVALIDARG;
+
+        if (*last == '\\')
+        {
+            *last-- = 0;
+            break;
+        }
+
+        *last-- = 0;
+    }
+
+    return last != path + length - 1 ? S_OK : S_FALSE;
+}
+
 HRESULT WINAPI PathCchRenameExtension(WCHAR *path, SIZE_T size, const WCHAR *extension)
 {
     HRESULT hr;
@@ -183,3 +756,113 @@ HRESULT WINAPI PathCchRenameExtension(WCHAR *path, SIZE_T size, const WCHAR *ext
     hr = PathCchAddExtension(path, size, extension);
     return FAILED(hr) ? hr : S_OK;
 }
+
+HRESULT WINAPI PathCchSkipRoot(const WCHAR *path, const WCHAR **root_end)
+{
+    static const WCHAR unc_prefix[] = {'\\', '\\', '?'};
+
+    TRACE("%s %p\n", debugstr_w(path), root_end);
+
+    if (!path || !path[0] || !root_end
+        || (!memicmpW(unc_prefix, path, ARRAY_SIZE(unc_prefix)) && !is_prefixed_volume(path) && !is_prefixed_unc(path)
+            && !is_prefixed_disk(path)))
+        return E_INVALIDARG;
+
+    *root_end = get_root_end(path);
+    if (*root_end)
+    {
+        (*root_end)++;
+        if (is_prefixed_unc(path))
+        {
+            get_next_segment(*root_end, root_end);
+            get_next_segment(*root_end, root_end);
+        }
+        else if (path[0] == '\\' && path[1] == '\\' && path[2] != '?')
+        {
+            /* Skip share server */
+            get_next_segment(*root_end, root_end);
+            /* If mount point is empty, don't skip over mount point */
+            if (**root_end != '\\') get_next_segment(*root_end, root_end);
+        }
+    }
+
+    return *root_end ? S_OK : E_INVALIDARG;
+}
+
+HRESULT WINAPI PathCchStripPrefix(WCHAR *path, SIZE_T size)
+{
+    TRACE("%s %lu\n", wine_dbgstr_w(path), size);
+
+    if (!path || !size || size > PATHCCH_MAX_CCH) return E_INVALIDARG;
+
+    if (is_prefixed_unc(path))
+    {
+        /* \\?\UNC\a -> \\a */
+        if (size < strlenW(path + 8) + 3) return E_INVALIDARG;
+        strcpyW(path + 2, path + 8);
+        return S_OK;
+    }
+    else if (is_prefixed_disk(path))
+    {
+        /* \\?\C:\ -> C:\ */
+        if (size < strlenW(path + 4) + 1) return E_INVALIDARG;
+        strcpyW(path, path + 4);
+        return S_OK;
+    }
+    else
+        return S_FALSE;
+}
+
+HRESULT WINAPI PathCchStripToRoot(WCHAR *path, SIZE_T size)
+{
+    const WCHAR *root_end;
+    WCHAR *segment_end;
+    BOOL is_unc;
+
+    TRACE("%s %lu\n", wine_dbgstr_w(path), size);
+
+    if (!path || !*path || !size || size > PATHCCH_MAX_CCH) return E_INVALIDARG;
+
+    /* \\\\?\\UNC\\* and \\\\* have to have at least two extra segments to be striped,
+     * e.g. \\\\?\\UNC\\a\\b\\c -> \\\\?\\UNC\\a\\b
+     *      \\\\a\\b\\c         -> \\\\a\\b         */
+    if ((is_unc = is_prefixed_unc(path)) || (path[0] == '\\' && path[1] == '\\' && path[2] != '?'))
+    {
+        root_end = is_unc ? path + 8 : path + 3;
+        if (!get_next_segment(root_end, &root_end)) return S_FALSE;
+        if (!get_next_segment(root_end, &root_end)) return S_FALSE;
+
+        if (root_end - path >= size) return E_INVALIDARG;
+
+        segment_end = path + (root_end - path) - 1;
+        *segment_end = 0;
+        return S_OK;
+    }
+    else if (PathCchSkipRoot(path, &root_end) == S_OK)
+    {
+        if (root_end - path >= size) return E_INVALIDARG;
+
+        segment_end = path + (root_end - path);
+        if (!*segment_end) return S_FALSE;
+
+        *segment_end = 0;
+        return S_OK;
+    }
+    else
+        return E_INVALIDARG;
+}
+
+BOOL WINAPI PathIsUNCEx(const WCHAR *path, const WCHAR **server)
+{
+    const WCHAR *result = NULL;
+
+    TRACE("%s %p\n", wine_dbgstr_w(path), server);
+
+    if (is_prefixed_unc(path))
+        result = path + 8;
+    else if (path[0] == '\\' && path[1] == '\\' && path[2] != '?')
+        result = path + 2;
+
+    if (server) *server = result;
+    return result ? TRUE : FALSE;
+}
diff --git a/dlls/kernelbase/tests/path.c b/dlls/kernelbase/tests/path.c
index 1d6f44ee76..7eff319ae4 100644
--- a/dlls/kernelbase/tests/path.c
+++ b/dlls/kernelbase/tests/path.c
@@ -30,21 +30,340 @@
 
 #include "wine/test.h"
 
+HRESULT (WINAPI *pPathAllocCanonicalize)(const WCHAR *path_in, DWORD flags, WCHAR **path_out);
+HRESULT (WINAPI *pPathAllocCombine)(const WCHAR *path1, const WCHAR *path2, DWORD flags, WCHAR **out);
 HRESULT (WINAPI *pPathCchAddBackslash)(WCHAR *out, SIZE_T size);
 HRESULT (WINAPI *pPathCchAddBackslashEx)(WCHAR *out, SIZE_T size, WCHAR **endptr, SIZE_T *remaining);
 HRESULT (WINAPI *pPathCchAddExtension)(WCHAR *path, SIZE_T size, const WCHAR *extension);
+HRESULT (WINAPI *pPathCchAppendEx)(WCHAR *path1, SIZE_T size, const WCHAR *path2, DWORD flags);
+HRESULT (WINAPI *pPathCchCombine)(WCHAR *out, SIZE_T size, const WCHAR *path1, const WCHAR *path2);
+HRESULT (WINAPI *pPathCchCombineEx)(WCHAR *out, SIZE_T size, const WCHAR *path1, const WCHAR *path2, DWORD flags);
+HRESULT (WINAPI *pPathCchCanonicalize)(WCHAR *out, SIZE_T size, const WCHAR *in);
+HRESULT (WINAPI *pPathCchCanonicalizeEx)(WCHAR *out, SIZE_T size, const WCHAR *in, DWORD flags);
 HRESULT (WINAPI *pPathCchCombineEx)(WCHAR *out, SIZE_T size, const WCHAR *path1, const WCHAR *path2, DWORD flags);
 HRESULT (WINAPI *pPathCchFindExtension)(const WCHAR *path, SIZE_T size, const WCHAR **extension);
+BOOL    (WINAPI *pPathCchIsRoot)(const WCHAR *path);
+HRESULT (WINAPI *pPathCchRemoveBackslash)(WCHAR *path, SIZE_T path_size);
+HRESULT (WINAPI *pPathCchRemoveBackslashEx)(WCHAR *path, SIZE_T path_size, WCHAR **path_end, SIZE_T *free_size);
 HRESULT (WINAPI *pPathCchRemoveExtension)(WCHAR *path, SIZE_T size);
+HRESULT (WINAPI *pPathCchRemoveFileSpec)(WCHAR *path, SIZE_T size);
 HRESULT (WINAPI *pPathCchRenameExtension)(WCHAR *path, SIZE_T size, const WCHAR *extension);
+HRESULT (WINAPI *pPathCchSkipRoot)(const WCHAR *path, const WCHAR **root_end);
+HRESULT (WINAPI *pPathCchStripPrefix)(WCHAR *path, SIZE_T size);
+HRESULT (WINAPI *pPathCchStripToRoot)(WCHAR *path, SIZE_T size);
+BOOL    (WINAPI *pPathIsUNCEx)(const WCHAR *path, const WCHAR **server);
 
-static const struct
+struct alloccanonicalize_test
 {
-    const char *path1;
-    const char *path2;
-    const char *result;
+    const CHAR *path_in;
+    const CHAR *path_out;
+    DWORD flags;
+    HRESULT hr;
+};
+
+static const struct alloccanonicalize_test alloccanonicalize_tests[] =
+{
+    /* Malformed path */
+    {"C:a", "C:a", 0, S_OK},
+    {"\\\\?\\C:", "C:\\", 0, S_OK},
+    {"\\\\?C:\\a", "\\\\?C:\\a", 0, S_OK},
+    {"\\\\?UNC\\a", "\\\\?UNC\\a", 0, S_OK},
+    {"\\\\?\\UNCa", "\\\\?\\UNCa", 0, S_OK},
+    {"\\\\?C:a", "\\\\?C:a", 0, S_OK},
+
+    /* No . */
+    {"", "\\", 0, S_OK},
+    {"C:", "C:", 0, S_OK},
+    {"C:\\", "C:\\", 0, S_OK},
+    {"\\\\?\\C:\\a", "C:\\a", 0, S_OK},
+    {"\\\\?\\UNC\\a", "\\\\a", 0, S_OK},
+
+    /* . */
+    {".", "\\", 0, S_OK},
+    {"..", "\\", 0, S_OK},
+    {"...", "\\", 0, S_OK},
+    {"*.", "*.", 0, S_OK},
+    {"*..", "*.", 0, S_OK},
+    {"*...", "*.", 0, S_OK},
+    {"a.", "a", 0, S_OK},
+    {"a.b", "a.b", 0, S_OK},
+    {"a\\.", "a", 0, S_OK},
+    {"a\\.\\b", "a\\b", 0, S_OK},
+    {"C:.", "C:\\", 0, S_OK},
+    {"C:\\.", "C:\\", 0, S_OK},
+    {"C:\\.\\", "C:\\", 0, S_OK},
+    {"C:\\a.", "C:\\a", 0, S_OK},
+    {"C:\\a\\.", "C:\\a", 0, S_OK},
+    {"C:\\a\\\\.", "C:\\a\\", 0, S_OK},
+    {"C:\\a\\\\\\.", "C:\\a\\\\", 0, S_OK},
+    {"\\.", "\\", 0, S_OK},
+    {"\\\\.", "\\\\", 0, S_OK},
+    {"\\\\.\\", "\\\\", 0, S_OK},
+    {"\\\\\\.", "\\\\", 0, S_OK},
+    {"\\\\.\\\\", "\\\\\\", 0, S_OK},
+    {"\\\\\\\\.", "\\\\\\", 0, S_OK},
+    {"\\?\\.", "\\?", 0, S_OK},
+    {"\\\\?\\.", "\\\\?", 0, S_OK},
+    {"\\192.168.1.1\\a", "\\192.168.1.1\\a", 0, S_OK},
+    {"\\a.168.1.1\\a", "\\a.168.1.1\\a", 0, S_OK},
+    {"\\\\192.168.1.1\\a", "\\\\192.168.1.1\\a", 0, S_OK},
+    {"\\\\a.168.1.1\\b", "\\\\a.168.1.1\\b", 0, S_OK},
+    {"\\\\?\\C:.", "C:\\", 0, S_OK},
+    {"\\\\?\\C:\\.", "C:\\", 0, S_OK},
+    {"\\\\?\\UNC\\.", "\\\\", 0, S_OK},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\.",
+      "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\", 0, S_OK},
+
+    /* .. */
+    {"a..", "a", 0, S_OK},
+    {"a..b", "a..b", 0, S_OK},
+    {"a\\..", "\\", 0, S_OK},
+    {"a\\..\\", "\\", 0, S_OK},
+    {"a\\..\\b", "\\b", 0, S_OK},
+    {"C:..", "C:\\", 0, S_OK},
+    {"C:\\..", "C:\\", 0, S_OK},
+    {"C:\\\\..", "C:\\", 0, S_OK},
+    {"C:\\..\\", "C:\\", 0, S_OK},
+    {"C:\\a\\..", "C:\\", 0, S_OK},
+    {"C:\\a\\\\..", "C:\\a", 0, S_OK},
+    {"C:\\a\\\\\\..", "C:\\a\\", 0, S_OK},
+    {"C:\\a\\..\\b", "C:\\b", 0, S_OK},
+    {"C:\\a\\..\\\\b", "C:\\\\b", 0, S_OK},
+    {"\\..", "\\", 0, S_OK},
+    {"\\\\..", "\\\\", 0, S_OK},
+    {"\\\\\\..", "\\", 0, S_OK},
+    {"\\\\..\\", "\\\\", 0, S_OK},
+    {"\\\\\\..", "\\", 0, S_OK},
+    {"\\\\..\\\\", "\\\\\\", 0, S_OK},
+    {"\\\\\\\\..", "\\\\", 0, S_OK},
+    {"\\?\\..", "\\", 0, S_OK},
+    {"\\a\\..", "\\", 0, S_OK},
+    {"\\\\?\\..", "\\", 0, S_OK},
+    {"\\\\a\\..", "\\", 0, S_OK},
+    {"\\a\\..\\b", "\\b", 0, S_OK},
+    {"\\a\\b\\..", "\\a", 0, S_OK},
+    {"\\?\\UNC\\..", "\\?", 0, S_OK},
+    {"\\?\\C:\\..", "\\?", 0, S_OK},
+    {"\\\\?\\C:..", "C:\\", 0, S_OK},
+    {"\\\\?\\C:\\..", "C:\\", 0, S_OK},
+    {"\\\\?\\UNC\\..", "\\\\", 0, S_OK},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}..",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}", 0, S_OK},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\..",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\", 0, S_OK},
+    {"\\\\?\\UNC\\a\\b\\..", "\\\\a", 0, S_OK},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a\\b\\..",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a", 0, S_OK},
+
+    /* . and .. */
+    {"C:\\a\\.\\b\\..\\", "C:\\a\\", 0, S_OK},
+    {"\\a\\.\\b\\..\\", "\\a\\", 0, S_OK},
+    {"\\?\\a\\.\\b\\..\\", "\\?\\a\\", 0, S_OK},
+    {"\\\\.\\a\\.\\b\\..\\", "\\\\a\\", 0, S_OK},
+    {"\\\\?\\a\\.\\b\\..\\", "\\\\?\\a\\", 0, S_OK},
+    {"\\\\.\\..", "\\\\", 0, S_OK},
+
+    /* PATHCCH_ALLOW_LONG_PATHS */
+    /* Input path with prefix \\?\ and length of MAXPATH + 1, HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE) = 0x800700ce */
+    {"\\\\?\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", NULL, 0, 0x800700ce},
+    /* Input path with prefix C:\ and length of MAXPATH + 1 */
+    {"C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", NULL, 0, 0x800700ce},
+    {"C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "\\\\?\\C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", PATHCCH_ALLOW_LONG_PATHS, S_OK},
+    /* Input path with prefix C: and length of MAXPATH + 1  */
+    {"C:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "\\\\?\\C:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", PATHCCH_ALLOW_LONG_PATHS, S_OK},
+    /* Input path with prefix C:\ and length of MAXPATH + 1 and with .. */
+    {"C:\\..\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", PATHCCH_ALLOW_LONG_PATHS, S_OK},
+    /* Input path with prefix \\?\ and length of MAXPATH + 1 */
+    {"\\\\?\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "\\\\?\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", PATHCCH_ALLOW_LONG_PATHS, S_OK},
+    /* Input path with prefix \ and length of MAXPATH + 1 */
+    {"\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", PATHCCH_ALLOW_LONG_PATHS, S_OK},
+    /* Input path with length of MAXPATH with PATHCCH_ALLOW_LONG_PATHS disabled*/
+    {"C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", 0, S_OK},
+    /* Input path with length of MAXPATH */
+    {"C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", PATHCCH_ALLOW_LONG_PATHS, S_OK},
+
+    /* Flags added after Windows 10 1709 */
+    /* PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS */
+    /* PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS without PATHCCH_ALLOW_LONG_PATHS */
+    {"", NULL, PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS, E_INVALIDARG},
+    /* Input path with prefix C:\ and length of MAXPATH + 1 and PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS */
+    {"C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
+     PATHCCH_ALLOW_LONG_PATHS | PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS, S_OK},
+
+    /* PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS */
+    /* PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS without PATHCCH_ALLOW_LONG_PATHS */
+    {"", NULL, PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS, E_INVALIDARG},
+    /* Both PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS and PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS */
+    {"", "\\", PATHCCH_ALLOW_LONG_PATHS | PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS | PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS,
+     E_INVALIDARG},
+    /* Input path with prefix C:\ and length of MAXPATH + 1 and PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS */
+    {"C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "\\\\?\\C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
+     PATHCCH_ALLOW_LONG_PATHS | PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS, S_OK},
+    /* Input path with prefix C:\ and length of MAXPATH and PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS */
+    {"C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
+    PATHCCH_ALLOW_LONG_PATHS | PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS, S_OK},
+
+    /* PATHCCH_DO_NOT_NORMALIZE_SEGMENTS */
+    /* No effect for spaces */
+    {"C:\\a \\", "C:\\a \\", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"C:\\a\\ ", "C:\\a\\ ", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"C:\\a ", "C:\\a ", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"C:\\a  ", "C:\\a  ", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"C:\\a. ", "C:\\a. ", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"\\a \\", "\\a \\", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"\\a\\ ", "\\a\\ ", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"\\\\a \\", "\\\\a \\", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"\\\\a\\ ", "\\\\a\\ ", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"\\\\?\\ ", "\\\\?\\ ", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    /* Keep trailing dot */
+    {"*..", "*..", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {".", "\\", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"..", "\\", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"C:.", "C:.", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"C:..", "C:..", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"C:\\a\\.", "C:\\a", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"C:\\a\\..", "C:\\", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"C:\\a.", "C:\\a.", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"C:\\a..", "C:\\a..", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+
+    /* PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH */
+    {"C:\\a\\", "\\\\?\\C:\\a\\", PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH, S_OK},
+    {"", NULL, PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH | PATHCCH_ALLOW_LONG_PATHS, E_INVALIDARG},
+    {"\\a\\", "\\a\\", PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH, S_OK},
+    {"\\\\?\\C:\\a\\", "\\\\?\\C:\\a\\", PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH, S_OK},
+    /* Implication of PATHCCH_DO_NOT_NORMALIZE_SEGMENTS by PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH */
+    {"\\a.", "\\a.", PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH, S_OK},
+
+    /* PATHCCH_ENSURE_TRAILING_SLASH */
+    {"\\", "\\", PATHCCH_ENSURE_TRAILING_SLASH, S_OK},
+    {"C:\\", "C:\\", PATHCCH_ENSURE_TRAILING_SLASH, S_OK},
+    {"C:\\a\\.", "C:\\a\\", PATHCCH_ENSURE_TRAILING_SLASH, S_OK},
+    {"C:\\a", "C:\\a\\", PATHCCH_ENSURE_TRAILING_SLASH, S_OK}
+};
+
+static void test_PathAllocCanonicalize(void)
+{
+    WCHAR path_inW[1024], path_maxW[PATHCCH_MAX_CCH + 1];
+    WCHAR *path_outW;
+    CHAR path_outA[1024];
+    BOOL skip_new_flags = TRUE;
+    HRESULT hr;
+    INT i;
+
+    if (!pPathAllocCanonicalize)
+    {
+        win_skip("PathAllocCanonicalize() is not available.\n");
+        return;
+    }
+
+    /* No NULL check for path on Windows */
+    if (0)
+    {
+        hr = pPathAllocCanonicalize(NULL, 0, &path_outW);
+        ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+    }
+
+    MultiByteToWideChar(CP_ACP, 0, "C:\\", -1, path_inW, ARRAY_SIZE(path_inW));
+    hr = pPathAllocCanonicalize(path_inW, 0, NULL);
+    ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+
+    /* Test longest path */
+    for (i = 0; i < ARRAY_SIZE(path_maxW) - 1; i++) path_maxW[i] = 'a';
+    path_maxW[PATHCCH_MAX_CCH] = '\0';
+    path_outW = (WCHAR *)0xdeadbeef;
+    hr = pPathAllocCanonicalize(path_maxW, PATHCCH_ALLOW_LONG_PATHS, &path_outW);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE), "expect hr %#x, got %#x\n",
+       HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE), hr);
+    ok(path_outW == NULL, "expect path_outW null, got %p\n", path_outW);
+
+    path_maxW[PATHCCH_MAX_CCH - 1] = '\0';
+    hr = pPathAllocCanonicalize(path_maxW, PATHCCH_ALLOW_LONG_PATHS, &path_outW);
+    ok(hr == S_OK, "expect hr %#x, got %#x\n", S_OK, hr);
+
+    /* Check if flags added after Windows 10 1709 are supported */
+    MultiByteToWideChar(CP_ACP, 0, "C:\\", -1, path_inW, ARRAY_SIZE(path_inW));
+    hr = pPathAllocCanonicalize(path_inW, PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS, &path_outW);
+    if (hr == E_INVALIDARG) skip_new_flags = FALSE;
+
+    for (i = 0; i < ARRAY_SIZE(alloccanonicalize_tests); i++)
+    {
+        const struct alloccanonicalize_test *t = alloccanonicalize_tests + i;
+
+        if (((PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS | PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS
+              | PATHCCH_DO_NOT_NORMALIZE_SEGMENTS | PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH
+              | PATHCCH_ENSURE_TRAILING_SLASH)
+             & t->flags)
+            && skip_new_flags)
+        {
+            win_skip("Skip testing new flags added after Windows 10 1709\n");
+            return;
+        }
+
+        MultiByteToWideChar(CP_ACP, 0, t->path_in, -1, path_inW, ARRAY_SIZE(path_inW));
+        hr = pPathAllocCanonicalize(path_inW, t->flags, &path_outW);
+        ok(hr == t->hr, "path %s expect result %#x, got %#x\n", t->path_in, t->hr, hr);
+        if (SUCCEEDED(hr))
+        {
+            WideCharToMultiByte(CP_ACP, 0, path_outW, -1, path_outA, ARRAY_SIZE(path_outA), NULL, NULL);
+            ok(!lstrcmpA(path_outA, t->path_out), "path \"%s\" expect output path \"%s\", got \"%s\"\n", t->path_in,
+               t->path_out, path_outA);
+            LocalFree(path_outW);
+        }
+    }
 }
-combine_test[] =
+
+struct combine_test
+{
+    const CHAR *path1;
+    const CHAR *path2;
+    const CHAR *result;
+};
+
+static const struct combine_test combine_tests[] =
 {
     /* normal paths */
     {"C:\\",  "a",     "C:\\a" },
@@ -52,38 +371,197 @@ combine_test[] =
     {"C:",    "a",     "C:\\a" },
     {"C:\\",  ".",     "C:\\" },
     {"C:\\",  "..",    "C:\\" },
-    {"\\a",   "b",      "\\a\\b" },
+    {"C:\\a",  "",     "C:\\a" },
 
     /* normal UNC paths */
     {"\\\\192.168.1.1\\test", "a",  "\\\\192.168.1.1\\test\\a" },
     {"\\\\192.168.1.1\\test", "..", "\\\\192.168.1.1" },
+    {"\\a",   "b",      "\\a\\b" },
+    {"\\", "a", "\\a"},
+    {"\\\\", "a", "\\\\a"},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\", "a",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a"},
 
     /* NT paths */
     {"\\\\?\\C:\\", "a",  "C:\\a" },
     {"\\\\?\\C:\\", "..", "C:\\" },
+    {"\\\\?\\C:", "a", "C:\\a"},
 
     /* NT UNC path */
+    {"\\\\?\\UNC\\", "a", "\\\\a"},
     {"\\\\?\\UNC\\192.168.1.1\\test", "a",  "\\\\192.168.1.1\\test\\a" },
     {"\\\\?\\UNC\\192.168.1.1\\test", "..", "\\\\192.168.1.1" },
+
+    /* Second path begins with a single backslash */
+    {"C:a\\b", "\\1", "C:\\1"},
+    {"C:\\a\\b", "\\1", "C:\\1"},
+    {"\\a\\b", "\\1", "\\1"},
+    {"\\\\a\\b", "\\1", "\\\\a\\b\\1"},
+    {"\\\\a\\b\\c", "\\1", "\\\\a\\b\\1"},
+    {"\\\\?\\UNC\\a", "\\1", "\\\\a\\1"},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}a", "\\1",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\1"},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a", "\\1",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\1"},
+    {"C:\\a\\b", "\\", "C:\\"},
+
+    /* Second path is fully qualified */
+    {"X:\\", "C:", "C:\\"},
+    {"X:\\", "C:\\", "C:\\"},
+    {"X:\\", "\\\\", "\\\\"},
+    {"X:\\", "\\\\?\\C:", "C:\\"},
+    {"X:\\", "\\\\?\\C:\\", "C:\\"},
+    {"X:\\", "\\\\?\\UNC\\", "\\\\"},
+    {"X:\\", "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\"},
+
+    /* Canonicalization */
+    {"C:\\a", ".\\b", "C:\\a\\b"},
+    {"C:\\a", "..\\b", "C:\\b"},
+
+    /* Other */
+    {"", "", "\\"},
+    {"a", "b", "a\\b"}
 };
 
+static void test_PathAllocCombine(void)
+{
+    WCHAR path1W[PATHCCH_MAX_CCH];
+    WCHAR path2W[PATHCCH_MAX_CCH];
+    WCHAR *resultW;
+    CHAR resultA[PATHCCH_MAX_CCH];
+    HRESULT hr;
+    INT i;
+
+    if (!pPathAllocCombine)
+    {
+        win_skip("PathAllocCombine() is not available.\n");
+        return;
+    }
+
+    resultW = (WCHAR *)0xdeadbeef;
+    hr = pPathAllocCombine(NULL, NULL, 0, &resultW);
+    ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+    ok(resultW == NULL, "expect resultW null, got %p\n", resultW);
+
+    MultiByteToWideChar(CP_ACP, 0, "\\a", -1, path1W, ARRAY_SIZE(path1W));
+    hr = pPathAllocCombine(path1W, NULL, 0, &resultW);
+    ok(hr == S_OK, "expect hr %#x, got %#x\n", S_OK, hr);
+    WideCharToMultiByte(CP_ACP, 0, resultW, -1, resultA, ARRAY_SIZE(resultA), NULL, NULL);
+    ok(!lstrcmpA(resultA, "\\a"), "expect \\a, got %s\n", resultA);
+
+    MultiByteToWideChar(CP_ACP, 0, "\\b", -1, path2W, ARRAY_SIZE(path2W));
+    hr = pPathAllocCombine(NULL, path2W, 0, &resultW);
+    ok(hr == S_OK, "expect hr %#x, got %#x\n", S_OK, hr);
+    WideCharToMultiByte(CP_ACP, 0, resultW, -1, resultA, ARRAY_SIZE(resultA), NULL, NULL);
+    ok(!lstrcmpA(resultA, "\\b"), "expect \\b, got %s\n", resultA);
+
+    hr = pPathAllocCombine(path1W, path2W, 0, NULL);
+    ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+
+    for (i = 0; i < ARRAY_SIZE(combine_tests); i++)
+    {
+        const struct combine_test *t = combine_tests + i;
+
+        MultiByteToWideChar(CP_ACP, 0, t->path1, -1, path1W, ARRAY_SIZE(path1W));
+        MultiByteToWideChar(CP_ACP, 0, t->path2, -1, path2W, ARRAY_SIZE(path2W));
+        hr = pPathAllocCombine(path1W, path2W, 0, &resultW);
+        ok(hr == S_OK, "combine \"%s\" \"%s\" expect hr %#x, got %#x\n", t->path1, t->path2, S_OK, hr);
+        if (SUCCEEDED(hr))
+        {
+            WideCharToMultiByte(CP_ACP, 0, resultW, -1, resultA, ARRAY_SIZE(resultA), NULL, NULL);
+            ok(!lstrcmpA(resultA, t->result), "combine \"%s\" \"%s\" expect result \"%s\", got \"%s\"\n", t->path1,
+               t->path2, t->result, resultA);
+            LocalFree(resultW);
+        }
+    }
+}
+
+static void test_PathCchCombine(void)
+{
+    WCHAR expected[PATHCCH_MAX_CCH] = {'C', ':', '\\', 'a', 0};
+    WCHAR p1[PATHCCH_MAX_CCH] = {'C', ':', '\\', 0};
+    WCHAR p2[PATHCCH_MAX_CCH] = {'a', 0};
+    WCHAR output[PATHCCH_MAX_CCH];
+    HRESULT hr;
+    INT i;
+
+    if (!pPathCchCombine)
+    {
+        win_skip("PathCchCombine() is not available.\n");
+        return;
+    }
+
+    hr = pPathCchCombine(output, 5, NULL, NULL);
+    ok(hr == E_INVALIDARG, "Expected E_INVALIDARG, got %08x\n", hr);
+
+    hr = pPathCchCombine(NULL, 2, p1, p2);
+    ok(hr == E_INVALIDARG, "Expected E_INVALIDARG, got %08x\n", hr);
+
+    memset(output, 0xff, sizeof(output));
+    hr = pPathCchCombine(output, 0, p1, p2);
+    ok(hr == E_INVALIDARG, "Expected E_INVALIDARG, got %08x\n", hr);
+    ok(output[0] == 0xffff, "Expected output buffer to be unchanged\n");
+
+    memset(output, 0xff, sizeof(output));
+    hr = pPathCchCombine(output, 1, p1, p2);
+    ok(hr == STRSAFE_E_INSUFFICIENT_BUFFER, "Expected STRSAFE_E_INSUFFICIENT_BUFFER, got %08x\n", hr);
+    ok(output[0] == 0, "Expected output buffer to contain NULL string\n");
+
+    memset(output, 0xff, sizeof(output));
+    hr = pPathCchCombine(output, 4, p1, p2);
+    ok(hr == STRSAFE_E_INSUFFICIENT_BUFFER, "Expected STRSAFE_E_INSUFFICIENT_BUFFER, got %08x\n", hr);
+    ok(output[0] == 0x0, "Expected output buffer to contain NULL string\n");
+
+    memset(output, 0xff, sizeof(output));
+    hr = pPathCchCombine(output, 5, p1, p2);
+    ok(hr == S_OK, "Expected S_OK, got %08x\n", hr);
+    ok(!lstrcmpW(output, expected), "Combination of %s + %s returned %s, expected %s\n", wine_dbgstr_w(p1),
+       wine_dbgstr_w(p2), wine_dbgstr_w(output), wine_dbgstr_w(expected));
+
+    hr = pPathCchCombine(output, PATHCCH_MAX_CCH + 1, p1, p2);
+    ok(hr == E_INVALIDARG, "Expected E_INVALIDARG, got %08x\n", hr);
+
+    hr = pPathCchCombine(output, PATHCCH_MAX_CCH, p1, p2);
+    ok(hr == S_OK, "Expected S_OK, got %08x\n", hr);
+
+    for (i = 0; i < ARRAY_SIZE(combine_tests); i++)
+    {
+        MultiByteToWideChar(CP_ACP, 0, combine_tests[i].path1, -1, p1, ARRAY_SIZE(p1));
+        MultiByteToWideChar(CP_ACP, 0, combine_tests[i].path2, -1, p2, ARRAY_SIZE(p2));
+        MultiByteToWideChar(CP_ACP, 0, combine_tests[i].result, -1, expected, ARRAY_SIZE(expected));
+
+        hr = pPathCchCombine(output, ARRAY_SIZE(output), p1, p2);
+        ok(hr == S_OK, "Expected S_OK, got %08x\n", hr);
+        ok(!lstrcmpW(output, expected), "Combining %s with %s returned %s, expected %s\n", wine_dbgstr_w(p1),
+           wine_dbgstr_w(p2), wine_dbgstr_w(output), wine_dbgstr_w(expected));
+    }
+}
+
 static void test_PathCchCombineEx(void)
 {
-    WCHAR expected[MAX_PATH] = {'C',':','\\','a',0};
-    WCHAR p1[MAX_PATH] = {'C',':','\\',0};
-    WCHAR p2[MAX_PATH] = {'a',0};
-    WCHAR output[MAX_PATH];
+    WCHAR expected[PATHCCH_MAX_CCH] = {'C',':','\\','a',0};
+    WCHAR p1[PATHCCH_MAX_CCH] = {'C',':','\\',0};
+    WCHAR p2[PATHCCH_MAX_CCH] = {'a',0};
+    WCHAR output[PATHCCH_MAX_CCH];
     HRESULT hr;
-    int i;
+    INT i;
 
     if (!pPathCchCombineEx)
     {
-        skip("PathCchCombineEx() is not available.\n");
+        win_skip("PathCchCombineEx() is not available.\n");
         return;
     }
 
+    output[0] = 0xff;
+    hr = pPathCchCombineEx(output, 5, NULL, NULL, 0);
+    ok(hr == E_INVALIDARG, "Expected E_INVALIDARG, got %08x\n", hr);
+    ok(output[0] == 0, "Expected output buffer to be empty\n");
+
+    output[0] = 0xff;
     hr = pPathCchCombineEx(NULL, 2, p1, p2, 0);
     ok(hr == E_INVALIDARG, "Expected E_INVALIDARG, got %08x\n", hr);
+    ok(output[0] == 0xff, "Expected output buffer to be unchanged\n");
 
     memset(output, 0xff, sizeof(output));
     hr = pPathCchCombineEx(output, 0, p1, p2, 0);
@@ -100,6 +578,14 @@ static void test_PathCchCombineEx(void)
     ok(hr == STRSAFE_E_INSUFFICIENT_BUFFER, "Expected STRSAFE_E_INSUFFICIENT_BUFFER, got %08x\n", hr);
     ok(output[0] == 0x0, "Expected output buffer to contain NULL string\n");
 
+    output[0] = 0xff;
+    hr = pPathCchCombineEx(output, PATHCCH_MAX_CCH + 1, p1, p2, 0);
+    ok(hr == E_INVALIDARG, "Expected E_INVALIDARG, got %08x\n", hr);
+    ok(output[0] == 0xff, "Expected output buffer to be 0xff\n");
+
+    hr = pPathCchCombineEx(output, PATHCCH_MAX_CCH, p1, p2, 0);
+    ok(hr == S_OK, "Expected S_OK, got %08x\n", hr);
+
     memset(output, 0xff, sizeof(output));
     hr = pPathCchCombineEx(output, 5, p1, p2, 0);
     ok(hr == S_OK, "Expected S_OK, got %08x\n", hr);
@@ -107,11 +593,11 @@ static void test_PathCchCombineEx(void)
         "Combination of %s + %s returned %s, expected %s\n",
         wine_dbgstr_w(p1), wine_dbgstr_w(p2), wine_dbgstr_w(output), wine_dbgstr_w(expected));
 
-    for (i = 0; i < ARRAY_SIZE(combine_test); i++)
+    for (i = 0; i < ARRAY_SIZE(combine_tests); i++)
     {
-        MultiByteToWideChar(CP_ACP, 0, combine_test[i].path1, -1, p1, MAX_PATH);
-        MultiByteToWideChar(CP_ACP, 0, combine_test[i].path2, -1, p2, MAX_PATH);
-        MultiByteToWideChar(CP_ACP, 0, combine_test[i].result, -1, expected, MAX_PATH);
+        MultiByteToWideChar(CP_ACP, 0, combine_tests[i].path1, -1, p1, MAX_PATH);
+        MultiByteToWideChar(CP_ACP, 0, combine_tests[i].path2, -1, p2, MAX_PATH);
+        MultiByteToWideChar(CP_ACP, 0, combine_tests[i].result, -1, expected, MAX_PATH);
 
         hr = pPathCchCombineEx(output, MAX_PATH, p1, p2, 0);
         ok(hr == S_OK, "Expected S_OK, got %08x\n", hr);
@@ -302,6 +788,126 @@ static const struct addextension_test addextension_tests[] =
     {"C:\\1.exe", " ", NULL, E_INVALIDARG}
 };
 
+struct append_test
+{
+    const CHAR *path1;
+    const CHAR *path2;
+    const CHAR *result;
+};
+
+static const struct append_test append_tests[] =
+{
+    /* normal paths */
+    {"C:\\", "a", "C:\\a"},
+    {"C:\\b", "..\\a", "C:\\a"},
+    {"C:", "a", "C:\\a"},
+    {"C:\\", ".", "C:\\"},
+    {"C:\\", "..", "C:\\"},
+    {"C:\\a", "", "C:\\a"},
+
+    /* normal UNC paths */
+    {"\\\\192.168.1.1\\test", "a", "\\\\192.168.1.1\\test\\a"},
+    {"\\\\192.168.1.1\\test", "..", "\\\\192.168.1.1"},
+    {"\\a", "b", "\\a\\b"},
+    {"\\", "a", "\\a"},
+    {"\\\\", "a", "\\\\a"},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\", "a",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a"},
+
+    /* NT paths */
+    {"\\\\?\\C:\\", "a", "C:\\a"},
+    {"\\\\?\\C:\\", "..", "C:\\"},
+    {"\\\\?\\C:", "a", "C:\\a"},
+
+    /* NT UNC path */
+    {"\\\\?\\UNC\\", "a", "\\\\a"},
+    {"\\\\?\\UNC\\192.168.1.1\\test", "a", "\\\\192.168.1.1\\test\\a"},
+    {"\\\\?\\UNC\\192.168.1.1\\test", "..", "\\\\192.168.1.1"},
+
+    /* Second path begins with a single backslash */
+    {"C:a\\b", "\\1", "C:a\\b\\1"},
+    {"C:\\a\\b", "\\1", "C:\\a\\b\\1"},
+    {"\\a\\b", "\\1", "\\a\\b\\1"},
+    {"\\\\a\\b", "\\1", "\\\\a\\b\\1"},
+    {"\\\\a\\b\\c", "\\1", "\\\\a\\b\\c\\1"},
+    {"\\\\?\\UNC\\a", "\\1", "\\\\a\\1"},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}a", "\\1",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}a\\1"},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a", "\\1",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a\\1"},
+    {"C:\\a\\b", "\\", "C:\\a\\b"},
+
+    /* Second path is fully qualified */
+    {"X:\\", "C:", "C:\\"},
+    {"X:\\", "C:\\", "C:\\"},
+    {"X:\\", "\\\\", "\\\\"},
+    {"X:\\", "\\\\?\\C:", "C:\\"},
+    {"X:\\", "\\\\?\\C:\\", "C:\\"},
+    {"X:\\", "\\\\?\\UNC\\", "\\\\"},
+    {"X:\\", "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\"},
+
+    /* Canonicalization */
+    {"C:\\a", ".\\b", "C:\\a\\b"},
+    {"C:\\a", "..\\b", "C:\\b"},
+
+    /* Other */
+    {"", "", "\\"},
+    {"a", "b", "a\\b"}
+};
+
+static void test_PathCchAppendEx(void)
+{
+    WCHAR path1W[PATHCCH_MAX_CCH];
+    WCHAR path2W[PATHCCH_MAX_CCH];
+    CHAR path1A[PATHCCH_MAX_CCH];
+    HRESULT hr;
+    INT i;
+
+    if (!pPathCchAppendEx)
+    {
+        win_skip("PathCchAppendEx() is not available.\n");
+        return;
+    }
+
+    MultiByteToWideChar(CP_ACP, 0, "\\a", -1, path1W, ARRAY_SIZE(path1W));
+    MultiByteToWideChar(CP_ACP, 0, "\\b", -1, path2W, ARRAY_SIZE(path2W));
+    hr = pPathCchAppendEx(NULL, ARRAY_SIZE(path1W), path2W, 0);
+    ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+
+    hr = pPathCchAppendEx(path1W, 0, path2W, 0);
+    ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+    ok(path1W[0] == '\\', "expect path1 unchanged\n");
+
+    hr = pPathCchAppendEx(path1W, PATHCCH_MAX_CCH + 1, path2W, 0);
+    ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+    ok(path1W[0] == '\\', "expect path1 unchanged\n");
+
+    hr = pPathCchAppendEx(path1W,  ARRAY_SIZE(path1W), NULL, 0);
+    ok(hr == S_OK, "expect hr %#x, got %#x\n", S_OK, hr);
+    WideCharToMultiByte(CP_ACP, 0, path1W, -1, path1A, ARRAY_SIZE(path1A), NULL, NULL);
+    ok(!lstrcmpA(path1A, "\\a"), "expect \\a, got %s\n", path1A);
+
+    hr = pPathCchAppendEx(path1W, PATHCCH_MAX_CCH, path2W, 0);
+    ok(hr == S_OK, "expect hr %#x, got %#x\n", S_OK, hr);
+
+    for (i = 0; i < ARRAY_SIZE(append_tests); i++)
+    {
+        const struct append_test *t = append_tests + i;
+
+        MultiByteToWideChar(CP_ACP, 0, t->path1, -1, path1W, ARRAY_SIZE(path1W));
+        MultiByteToWideChar(CP_ACP, 0, t->path2, -1, path2W, ARRAY_SIZE(path2W));
+        hr = pPathCchAppendEx(path1W, PATHCCH_MAX_CCH, path2W, 0);
+        ok(hr == S_OK, "append \"%s\" \"%s\" expect hr %#x, got %#x\n", t->path1, t->path2, S_OK, hr);
+        if (SUCCEEDED(hr))
+        {
+            WideCharToMultiByte(CP_ACP, 0, path1W, -1, path1A, ARRAY_SIZE(path1A), NULL, NULL);
+            ok(!lstrcmpA(path1A, t->result), "append \"%s\" \"%s\" expect result \"%s\", got \"%s\"\n", t->path1,
+               t->path2, t->result, path1A);
+        }
+    }
+}
+
 static void test_PathCchAddExtension(void)
 {
     WCHAR pathW[PATHCCH_MAX_CCH + 1];
@@ -355,6 +961,248 @@ static void test_PathCchAddExtension(void)
     }
 }
 
+static void test_PathCchCanonicalize(void)
+{
+    WCHAR path_inW[MAX_PATH], path_outW[MAX_PATH];
+    CHAR path_outA[MAX_PATH];
+    HRESULT hr;
+    INT i;
+
+    if (!pPathCchCanonicalize)
+    {
+        win_skip("PathCchCanonicalize() is not available.\n");
+        return;
+    }
+
+    /* No NULL check for path pointers on Windows */
+    if (0)
+    {
+        hr = pPathCchCanonicalize(NULL, ARRAY_SIZE(path_outW), path_inW);
+        ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+
+        /* MSDN says NULL path_in result in a backslash added to path_out, but the fact is that it would crash */
+        hr = pPathCchCanonicalize(path_outW, ARRAY_SIZE(path_outW), NULL);
+        ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+    }
+
+    hr = pPathCchCanonicalize(path_outW, 0, path_inW);
+    ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+
+    /* Test path length */
+    for (i = 0; i < MAX_PATH - 3; i++) path_inW[i] = 'a';
+    path_inW[MAX_PATH - 3] = '\0';
+    memset(path_outW, 0, sizeof(path_outW));
+    hr = pPathCchCanonicalize(path_outW, ARRAY_SIZE(path_outW), path_inW);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE), "expect hr %#x, got %#x %s\n",
+       HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE), hr, wine_dbgstr_w(path_outW));
+    ok(lstrlenW(path_outW) == 0, "got %d\n", lstrlenW(path_outW));
+
+    path_inW[0] = 'C';
+    path_inW[1] = ':';
+    path_inW[2] = '\\';
+    hr = pPathCchCanonicalize(path_outW, ARRAY_SIZE(path_outW), path_inW);
+    ok(hr == S_OK, "expect hr %#x, got %#x\n", S_OK, hr);
+
+    path_inW[MAX_PATH - 4] = '\0';
+    hr = pPathCchCanonicalize(path_outW, ARRAY_SIZE(path_outW), path_inW);
+    ok(hr == S_OK, "expect hr %#x, got %#x\n", S_OK, hr);
+
+    /* Insufficient buffer size handling */
+    hr = pPathCchCanonicalize(path_outW, 1, path_inW);
+    ok(hr == STRSAFE_E_INSUFFICIENT_BUFFER, "expect hr %#x, got %#x\n", STRSAFE_E_INSUFFICIENT_BUFFER, hr);
+
+    for (i = 0; i < ARRAY_SIZE(alloccanonicalize_tests); i++)
+    {
+        const struct alloccanonicalize_test *t = alloccanonicalize_tests + i;
+
+        /* Skip testing X: path input, this case is different compared to PathAllocCanonicalize */
+        /* Skip test cases where a flag is used */
+        if (!lstrcmpA("C:", t->path_in) || t->flags) continue;
+
+        MultiByteToWideChar(CP_ACP, 0, t->path_in, -1, path_inW, ARRAY_SIZE(path_inW));
+        hr = pPathCchCanonicalize(path_outW, ARRAY_SIZE(path_outW), path_inW);
+        ok(hr == t->hr, "path %s expect result %#x, got %#x\n", t->path_in, t->hr, hr);
+        if (SUCCEEDED(hr))
+        {
+            WideCharToMultiByte(CP_ACP, 0, path_outW, -1, path_outA, ARRAY_SIZE(path_outA), NULL, NULL);
+            ok(!lstrcmpA(path_outA, t->path_out), "path \"%s\" expect output path \"%s\", got \"%s\"\n", t->path_in,
+               t->path_out, path_outA);
+        }
+    }
+
+    /* X: path input */
+    /* Fill a \ at the end of X: if there is enough space */
+    MultiByteToWideChar(CP_ACP, 0, "C:", -1, path_inW, ARRAY_SIZE(path_inW));
+    hr = pPathCchCanonicalize(path_outW, ARRAY_SIZE(path_outW), path_inW);
+    ok(hr == S_OK, "path %s expect result %#x, got %#x\n", "C:", S_OK, hr);
+    if (SUCCEEDED(hr))
+    {
+        WideCharToMultiByte(CP_ACP, 0, path_outW, -1, path_outA, ARRAY_SIZE(path_outA), NULL, NULL);
+        ok(!lstrcmpA(path_outA, "C:\\"), "path \"%s\" expect output path \"%s\", got \"%s\"\n", "C:", "C:\\",
+           path_outA);
+    }
+
+    /* Don't fill a \ at the end of X: if there isn't enough space */
+    MultiByteToWideChar(CP_ACP, 0, "C:", -1, path_inW, ARRAY_SIZE(path_inW));
+    hr = pPathCchCanonicalize(path_outW, 3, path_inW);
+    ok(hr == S_OK, "path %s expect result %#x, got %#x\n", "C:", S_OK, hr);
+    if (SUCCEEDED(hr))
+    {
+        WideCharToMultiByte(CP_ACP, 0, path_outW, -1, path_outA, ARRAY_SIZE(path_outA), NULL, NULL);
+        ok(!lstrcmpA(path_outA, "C:"), "path \"%s\" expect output path \"%s\", got \"%s\"\n", "C:", "C:\\", path_outA);
+    }
+
+    /* Don't fill a \ at the end of X: if there is character following X: */
+    MultiByteToWideChar(CP_ACP, 0, "C:a", -1, path_inW, ARRAY_SIZE(path_inW));
+    hr = pPathCchCanonicalize(path_outW, ARRAY_SIZE(path_outW), path_inW);
+    ok(hr == S_OK, "path %s expect result %#x, got %#x\n", "C:a", S_OK, hr);
+    if (SUCCEEDED(hr))
+    {
+        WideCharToMultiByte(CP_ACP, 0, path_outW, -1, path_outA, ARRAY_SIZE(path_outA), NULL, NULL);
+        ok(!lstrcmpA(path_outA, "C:a"), "path \"%s\" expect output path \"%s\", got \"%s\"\n", "C:a", "C:a", path_outA);
+    }
+}
+
+static void test_PathCchCanonicalizeEx(void)
+{
+    WCHAR path_inW[PATHCCH_MAX_CCH + 1], path_outW[PATHCCH_MAX_CCH];
+    CHAR path_outA[4096];
+    BOOL skip_new_flags = TRUE;
+    HRESULT hr;
+    INT i;
+
+    if (!pPathCchCanonicalizeEx)
+    {
+        win_skip("PathCchCanonicalizeEx() is not available.\n");
+        return;
+    }
+
+    /* No NULL check for path pointers on Windows */
+    if (0)
+    {
+        hr = pPathCchCanonicalizeEx(NULL, ARRAY_SIZE(path_outW), path_inW, 0);
+        ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+
+        /* MSDN says NULL path_in result in a backslash added to path_out, but the fact is that it would crash */
+        hr = pPathCchCanonicalizeEx(path_outW, ARRAY_SIZE(path_outW), NULL, 0);
+        ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+    }
+
+    path_outW[0] = 0xff;
+    hr = pPathCchCanonicalizeEx(path_outW, 0, path_inW, 0);
+    ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+    ok(path_outW[0] = 0xff, "expect path_outW unchanged\n");
+
+    /* Test path length */
+    for (i = 0; i < ARRAY_SIZE(path_inW) - 1; i++) path_inW[i] = 'a';
+    path_inW[PATHCCH_MAX_CCH] = '\0';
+    hr = pPathCchCanonicalizeEx(path_outW, ARRAY_SIZE(path_outW), path_inW, PATHCCH_ALLOW_LONG_PATHS);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE), "expect hr %#x, got %#x\n",
+       HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE), hr);
+
+    path_inW[PATHCCH_MAX_CCH - 1] = '\0';
+    hr = pPathCchCanonicalizeEx(path_outW, ARRAY_SIZE(path_outW), path_inW, PATHCCH_ALLOW_LONG_PATHS);
+    ok(hr == S_OK, "expect hr %#x, got %#x\n", S_OK, hr);
+
+    hr = pPathCchCanonicalizeEx(path_outW, 1, path_inW, PATHCCH_ALLOW_LONG_PATHS);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE), "expect hr %#x, got %#x\n",
+       HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE), hr);
+
+    /* No root and path > MAX_PATH - 4, return HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE) */
+    path_inW[MAX_PATH - 3] = '\0';
+    hr = pPathCchCanonicalizeEx(path_outW, 1, path_inW, 0);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE), "expect hr %#x, got %#x\n",
+       HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE), hr);
+
+    /* Has root and path > MAX_PATH - 4 */
+    path_inW[0] = 'C';
+    path_inW[1] = ':';
+    path_inW[2] = '\\';
+    hr = pPathCchCanonicalizeEx(path_outW, 1, path_inW, 0);
+    ok(hr == STRSAFE_E_INSUFFICIENT_BUFFER, "expect hr %#x, got %#x\n", STRSAFE_E_INSUFFICIENT_BUFFER, hr);
+
+    path_inW[0] = '\\';
+    path_inW[1] = path_inW[2] = 'a';
+    hr = pPathCchCanonicalizeEx(path_outW, 1, path_inW, 0);
+    ok(hr == STRSAFE_E_INSUFFICIENT_BUFFER, "expect hr %#x, got %#x\n", STRSAFE_E_INSUFFICIENT_BUFFER, hr);
+
+    path_inW[0] = path_inW[1] = '\\';
+    path_inW[2] = 'a';
+    hr = pPathCchCanonicalizeEx(path_outW, 1, path_inW, 0);
+    ok(hr == STRSAFE_E_INSUFFICIENT_BUFFER, "expect hr %#x, got %#x\n", STRSAFE_E_INSUFFICIENT_BUFFER, hr);
+
+    /* path <= MAX_PATH - 4 */
+    path_inW[0] = path_inW[1] = path_inW[2] = 'a';
+    path_inW[MAX_PATH - 4] = '\0';
+    hr = pPathCchCanonicalizeEx(path_outW, 1, path_inW, 0);
+    ok(hr == STRSAFE_E_INSUFFICIENT_BUFFER, "expect hr %#x, got %#x\n", STRSAFE_E_INSUFFICIENT_BUFFER, hr);
+
+    /* Check if flags added after Windows 10 1709 are supported */
+    MultiByteToWideChar(CP_ACP, 0, "C:\\", -1, path_inW, ARRAY_SIZE(path_inW));
+    hr = pPathCchCanonicalizeEx(path_outW, ARRAY_SIZE(path_outW), path_inW, PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS);
+    if (hr == E_INVALIDARG) skip_new_flags = FALSE;
+
+    for (i = 0; i < ARRAY_SIZE(alloccanonicalize_tests); i++)
+    {
+        const struct alloccanonicalize_test *t = alloccanonicalize_tests + i;
+
+        /* Skip testing X: path input, this case is different compared to PathAllocCanonicalize */
+        if (!lstrcmpA("C:", t->path_in)) continue;
+
+        if (((PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS | PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS
+              | PATHCCH_DO_NOT_NORMALIZE_SEGMENTS | PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH
+              | PATHCCH_ENSURE_TRAILING_SLASH)
+             & t->flags)
+            && skip_new_flags)
+        {
+            win_skip("Skip testing new flags added after Windows 10 1709\n");
+            return;
+        }
+
+        MultiByteToWideChar(CP_ACP, 0, t->path_in, -1, path_inW, ARRAY_SIZE(path_inW));
+        hr = pPathCchCanonicalizeEx(path_outW, ARRAY_SIZE(path_outW), path_inW, t->flags);
+        ok(hr == t->hr, "path %s expect result %#x, got %#x\n", t->path_in, t->hr, hr);
+        if (SUCCEEDED(hr))
+        {
+            WideCharToMultiByte(CP_ACP, 0, path_outW, -1, path_outA, ARRAY_SIZE(path_outA), NULL, NULL);
+            ok(!lstrcmpA(path_outA, t->path_out), "path \"%s\" expect output path \"%s\", got \"%s\"\n", t->path_in,
+               t->path_out, path_outA);
+        }
+    }
+
+    /* X: path input */
+    /* Fill a \ at the end of X: if there is enough space */
+    MultiByteToWideChar(CP_ACP, 0, "C:", -1, path_inW, ARRAY_SIZE(path_inW));
+    hr = pPathCchCanonicalizeEx(path_outW, ARRAY_SIZE(path_outW), path_inW, 0);
+    ok(hr == S_OK, "path %s expect result %#x, got %#x\n", "C:", S_OK, hr);
+    if (SUCCEEDED(hr))
+    {
+        WideCharToMultiByte(CP_ACP, 0, path_outW, -1, path_outA, ARRAY_SIZE(path_outA), NULL, NULL);
+        ok(!lstrcmpA(path_outA, "C:\\"), "path \"%s\" expect output path \"%s\", got \"%s\"\n", "C:", "C:\\",
+           path_outA);
+    }
+
+    /* Don't fill a \ at the end of X: if there isn't enough space */
+    MultiByteToWideChar(CP_ACP, 0, "C:", -1, path_inW, ARRAY_SIZE(path_inW));
+    hr = pPathCchCanonicalizeEx(path_outW, 3, path_inW, 0);
+    ok(hr == S_OK, "path %s expect result %#x, got %#x\n", "C:", S_OK, hr);
+    if (SUCCEEDED(hr))
+    {
+        WideCharToMultiByte(CP_ACP, 0, path_outW, -1, path_outA, ARRAY_SIZE(path_outA), NULL, NULL);
+        ok(!lstrcmpA(path_outA, "C:"), "path \"%s\" expect output path \"%s\", got \"%s\"\n", "C:", "C:\\", path_outA);
+    }
+
+    /* Don't fill a \ at the end of X: if there is character following X: */
+    MultiByteToWideChar(CP_ACP, 0, "C:a", -1, path_inW, ARRAY_SIZE(path_inW));
+    hr = pPathCchCanonicalizeEx(path_outW, ARRAY_SIZE(path_outW), path_inW, 0);
+    ok(hr == S_OK, "path %s expect result %#x, got %#x\n", "C:a", S_OK, hr);
+    if (SUCCEEDED(hr))
+    {
+        WideCharToMultiByte(CP_ACP, 0, path_outW, -1, path_outA, ARRAY_SIZE(path_outA), NULL, NULL);
+        ok(!lstrcmpA(path_outA, "C:a"), "path \"%s\" expect output path \"%s\", got \"%s\"\n", "C:a", "C:a", path_outA);
+    }
+}
+
 struct findextension_test
 {
     const CHAR *path;
@@ -473,6 +1321,231 @@ static void test_PathCchFindExtension(void)
     }
 }
 
+struct isroot_test
+{
+    const CHAR *path;
+    BOOL ret;
+};
+
+static const struct isroot_test isroot_tests[] =
+{
+    {"", FALSE},
+    {"a", FALSE},
+    {"C:", FALSE},
+    {"C:\\", TRUE},
+    {"C:\\a", FALSE},
+    {"\\\\?\\C:\\", TRUE},
+    {"\\\\?\\C:", FALSE},
+    {"\\\\?\\C:\\a", FALSE},
+    {"\\", TRUE},
+    {"\\a\\", FALSE},
+    {"\\a\\b", FALSE},
+    {"\\\\", TRUE},
+    {"\\\\a", TRUE},
+    {"\\\\a\\", FALSE},
+    {"\\\\a\\b", TRUE},
+    {"\\\\a\\b\\", FALSE},
+    {"\\\\a\\b\\c", FALSE},
+    {"\\\\?\\UNC\\", TRUE},
+    {"\\\\?\\UNC\\a", TRUE},
+    {"\\\\?\\UNC\\a\\", FALSE},
+    {"\\\\?\\UNC\\a\\b", TRUE},
+    {"\\\\?\\UNC\\a\\b\\", FALSE},
+    {"\\\\?\\UNC\\a\\b\\c", FALSE},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}", FALSE},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\", TRUE},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a", FALSE},
+    {"..\\a", FALSE},
+
+    /* Wrong MSDN examples */
+    {"\\a", FALSE},
+    {"X:", FALSE},
+    {"\\server", FALSE}
+};
+
+static void test_PathCchIsRoot(void)
+{
+    WCHAR pathW[MAX_PATH];
+    BOOL ret;
+    INT i;
+
+    if (!pPathCchIsRoot)
+    {
+        win_skip("PathCchIsRoot() is not available.\n");
+        return;
+    }
+
+    ret = pPathCchIsRoot(NULL);
+    ok(ret == FALSE, "expect return FALSE\n");
+
+    for (i = 0; i < ARRAY_SIZE(isroot_tests); i++)
+    {
+        const struct isroot_test *t = isroot_tests + i;
+        MultiByteToWideChar(CP_ACP, 0, t->path, -1, pathW, ARRAY_SIZE(pathW));
+        ret = pPathCchIsRoot(pathW);
+        ok(ret == t->ret, "path %s expect return %d, got %d\n", t->path, t->ret, ret);
+    }
+}
+
+struct removebackslashex_test
+{
+    const CHAR *path_in;
+    const CHAR *path_out;
+    int end_offset;
+    SIZE_T free_size;
+    HRESULT hr;
+};
+
+static const struct removebackslashex_test removebackslashex_tests [] =
+{
+    {"", "", 0, 1, S_FALSE},
+    {"C", "C", 1, 1, S_FALSE},
+    {"C\\", "C", 1, 2, S_OK},
+    {"C:", "C:", 2, 1, S_FALSE},
+    {"C:\\", "C:\\", 2, 2, S_FALSE},
+    {"C:\\\\", "C:\\", 3, 2, S_OK},
+    {"C:\\a\\", "C:\\a", 4, 2, S_OK},
+    {"C:\\a\\\\", "C:\\a\\", 5, 2, S_OK},
+    {"\\", "\\", 0, 2, S_FALSE},
+    {"\\\\", "\\\\", 1, 2, S_FALSE},
+    {"\\?\\", "\\?", 2, 2, S_OK},
+    {"\\?\\\\", "\\?\\", 3, 2, S_OK},
+    {"\\a\\", "\\a", 2, 2, S_OK},
+    {"\\a\\\\", "\\a\\", 3, 2, S_OK},
+    {"\\\\a\\", "\\\\a", 3, 2, S_OK},
+    {"\\\\a\\b\\", "\\\\a\\b", 5, 2, S_OK},
+    {"\\\\a\\\\", "\\\\a\\", 4, 2, S_OK},
+    {"\\\\?\\", "\\\\?", 3, 2, S_OK},
+    {"\\\\?\\\\", "\\\\?\\", 4, 2, S_OK},
+    {"\\\\?\\C:", "\\\\?\\C:", 6, 1, S_FALSE},
+    {"\\\\?\\C:\\", "\\\\?\\C:\\", 6, 2, S_FALSE},
+    {"\\?\\UNC\\", "\\?\\UNC", 6, 2, S_OK},
+    {"\\\\?\\UNC", "\\\\?\\UNC", 7, 1, S_FALSE},
+    {"\\\\?\\UNC\\", "\\\\?\\UNC\\", 7, 2, S_FALSE},
+    {"\\\\?\\UNC\\a", "\\\\?\\UNC\\a", 9, 1, S_FALSE},
+    {"\\\\?\\UNC\\a\\", "\\\\?\\UNC\\a", 9, 2, S_OK},
+    {"\\\\?\\UNC\\a\\b\\", "\\\\?\\UNC\\a\\b", 11, 2, S_OK},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}", 48, 1, S_FALSE},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\", 48, 2, S_FALSE},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a", 50, 1, S_FALSE},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a\\",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a", 50, 2, S_OK}
+};
+
+static void test_PathCchRemoveBackslash(void)
+{
+    WCHAR pathW[PATHCCH_MAX_CCH];
+    CHAR pathA[PATHCCH_MAX_CCH];
+    HRESULT hr;
+    SIZE_T path_size;
+    INT i;
+
+    if (!pPathCchRemoveBackslash)
+    {
+        win_skip("PathCchRemoveBackslash() is not available.\n");
+        return;
+    }
+
+    /* No NULL check for path on Windows */
+    if (0)
+    {
+        hr = pPathCchRemoveBackslash(NULL, PATHCCH_MAX_CCH);
+        ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+    }
+
+    MultiByteToWideChar(CP_ACP, 0, "C:\\a\\", -1, pathW, ARRAY_SIZE(pathW));
+    hr = pPathCchRemoveBackslash(pathW, 0);
+    ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+
+    hr = pPathCchRemoveBackslash(pathW, PATHCCH_MAX_CCH + 1);
+    ok(hr == S_OK, "expect hr %#x, got %#x\n", S_OK, hr);
+
+    hr = pPathCchRemoveBackslash(pathW, PATHCCH_MAX_CCH);
+    ok(hr == S_FALSE, "expect hr %#x, got %#x\n", S_FALSE, hr);
+
+    for (i = 0; i < ARRAY_SIZE(removebackslashex_tests); i++)
+    {
+        const struct removebackslashex_test *t = removebackslashex_tests + i;
+        path_size = MultiByteToWideChar(CP_ACP, 0, t->path_in, -1, pathW, ARRAY_SIZE(pathW));
+        hr = pPathCchRemoveBackslash(pathW, path_size);
+        ok(hr == t->hr, "path %s expect result %#x, got %#x\n", t->path_in, t->hr, hr);
+        if (SUCCEEDED(hr))
+        {
+            WideCharToMultiByte(CP_ACP, 0, pathW, -1, pathA, ARRAY_SIZE(pathA), NULL, NULL);
+            ok(!lstrcmpA(pathA, t->path_out), "path %s expect output path %s, got %s\n", t->path_in, t->path_out,
+               pathA);
+        }
+    }
+}
+
+static void test_PathCchRemoveBackslashEx(void)
+{
+    WCHAR pathW[PATHCCH_MAX_CCH];
+    CHAR pathA[PATHCCH_MAX_CCH];
+    WCHAR *path_end;
+    SIZE_T path_size, free_size;
+    HRESULT hr;
+    INT i;
+
+    if (!pPathCchRemoveBackslashEx)
+    {
+        win_skip("PathCchRemoveBackslashEx() is not available.\n");
+        return;
+    }
+
+    /* No NULL check for path on Windows */
+    if (0)
+    {
+        hr = pPathCchRemoveBackslashEx(NULL, 0, &path_end, &path_size);
+        ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+    }
+
+    path_size = MultiByteToWideChar(CP_ACP, 0, "C:\\a\\", -1, pathW, ARRAY_SIZE(pathW));
+    hr = pPathCchRemoveBackslashEx(pathW, 0, &path_end, &path_size);
+    ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+
+    free_size = 0xdeadbeef;
+    hr = pPathCchRemoveBackslashEx(pathW, path_size, NULL, &free_size);
+    ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+    ok(free_size == 0, "expect %d, got %lu\n", 0, free_size);
+
+    path_end = (WCHAR *)0xdeadbeef;
+    hr = pPathCchRemoveBackslashEx(pathW, path_size, &path_end, NULL);
+    ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+    ok(path_end == NULL, "expect null, got %p\n", path_end);
+
+    hr = pPathCchRemoveBackslashEx(pathW, PATHCCH_MAX_CCH + 1, &path_end, &free_size);
+    ok(hr == S_OK, "expect hr %#x, got %#x\n", S_OK, hr);
+
+    hr = pPathCchRemoveBackslashEx(pathW, PATHCCH_MAX_CCH, &path_end, &free_size);
+    ok(hr == S_FALSE, "expect hr %#x, got %#x\n", S_FALSE, hr);
+
+    /* Size < original path length + 1, don't read beyond size */
+    MultiByteToWideChar(CP_ACP, 0, "C:\\a", -1, pathW, ARRAY_SIZE(pathW));
+    hr = pPathCchRemoveBackslashEx(pathW, ARRAY_SIZE("C:\\a") - 1, &path_end, &free_size);
+    ok(hr == E_INVALIDARG, "expect result %#x, got %#x\n", E_INVALIDARG, hr);
+
+    for (i = 0; i < ARRAY_SIZE(removebackslashex_tests); i++)
+    {
+        const struct removebackslashex_test *t = removebackslashex_tests + i;
+        path_size = MultiByteToWideChar(CP_ACP, 0, t->path_in, -1, pathW, ARRAY_SIZE(pathW));
+        hr = pPathCchRemoveBackslashEx(pathW, path_size, &path_end, &free_size);
+        ok(hr == t->hr, "path %s expect result %#x, got %#x\n", t->path_in, t->hr, hr);
+        if (SUCCEEDED(hr))
+        {
+            ok(path_end - pathW == t->end_offset, "path %s expect end offset %d, got %d\n", t->path_in, t->end_offset,
+               path_end - pathW);
+            ok(free_size == t->free_size, "path %s expect free size %lu, got %lu\n", t->path_in, t->free_size, free_size);
+            WideCharToMultiByte(CP_ACP, 0, pathW, -1, pathA, ARRAY_SIZE(pathA), NULL, NULL);
+            ok(!lstrcmpA(pathA, t->path_out), "path %s expect output path %s, got %s\n", t->path_in, t->path_out,
+               pathA);
+        }
+    }
+}
+
 struct removeextension_test
 {
     const CHAR *path;
@@ -555,6 +1628,129 @@ static void test_PathCchRemoveExtension(void)
     }
 }
 
+struct removefilespec_test
+{
+    const CHAR *path;
+    const CHAR *expected;
+    HRESULT hr;
+    SIZE_T size;
+};
+
+static const struct removefilespec_test removefilespec_tests[] =
+{
+    {"", "", S_FALSE},
+    {"a", "", S_OK},
+    {"a\\", "a", S_OK},
+    {"a\\b", "a", S_OK},
+
+    {"\\", "\\", S_FALSE},
+    {"\\a", "\\", S_OK},
+    {"\\a\\", "\\a", S_OK},
+    {"\\a\\b", "\\a", S_OK},
+
+    {"\\\\", "\\\\", S_FALSE},
+    {"\\\\a", "\\\\a", S_FALSE},
+    {"\\\\a\\", "\\\\a", S_OK},
+    {"\\\\a\\b", "\\\\a\\b", S_FALSE},
+    {"\\\\a\\b\\", "\\\\a\\b", S_OK},
+    {"\\\\a\\b\\c", "\\\\a\\b", S_OK},
+
+    {"C:", "C:", S_FALSE},
+    {"C:a", "C:", S_OK},
+    {"C:a\\", "C:a", S_OK},
+    {"C:a\\b", "C:a", S_OK},
+
+    {"C:\\", "C:\\", S_FALSE},
+    {"C:\\a", "C:\\", S_OK},
+    {"C:\\a\\", "C:\\a", S_OK},
+    {"C:\\a\\b", "C:\\a", S_OK},
+
+    {"\\\\?\\", "\\\\?", S_OK},
+    {"\\\\?\\a", "\\\\?", S_OK},
+    {"\\\\?\\a\\", "\\\\?\\a", S_OK},
+    {"\\\\?\\a\\b", "\\\\?\\a", S_OK},
+
+    {"\\\\?\\C:", "\\\\?\\C:", S_FALSE},
+    {"\\\\?\\C:a", "\\\\?\\C:", S_OK},
+    {"\\\\?\\C:a\\", "\\\\?\\C:a", S_OK},
+    {"\\\\?\\C:a\\b", "\\\\?\\C:a", S_OK},
+
+    {"\\\\?\\C:\\", "\\\\?\\C:\\", S_FALSE},
+    {"\\\\?\\C:\\a", "\\\\?\\C:\\", S_OK},
+    {"\\\\?\\C:\\a\\", "\\\\?\\C:\\a", S_OK},
+    {"\\\\?\\C:\\a\\b", "\\\\?\\C:\\a", S_OK},
+
+    {"\\\\?\\UNC\\", "\\\\?\\UNC\\", S_FALSE},
+    {"\\\\?\\UNC\\a", "\\\\?\\UNC\\a", S_FALSE},
+    {"\\\\?\\UNC\\a\\", "\\\\?\\UNC\\a", S_OK},
+    {"\\\\?\\UNC\\a\\b", "\\\\?\\UNC\\a\\b", S_FALSE},
+    {"\\\\?\\UNC\\a\\b\\", "\\\\?\\UNC\\a\\b", S_OK},
+    {"\\\\?\\UNC\\a\\b\\c", "\\\\?\\UNC\\a\\b", S_OK},
+
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}", S_FALSE},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}a",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}", S_OK},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}a\\",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}a", S_OK},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}a\\b",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}a", S_OK},
+
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\", S_FALSE},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\", S_OK},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a\\",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a", S_OK},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a\\b",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a", S_OK},
+
+    /* Size tests */
+    {"C:\\a", NULL, E_INVALIDARG, PATHCCH_MAX_CCH + 1},
+    {"C:\\a", "C:\\", S_OK, PATHCCH_MAX_CCH},
+    /* Size < original path length + 1, read beyond size */
+    {"C:\\a", "C:\\", S_OK, ARRAY_SIZE("C:\\a") - 1},
+    /* Size < result path length + 1 */
+    {"C:\\a", NULL, E_INVALIDARG, ARRAY_SIZE("C:\\") - 1}
+};
+
+static void test_PathCchRemoveFileSpec(void)
+{
+    WCHAR pathW[PATHCCH_MAX_CCH] = {0};
+    CHAR pathA[PATHCCH_MAX_CCH];
+    SIZE_T size;
+    HRESULT hr;
+    INT i;
+
+    if (!pPathCchRemoveFileSpec)
+    {
+        win_skip("PathCchRemoveFileSpec() is not available.\n");
+        return;
+    }
+
+    /* Null arguments */
+    hr = pPathCchRemoveFileSpec(NULL, ARRAY_SIZE(pathW));
+    ok(hr == E_INVALIDARG, "expect %#x, got %#x\n", E_INVALIDARG, hr);
+
+    hr = pPathCchRemoveFileSpec(pathW, 0);
+    ok(hr == E_INVALIDARG, "expect %#x, got %#x\n", E_INVALIDARG, hr);
+
+    for (i = 0; i < ARRAY_SIZE(removefilespec_tests); i++)
+    {
+        const struct removefilespec_test *t = removefilespec_tests + i;
+
+        MultiByteToWideChar(CP_ACP, 0, t->path, -1, pathW, ARRAY_SIZE(pathW));
+        size = t->size ? t->size : ARRAY_SIZE(pathW);
+        hr = pPathCchRemoveFileSpec(pathW, size);
+        ok(hr == t->hr, "path %s expect result %#x, got %#x\n", t->path, t->hr, hr);
+        if (SUCCEEDED(hr))
+        {
+            WideCharToMultiByte(CP_ACP, 0, pathW, -1, pathA, ARRAY_SIZE(pathA), NULL, NULL);
+            ok(!lstrcmpA(pathA, t->expected), "path %s expect stripped path %s, got %s\n", t->path, t->expected, pathA);
+        }
+    }
+}
+
 struct renameextension_test
 {
     const CHAR *path;
@@ -632,23 +1828,445 @@ static void test_PathCchRenameExtension(void)
     }
 }
 
+struct skiproot_test
+{
+    const char *path;
+    int root_offset;
+    HRESULT hr;
+};
+
+static const struct skiproot_test skiproot_tests [] =
+{
+    /* Basic combination */
+    {"", 0, E_INVALIDARG},
+    {"C:\\", 3, S_OK},
+    {"\\", 1, S_OK},
+    {"\\\\.\\", 4, S_OK},
+    {"\\\\?\\UNC\\", 8, S_OK},
+    {"\\\\?\\C:\\", 7, S_OK},
+
+    /* Basic + \ */
+    {"C:\\\\", 3, S_OK},
+    {"\\\\", 2, S_OK},
+    {"\\\\.\\\\", 4, S_OK},
+    {"\\\\?\\UNC\\\\", 9, S_OK},
+    {"\\\\?\\C:\\\\", 7, S_OK},
+
+    /* Basic + a */
+    {"a", 0, E_INVALIDARG},
+    {"C:\\a", 3, S_OK},
+    {"\\a", 1, S_OK},
+    {"\\\\.\\a", 5, S_OK},
+    {"\\\\?\\UNC\\a", 9, S_OK},
+
+    /* Basic + \a */
+    {"\\a", 1, S_OK},
+    {"C:\\\\a", 3, S_OK},
+    {"\\\\a", 3, S_OK},
+    {"\\\\.\\\\a", 4, S_OK},
+    {"\\\\?\\UNC\\\\a", 10, S_OK},
+    {"\\\\?\\C:\\\\a", 7, S_OK},
+
+    /* Basic + a\ */
+    {"a\\", 0, E_INVALIDARG},
+    {"C:\\a\\", 3, S_OK},
+    {"\\a\\", 1, S_OK},
+    {"\\\\.\\a\\", 6, S_OK},
+    {"\\\\?\\UNC\\a\\", 10, S_OK},
+    {"\\\\?\\C:\\a\\", 7, S_OK},
+
+    /* Network share */
+    {"\\\\\\\\", 3, S_OK},
+    {"\\\\a\\", 4, S_OK},
+    {"\\\\a\\b", 5, S_OK},
+    {"\\\\a\\b\\", 6, S_OK},
+    {"\\\\a\\b\\\\", 6, S_OK},
+    {"\\\\a\\b\\\\c", 6, S_OK},
+    {"\\\\a\\b\\c", 6, S_OK},
+    {"\\\\a\\b\\c\\", 6, S_OK},
+    {"\\\\a\\b\\c\\d", 6, S_OK},
+    {"\\\\a\\\\b\\c\\", 4, S_OK},
+    {"\\\\aa\\bb\\cc\\", 8, S_OK},
+
+    /* UNC */
+    {"\\\\?\\UNC\\\\", 9, S_OK},
+    {"\\\\?\\UNC\\a\\b", 11, S_OK},
+    {"\\\\?\\UNC\\a\\b", 11, S_OK},
+    {"\\\\?\\UNC\\a\\b\\", 12, S_OK},
+    {"\\\\?\\UNC\\a\\b\\c", 12, S_OK},
+    {"\\\\?\\UNC\\a\\b\\c\\", 12, S_OK},
+    {"\\\\?\\UNC\\a\\b\\c\\d", 12, S_OK},
+    {"\\\\?\\C:", 6, S_OK},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}", 48, S_OK},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\", 49, S_OK},
+    {"\\\\?\\unc\\a\\b", 11, S_OK},
+    {"\\\\?\\volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\", 49, S_OK},
+    {"\\\\?\\volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a", 49, S_OK},
+
+    /* Malformed */
+    {"C:", 2, S_OK},
+    {":", 0, E_INVALIDARG},
+    {":\\", 0, E_INVALIDARG},
+    {"C\\", 0, E_INVALIDARG},
+    {"\\?", 1, S_OK},
+    {"\\?\\UNC", 1, S_OK},
+    {"\\\\?\\", 0, E_INVALIDARG},
+    {"\\\\?\\UNC", 0, E_INVALIDARG},
+    {"\\\\?\\::\\", 0, E_INVALIDARG},
+    {"\\\\?\\Volume", 0, E_INVALIDARG},
+    {"\\.", 1, S_OK},
+    {"\\\\..", 4, S_OK},
+    {"\\\\..a", 5, S_OK}
+};
+
+static void test_PathCchSkipRoot(void)
+{
+    WCHAR pathW[MAX_PATH];
+    const WCHAR *root_end;
+    HRESULT hr;
+    INT i;
+
+    if (!pPathCchSkipRoot)
+    {
+        win_skip("PathCchSkipRoot() is not available.\n");
+        return;
+    }
+
+    root_end = (const WCHAR *)0xdeadbeef;
+    hr = pPathCchSkipRoot(NULL, &root_end);
+    ok(hr == E_INVALIDARG, "Expect result %#x, got %#x\n", E_INVALIDARG, hr);
+    ok(root_end == (const WCHAR *)0xdeadbeef, "Expect root_end 0xdeadbeef, got %p\n", root_end);
+
+    MultiByteToWideChar(CP_ACP, 0, "C:\\", -1, pathW, ARRAY_SIZE(pathW));
+    hr = pPathCchSkipRoot(pathW, NULL);
+    ok(hr == E_INVALIDARG, "Expect result %#x, got %#x\n", E_INVALIDARG, hr);
+
+    for (i = 0; i < ARRAY_SIZE(skiproot_tests); i++)
+    {
+        const struct skiproot_test *t = skiproot_tests + i;
+        MultiByteToWideChar(CP_ACP, 0, t->path, -1, pathW, ARRAY_SIZE(pathW));
+        hr = pPathCchSkipRoot(pathW, &root_end);
+        ok(hr == t->hr, "path %s expect result %#x, got %#x\n", t->path, t->hr, hr);
+        if (SUCCEEDED(hr))
+            ok(root_end - pathW == t->root_offset, "path %s expect root offset %d, got %d\n", t->path, t->root_offset,
+               root_end - pathW);
+    }
+}
+
+struct stripprefix_test
+{
+    const CHAR *path;
+    const CHAR *stripped_path;
+    HRESULT hr;
+    SIZE_T size;
+};
+
+static const struct stripprefix_test stripprefix_tests[] =
+{
+    {"\\\\?\\UNC\\", "\\\\", S_OK},
+    {"\\\\?\\UNC\\a", "\\\\a", S_OK},
+    {"\\\\?\\C:", "C:", S_OK},
+    {"\\\\?\\C:\\", "C:\\", S_OK},
+    {"\\\\?\\C:\\a", "C:\\a", S_OK},
+    {"\\\\?\\unc\\", "\\\\", S_OK},
+    {"\\\\?\\c:\\", "c:\\", S_OK},
+
+    {"\\", "\\", S_FALSE},
+    {"\\\\", "\\\\", S_FALSE},
+    {"\\\\a", "\\\\a", S_FALSE},
+    {"\\\\a\\", "\\\\a\\", S_FALSE},
+    {"\\\\?\\a", "\\\\?\\a", S_FALSE},
+    {"\\\\?\\UNC", "\\\\?\\UNC", S_FALSE},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\", S_FALSE},
+
+    /* Size Tests */
+    {"C:\\", NULL, E_INVALIDARG, PATHCCH_MAX_CCH + 1},
+    {"C:\\", "C:\\", S_FALSE, PATHCCH_MAX_CCH},
+    /* Size < original path actual length + 1, read beyond size */
+    {"\\\\?\\C:\\", "C:\\", S_OK, ARRAY_SIZE("\\\\?\\C:\\") - 1},
+    /* Size < stripped path length + 1 */
+    {"\\\\?\\C:\\", NULL, E_INVALIDARG, ARRAY_SIZE("C:\\") - 1},
+    {"\\\\?\\UNC\\", NULL, E_INVALIDARG, ARRAY_SIZE("\\\\") - 1}
+};
+
+static void test_PathCchStripPrefix(void)
+{
+    WCHAR pathW[PATHCCH_MAX_CCH + 1] = {0};
+    CHAR stripped_pathA[PATHCCH_MAX_CCH];
+    SIZE_T size;
+    HRESULT hr;
+    INT i;
+
+    if (!pPathCchStripPrefix)
+    {
+        win_skip("PathCchStripPrefix(() is not available.\n");
+        return;
+    }
+
+    /* Null arguments */
+    hr = pPathCchStripPrefix(NULL, PATHCCH_MAX_CCH);
+    ok(hr == E_INVALIDARG, "expect %#x, got %#x\n", E_INVALIDARG, hr);
+
+    hr = pPathCchStripPrefix(pathW, 0);
+    ok(hr == E_INVALIDARG, "expect %#x, got %#x\n", E_INVALIDARG, hr);
+
+    for (i = 0; i < ARRAY_SIZE(stripprefix_tests); i++)
+    {
+        const struct stripprefix_test *t = stripprefix_tests + i;
+
+        MultiByteToWideChar(CP_ACP, 0, t->path, -1, pathW, ARRAY_SIZE(pathW));
+        size = t->size ? t->size : PATHCCH_MAX_CCH;
+        hr = pPathCchStripPrefix(pathW, size);
+        ok(hr == t->hr, "path %s expect result %#x, got %#x\n", t->path, t->hr, hr);
+        if (SUCCEEDED(hr))
+        {
+            WideCharToMultiByte(CP_ACP, 0, pathW, -1, stripped_pathA, ARRAY_SIZE(stripped_pathA), NULL, NULL);
+            ok(!lstrcmpA(stripped_pathA, t->stripped_path), "path %s expect stripped path %s, got %s\n", t->path,
+               t->stripped_path, stripped_pathA);
+        }
+    }
+}
+
+struct striptoroot_test
+{
+    const CHAR *path;
+    const CHAR *root;
+    HRESULT hr;
+    SIZE_T size;
+};
+
+static const struct striptoroot_test striptoroot_tests[] =
+{
+    /* Invalid */
+    {"", "", E_INVALIDARG},
+    {"C", NULL, E_INVALIDARG},
+    {"\\\\?\\UNC", NULL, E_INVALIDARG},
+
+    /* Size */
+    {"C:\\", NULL, E_INVALIDARG, PATHCCH_MAX_CCH + 1},
+    {"C:\\", "C:\\", S_FALSE, PATHCCH_MAX_CCH},
+    /* Size < original path length + 1, read beyond size */
+    {"C:\\a", "C:\\", S_OK, ARRAY_SIZE("C:\\a") - 1},
+    /* Size < stripped path length + 1 */
+    {"C:\\a", "C:\\", E_INVALIDARG, ARRAY_SIZE("C:\\") - 1},
+    {"\\\\a\\b\\c", NULL, E_INVALIDARG, ARRAY_SIZE("\\\\a\\b") - 1},
+
+    /* X: */
+    {"C:", "C:", S_FALSE},
+    {"C:a", "C:", S_OK},
+    {"C:a\\b", "C:", S_OK},
+    {"C:a\\b\\c", "C:", S_OK},
+
+    /* X:\ */
+    {"C:\\", "C:\\", S_FALSE},
+    {"C:\\a", "C:\\", S_OK},
+    {"C:\\a\\b", "C:\\", S_OK},
+    {"C:\\a\\b\\c", "C:\\", S_OK},
+
+    /* \ */
+    {"\\", "\\", S_FALSE},
+    {"\\a", "\\", S_OK},
+    {"\\a\\b", "\\", S_OK},
+    {"\\a\\b\\c", "\\", S_OK},
+
+    /* \\ */
+    {"\\\\", "\\\\", S_FALSE},
+    {"\\\\a", "\\\\a", S_FALSE},
+    {"\\\\a\\b", "\\\\a\\b", S_FALSE},
+    {"\\\\a\\b\\c", "\\\\a\\b", S_OK},
+
+    /* UNC */
+    {"\\\\?\\UNC\\", "\\\\?\\UNC\\", S_FALSE},
+    {"\\\\?\\UNC\\a", "\\\\?\\UNC\\a", S_FALSE},
+    {"\\\\?\\UNC\\a\\b", "\\\\?\\UNC\\a\\b", S_FALSE},
+    {"\\\\?\\UNC\\a\\b\\", "\\\\?\\UNC\\a\\b", S_OK},
+    {"\\\\?\\UNC\\a\\b\\c", "\\\\?\\UNC\\a\\b", S_OK},
+
+    /* Prefixed X: */
+    {"\\\\?\\C:", "\\\\?\\C:", S_FALSE},
+    {"\\\\?\\C:a", "\\\\?\\C:", S_OK},
+    {"\\\\?\\C:a\\b", "\\\\?\\C:", S_OK},
+    {"\\\\?\\C:a\\b\\c", "\\\\?\\C:", S_OK},
+
+    /* Prefixed X:\ */
+    {"\\\\?\\C:\\", "\\\\?\\C:\\", S_FALSE},
+    {"\\\\?\\C:\\a", "\\\\?\\C:\\", S_OK},
+    {"\\\\?\\C:\\a\\b", "\\\\?\\C:\\", S_OK},
+    {"\\\\?\\C:\\a\\b\\c", "\\\\?\\C:\\", S_OK},
+
+    /* UNC Volume */
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}", S_FALSE},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}a",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}", S_OK},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}a\\b",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}", S_OK},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}a\\b\\c",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}", S_OK},
+
+    /* UNC Volume with backslash */
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\", S_FALSE},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\", S_OK},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a\\b",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\", S_OK},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a\\b\\c",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\", S_OK},
+};
+
+static void test_PathCchStripToRoot(void)
+{
+    WCHAR pathW[PATHCCH_MAX_CCH];
+    CHAR rootA[PATHCCH_MAX_CCH];
+    SIZE_T size;
+    HRESULT hr;
+    INT i;
+
+    if (!pPathCchStripToRoot)
+    {
+        win_skip("PathCchStripToRoot() is not available.\n");
+        return;
+    }
+
+    /* Null arguments */
+    hr = pPathCchStripToRoot(NULL, ARRAY_SIZE(pathW));
+    ok(hr == E_INVALIDARG, "Expect result %#x, got %#x\n", E_INVALIDARG, hr);
+
+    MultiByteToWideChar(CP_ACP, 0, "C:\\a", -1, pathW, ARRAY_SIZE(pathW));
+    hr = pPathCchStripToRoot(pathW, 0);
+    ok(hr == E_INVALIDARG, "Expect result %#x, got %#x\n", E_INVALIDARG, hr);
+
+    for (i = 0; i < ARRAY_SIZE(striptoroot_tests); i++)
+    {
+        const struct striptoroot_test *t = striptoroot_tests + i;
+        MultiByteToWideChar(CP_ACP, 0, t->path, -1, pathW, ARRAY_SIZE(pathW));
+        size = t->size ? t->size : ARRAY_SIZE(pathW);
+        hr = pPathCchStripToRoot(pathW, size);
+        ok(hr == t->hr, "path %s expect result %#x, got %#x\n", t->path, t->hr, hr);
+        if (SUCCEEDED(hr))
+        {
+            WideCharToMultiByte(CP_ACP, 0, pathW, -1, rootA, ARRAY_SIZE(rootA), NULL, NULL);
+            ok(!lstrcmpA(rootA, t->root), "path %s expect stripped path %s, got %s\n", t->path, t->root, rootA);
+        }
+    }
+}
+
+struct isuncex_test
+{
+    const CHAR *path;
+    INT server_offset;
+    BOOL ret;
+};
+
+static const struct isuncex_test isuncex_tests[] =
+{
+    {"\\\\", 2, TRUE},
+    {"\\\\a\\", 2, TRUE},
+    {"\\\\.\\", 2, TRUE},
+    {"\\\\?\\UNC\\", 8, TRUE},
+    {"\\\\?\\UNC\\a", 8, TRUE},
+    {"\\\\?\\unc\\", 8, TRUE},
+    {"\\\\?\\unc\\a", 8, TRUE},
+
+    {"", 0, FALSE},
+    {"\\", 0, FALSE},
+    {"C:\\", 0, FALSE},
+    {"\\??\\", 0, FALSE},
+    {"\\\\?\\", 0, FALSE},
+    {"\\\\?\\UNC", 0, FALSE},
+    {"\\\\?\\C:", 0, FALSE},
+    {"\\\\?\\C:\\", 0, FALSE},
+    {"\\\\?\\C:\\a", 0, FALSE},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\", 0, FALSE}
+};
+
+static void test_PathIsUNCEx(void)
+{
+    WCHAR pathW[MAX_PATH];
+    const WCHAR *server;
+    BOOL ret;
+    INT i;
+
+    if (!pPathIsUNCEx)
+    {
+        win_skip("PathIsUNCEx(() is not available.\n");
+        return;
+    }
+
+    /* No NULL check for path pointers on Windows */
+    if (0)
+    {
+        ret = pPathIsUNCEx(NULL, &server);
+        ok(ret == FALSE, "expect FALSE\n");
+    }
+
+    MultiByteToWideChar(CP_ACP, 0, "C:\\", -1, pathW, ARRAY_SIZE(pathW));
+    ret = pPathIsUNCEx(pathW, NULL);
+    ok(ret == FALSE, "expect FALSE\n");
+
+    for (i = 0; i < ARRAY_SIZE(isuncex_tests); i++)
+    {
+        const struct isuncex_test *t = isuncex_tests + i;
+
+        MultiByteToWideChar(CP_ACP, 0, t->path, -1, pathW, ARRAY_SIZE(pathW));
+        server = (const WCHAR *)0xdeadbeef;
+        ret = pPathIsUNCEx(pathW, &server);
+        ok(ret == t->ret, "path \"%s\" expect return %d, got %d\n", t->path, t->ret, ret);
+        if (ret)
+            ok(server == pathW + t->server_offset, "path \"%s\" expect server offset %d, got %d\n", t->path,
+               t->server_offset, server - pathW);
+        else
+            ok(!server, "expect server is null, got %p\n", server);
+    }
+}
+
 START_TEST(path)
 {
     HMODULE hmod = LoadLibraryA("kernelbase.dll");
 
-    pPathCchCombineEx = (void *)GetProcAddress(hmod, "PathCchCombineEx");
+    pPathAllocCanonicalize = (void *)GetProcAddress(hmod, "PathAllocCanonicalize");
+    pPathAllocCombine = (void *)GetProcAddress(hmod, "PathAllocCombine");
     pPathCchAddBackslash = (void *)GetProcAddress(hmod, "PathCchAddBackslash");
     pPathCchAddBackslashEx = (void *)GetProcAddress(hmod, "PathCchAddBackslashEx");
     pPathCchAddExtension = (void *)GetProcAddress(hmod, "PathCchAddExtension");
+    pPathCchAppendEx = (void *)GetProcAddress(hmod, "PathCchAppendEx");
+    pPathCchCanonicalize = (void *)GetProcAddress(hmod, "PathCchCanonicalize");
+    pPathCchCanonicalizeEx = (void *)GetProcAddress(hmod, "PathCchCanonicalizeEx");
+    pPathCchCombine = (void *)GetProcAddress(hmod, "PathCchCombine");
+    pPathCchCombineEx = (void *)GetProcAddress(hmod, "PathCchCombineEx");
     pPathCchFindExtension = (void *)GetProcAddress(hmod, "PathCchFindExtension");
+    pPathCchIsRoot = (void *)GetProcAddress(hmod, "PathCchIsRoot");
+    pPathCchRemoveBackslash = (void *)GetProcAddress(hmod, "PathCchRemoveBackslash");
+    pPathCchRemoveBackslashEx = (void *)GetProcAddress(hmod, "PathCchRemoveBackslashEx");
     pPathCchRemoveExtension = (void *)GetProcAddress(hmod, "PathCchRemoveExtension");
+    pPathCchRemoveFileSpec = (void *)GetProcAddress(hmod, "PathCchRemoveFileSpec");
     pPathCchRenameExtension = (void *)GetProcAddress(hmod, "PathCchRenameExtension");
+    pPathCchSkipRoot = (void *)GetProcAddress(hmod, "PathCchSkipRoot");
+    pPathCchStripPrefix = (void *)GetProcAddress(hmod, "PathCchStripPrefix");
+    pPathCchStripToRoot = (void *)GetProcAddress(hmod, "PathCchStripToRoot");
+    pPathIsUNCEx = (void *)GetProcAddress(hmod, "PathIsUNCEx");
 
-    test_PathCchCombineEx();
+    test_PathAllocCanonicalize();
+    test_PathAllocCombine();
     test_PathCchAddBackslash();
     test_PathCchAddBackslashEx();
     test_PathCchAddExtension();
+    test_PathCchAppendEx();
+    test_PathCchCanonicalize();
+    test_PathCchCanonicalizeEx();
+    test_PathCchCombine();
+    test_PathCchCombineEx();
     test_PathCchFindExtension();
+    test_PathCchIsRoot();
+    test_PathCchRemoveBackslash();
+    test_PathCchRemoveBackslashEx();
     test_PathCchRemoveExtension();
+    test_PathCchRemoveFileSpec();
     test_PathCchRenameExtension();
+    test_PathCchSkipRoot();
+    test_PathCchStripPrefix();
+    test_PathCchStripToRoot();
+    test_PathIsUNCEx();
 }
diff --git a/include/pathcch.h b/include/pathcch.h
index 3057b6c1ec..18f065c4c6 100644
--- a/include/pathcch.h
+++ b/include/pathcch.h
@@ -22,13 +22,28 @@
 #define PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS 0x04
 #define PATHCCH_DO_NOT_NORMALIZE_SEGMENTS       0x08
 #define PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH  0x10
+#define PATHCCH_ENSURE_TRAILING_SLASH           0x20
 
 #define PATHCCH_MAX_CCH 0x8000
 
+HRESULT WINAPI PathAllocCanonicalize(const WCHAR *path_in, DWORD flags, WCHAR **path_out);
+HRESULT WINAPI PathAllocCombine(const WCHAR *path1, const WCHAR *path2, DWORD flags, WCHAR **out);
 HRESULT WINAPI PathCchAddBackslash(WCHAR *path, SIZE_T size);
 HRESULT WINAPI PathCchAddBackslashEx(WCHAR *path, SIZE_T size, WCHAR **end, SIZE_T *remaining);
 HRESULT WINAPI PathCchAddExtension(WCHAR *path, SIZE_T size, const WCHAR *extension);
+HRESULT WINAPI PathCchAppendEx(WCHAR *path1, SIZE_T size, const WCHAR *path2, DWORD flags);
+HRESULT WINAPI PathCchCanonicalize(WCHAR *out, SIZE_T size, const WCHAR *in);
+HRESULT WINAPI PathCchCanonicalizeEx(WCHAR *out, SIZE_T size, const WCHAR *in, DWORD flags);
+HRESULT WINAPI PathCchCombine(WCHAR *out, SIZE_T size, const WCHAR *path1, const WCHAR *path2);
 HRESULT WINAPI PathCchCombineEx(WCHAR *out, SIZE_T size, const WCHAR *path1, const WCHAR *path2, DWORD flags);
 HRESULT WINAPI PathCchFindExtension(const WCHAR *path, SIZE_T size, const WCHAR **extension);
+BOOL    WINAPI PathCchIsRoot(const WCHAR *path);
+HRESULT WINAPI PathCchRemoveBackslash(WCHAR *path, SIZE_T path_size);
+HRESULT WINAPI PathCchRemoveBackslashEx(WCHAR *path, SIZE_T path_size, WCHAR **path_end, SIZE_T *free_size);
 HRESULT WINAPI PathCchRemoveExtension(WCHAR *path, SIZE_T size);
+HRESULT WINAPI PathCchRemoveFileSpec(WCHAR *path, SIZE_T size);
 HRESULT WINAPI PathCchRenameExtension(WCHAR *path, SIZE_T size, const WCHAR *extension);
+HRESULT WINAPI PathCchSkipRoot(const WCHAR *path, const WCHAR **root_end);
+HRESULT WINAPI PathCchStripPrefix(WCHAR *path, SIZE_T size);
+HRESULT WINAPI PathCchStripToRoot(WCHAR *path, SIZE_T size);
+BOOL    WINAPI PathIsUNCEx(const WCHAR *path, const WCHAR **server);
