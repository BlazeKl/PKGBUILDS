diff --git a/dlls/user32/input.c b/dlls/user32/input.c
index 8b2ae805aa..f3f5646a4c 100644
--- a/dlls/user32/input.c
+++ b/dlls/user32/input.c
@@ -33,6 +33,7 @@
 #include <assert.h>
 
 #define NONAMELESSUNION
+#define NONAMELESSSTRUCT
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -129,6 +130,35 @@ BOOL CDECL __wine_send_input( HWND hwnd, const INPUT *input )
     return !status;
 }
 
+BOOL CDECL __wine_send_raw_input( const RAWINPUT *raw_input )
+{
+    NTSTATUS status;
+
+    SERVER_START_REQ( send_rawinput_message )
+    {
+        req->input.type = raw_input->header.dwType;
+        switch (raw_input->header.dwType)
+        {
+        case RIM_TYPEMOUSE:
+            if (raw_input->data.mouse.usFlags ||
+                raw_input->data.mouse.ulRawButtons ||
+                raw_input->data.mouse.ulExtraInformation)
+                FIXME("Unhandled parameters\n");
+
+            req->input.mouse.x = raw_input->data.mouse.lLastX;
+            req->input.mouse.y = raw_input->data.mouse.lLastY;
+            req->input.mouse.button_flags = raw_input->data.mouse.u.s.usButtonFlags;
+            req->input.mouse.button_data = raw_input->data.mouse.u.s.usButtonData;
+            break;
+        }
+        status = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+
+    if (status) SetLastError( RtlNtStatusToDosError(status) );
+    return !status;
+}
+
 
 /***********************************************************************
  *		update_mouse_coords
diff --git a/dlls/user32/message.c b/dlls/user32/message.c
index 43ce77c2dd..b6dd7d5932 100644
--- a/dlls/user32/message.c
+++ b/dlls/user32/message.c
@@ -2295,54 +2295,14 @@ static BOOL process_rawinput_message( MSG *msg, const struct hardware_msg_data *
     rawinput->header.dwType = msg_data->rawinput.type;
     if (msg_data->rawinput.type == RIM_TYPEMOUSE)
     {
-        static const unsigned int button_flags[] =
-        {
-            0,                              /* MOUSEEVENTF_MOVE */
-            RI_MOUSE_LEFT_BUTTON_DOWN,      /* MOUSEEVENTF_LEFTDOWN */
-            RI_MOUSE_LEFT_BUTTON_UP,        /* MOUSEEVENTF_LEFTUP */
-            RI_MOUSE_RIGHT_BUTTON_DOWN,     /* MOUSEEVENTF_RIGHTDOWN */
-            RI_MOUSE_RIGHT_BUTTON_UP,       /* MOUSEEVENTF_RIGHTUP */
-            RI_MOUSE_MIDDLE_BUTTON_DOWN,    /* MOUSEEVENTF_MIDDLEDOWN */
-            RI_MOUSE_MIDDLE_BUTTON_UP,      /* MOUSEEVENTF_MIDDLEUP */
-        };
-        unsigned int i;
-
         rawinput->header.dwSize  = FIELD_OFFSET(RAWINPUT, data) + sizeof(RAWMOUSE);
         rawinput->header.hDevice = WINE_MOUSE_HANDLE;
         rawinput->header.wParam  = 0;
 
         rawinput->data.mouse.usFlags           = MOUSE_MOVE_RELATIVE;
-        rawinput->data.mouse.u.s.usButtonFlags = 0;
-        rawinput->data.mouse.u.s.usButtonData  = 0;
-        for (i = 1; i < ARRAY_SIZE(button_flags); ++i)
-        {
-            if (msg_data->flags & (1 << i))
-                rawinput->data.mouse.u.s.usButtonFlags |= button_flags[i];
-        }
-        if (msg_data->flags & MOUSEEVENTF_WHEEL)
-        {
-            rawinput->data.mouse.u.s.usButtonFlags |= RI_MOUSE_WHEEL;
-            rawinput->data.mouse.u.s.usButtonData   = msg_data->rawinput.mouse.data;
-        }
-        if (msg_data->flags & MOUSEEVENTF_HWHEEL)
-        {
-            rawinput->data.mouse.u.s.usButtonFlags |= RI_MOUSE_HORIZONTAL_WHEEL;
-            rawinput->data.mouse.u.s.usButtonData   = msg_data->rawinput.mouse.data;
-        }
-        if (msg_data->flags & MOUSEEVENTF_XDOWN)
-        {
-            if (msg_data->rawinput.mouse.data == XBUTTON1)
-                rawinput->data.mouse.u.s.usButtonFlags |= RI_MOUSE_BUTTON_4_DOWN;
-            else if (msg_data->rawinput.mouse.data == XBUTTON2)
-                rawinput->data.mouse.u.s.usButtonFlags |= RI_MOUSE_BUTTON_5_DOWN;
-        }
-        if (msg_data->flags & MOUSEEVENTF_XUP)
-        {
-            if (msg_data->rawinput.mouse.data == XBUTTON1)
-                rawinput->data.mouse.u.s.usButtonFlags |= RI_MOUSE_BUTTON_4_UP;
-            else if (msg_data->rawinput.mouse.data == XBUTTON2)
-                rawinput->data.mouse.u.s.usButtonFlags |= RI_MOUSE_BUTTON_5_UP;
-        }
+
+        rawinput->data.mouse.u.s.usButtonFlags = msg_data->rawinput.mouse.button_flags;
+        rawinput->data.mouse.u.s.usButtonData = msg_data->rawinput.mouse.button_data;
 
         rawinput->data.mouse.ulRawButtons       = 0;
         rawinput->data.mouse.lLastX             = msg_data->rawinput.mouse.x;
diff --git a/dlls/user32/rawinput.c b/dlls/user32/rawinput.c
index 49cf9f73a0..58480b8ae7 100644
--- a/dlls/user32/rawinput.c
+++ b/dlls/user32/rawinput.c
@@ -271,7 +271,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH RegisterRawInputDevices(RAWINPUTDEVICE *devices, U
         TRACE("device %u: page %#x, usage %#x, flags %#x, target %p.\n",
                 i, devices[i].usUsagePage, devices[i].usUsage,
                 devices[i].dwFlags, devices[i].hwndTarget);
-        if (devices[i].dwFlags & ~RIDEV_REMOVE)
+        if (devices[i].dwFlags & ~(RIDEV_REMOVE|RIDEV_NOLEGACY))
             FIXME("Unhandled flags %#x for device %u.\n", devices[i].dwFlags, i);
 
         d[i].usage_page = devices[i].usUsagePage;
diff --git a/dlls/user32/user32.spec b/dlls/user32/user32.spec
index f9a4ae26df..3311dcd685 100644
--- a/dlls/user32/user32.spec
+++ b/dlls/user32/user32.spec
@@ -833,4 +833,5 @@
 # or 'wine_' (for user-visible functions) to avoid namespace conflicts.
 #
 @ cdecl __wine_send_input(long ptr)
+@ cdecl __wine_send_raw_input(ptr)
 @ cdecl __wine_set_pixel_format(long long)
diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index 5c465aa033..1e64f0d2a3 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -271,46 +271,6 @@ enum event_merge_action
     MERGE_IGNORE    /* ignore the new event, keep the old one */
 };
 
-/***********************************************************************
- *           merge_raw_motion_events
- */
-#ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
-static enum event_merge_action merge_raw_motion_events( XIRawEvent *prev, XIRawEvent *next )
-{
-    int i, j, k;
-    unsigned char mask;
-
-    if (!prev->valuators.mask_len) return MERGE_HANDLE;
-    if (!next->valuators.mask_len) return MERGE_HANDLE;
-
-    mask = prev->valuators.mask[0] | next->valuators.mask[0];
-    if (mask == next->valuators.mask[0])  /* keep next */
-    {
-        for (i = j = k = 0; i < 8; i++)
-        {
-            if (XIMaskIsSet( prev->valuators.mask, i ))
-                next->valuators.values[j] += prev->valuators.values[k++];
-            if (XIMaskIsSet( next->valuators.mask, i )) j++;
-        }
-        TRACE( "merging duplicate GenericEvent\n" );
-        return MERGE_DISCARD;
-    }
-    if (mask == prev->valuators.mask[0])  /* keep prev */
-    {
-        for (i = j = k = 0; i < 8; i++)
-        {
-            if (XIMaskIsSet( next->valuators.mask, i ))
-                prev->valuators.values[j] += next->valuators.values[k++];
-            if (XIMaskIsSet( prev->valuators.mask, i )) j++;
-        }
-        TRACE( "merging duplicate GenericEvent\n" );
-        return MERGE_IGNORE;
-    }
-    /* can't merge events with disjoint masks */
-    return MERGE_HANDLE;
-}
-#endif
-
 /***********************************************************************
  *           merge_events
  *
@@ -362,7 +322,7 @@ static enum event_merge_action merge_events( XEvent *prev, XEvent *next )
             if (next->xcookie.extension != xinput2_opcode) break;
             if (next->xcookie.evtype != XI_RawMotion) break;
             if (x11drv_thread_data()->warp_serial) break;
-            return merge_raw_motion_events( prev->xcookie.data, next->xcookie.data );
+            return MERGE_HANDLE;
 #endif
         }
         break;
diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index f737a306a5..6df473e548 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -130,6 +130,8 @@ static Cursor create_cursor( HANDLE handle );
 
 #ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
 static BOOL xinput2_available;
+static int xinput2_version_major = 2;
+static int xinput2_version_minor = 1;
 static BOOL broken_rawevents;
 #define MAKE_FUNCPTR(f) static typeof(f) * p##f
 MAKE_FUNCPTR(XIGetClientPointer);
@@ -257,6 +259,11 @@ static void update_relative_valuators(XIAnyClassInfo **valuators, int n_valuator
 
     thread_data->x_rel_valuator.number = -1;
     thread_data->y_rel_valuator.number = -1;
+    thread_data->wheel_valuator.number = -1;
+
+    thread_data->x_rel_valuator.accum = 0;
+    thread_data->y_rel_valuator.accum = 0;
+    thread_data->wheel_valuator.accum = 0;
 
     for (i = 0; i < n_valuators; i++)
     {
@@ -274,6 +281,11 @@ static void update_relative_valuators(XIAnyClassInfo **valuators, int n_valuator
         {
             valuator_data = &thread_data->y_rel_valuator;
         }
+        else if (class->label == x11drv_atom( Rel_Vert_Scroll ) ||
+                 (!class->label && class->number == 3 && class->mode == XIModeRelative))
+        {
+            valuator_data = &thread_data->wheel_valuator;
+        }
 
         if (valuator_data) {
             valuator_data->number = class->number;
@@ -286,9 +298,9 @@ static void update_relative_valuators(XIAnyClassInfo **valuators, int n_valuator
 
 
 /***********************************************************************
- *              enable_xinput2
+ *              X11DRV_XInput2_Enable
  */
-static void enable_xinput2(void)
+void X11DRV_XInput2_Enable(void)
 {
 #ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
     struct x11drv_thread_data *data = x11drv_thread_data();
@@ -301,8 +313,11 @@ static void enable_xinput2(void)
 
     if (data->xi2_state == xi_unknown)
     {
-        int major = 2, minor = 0;
-        if (!pXIQueryVersion( data->display, &major, &minor )) data->xi2_state = xi_disabled;
+        if (!pXIQueryVersion( data->display, &xinput2_version_major, &xinput2_version_minor ))
+        {
+            TRACE( "XInput2 v%d.%d available\n", xinput2_version_major, xinput2_version_minor );
+            data->xi2_state = xi_disabled;
+        }
         else
         {
             data->xi2_state = xi_unavailable;
@@ -314,11 +329,20 @@ static void enable_xinput2(void)
 
     mask.mask     = mask_bits;
     mask.mask_len = sizeof(mask_bits);
-    mask.deviceid = XIAllDevices;
+    mask.deviceid = XIAllMasterDevices;
     memset( mask_bits, 0, sizeof(mask_bits) );
-    XISetMask( mask_bits, XI_DeviceChanged );
     XISetMask( mask_bits, XI_RawMotion );
-    XISetMask( mask_bits, XI_ButtonPress );
+    XISetMask( mask_bits, XI_RawButtonPress );
+    XISetMask( mask_bits, XI_RawButtonRelease );
+
+    /* XInput 2.0 has a problematic behavior where master pointer will
+     * not send raw events to the root window whenever a grab is active
+     */
+    if (xinput2_version_major == 2 && xinput2_version_minor == 0)
+    {
+        mask.deviceid = XIAllDevices;
+        XISetMask( mask_bits, XI_DeviceChanged );
+    }
 
     pXISelectEvents( data->display, DefaultRootWindow( data->display ), &mask, 1 );
 
@@ -333,7 +357,7 @@ static void enable_xinput2(void)
      * safe to be obtained statically at enable_xinput2() time.
      */
     if (data->xi2_devices) pXIFreeDeviceInfo( data->xi2_devices );
-    data->xi2_devices = pXIQueryDevice( data->display, XIAllDevices, &data->xi2_device_count );
+    data->xi2_devices = pXIQueryDevice( data->display, mask.deviceid, &data->xi2_device_count );
     data->xi2_current_slave = 0;
 
     data->xi2_state = xi_enabled;
@@ -341,33 +365,55 @@ static void enable_xinput2(void)
 }
 
 /***********************************************************************
- *              disable_xinput2
+ *              X11DRV_XInput2_Disable
  */
-static void disable_xinput2(void)
+void X11DRV_XInput2_Disable(void)
 {
 #ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
     struct x11drv_thread_data *data = x11drv_thread_data();
     XIEventMask mask;
 
-    if (data->xi2_state != xi_enabled) return;
+    if (data->xi2_state < xi_enabled) return;
 
     TRACE( "disabling\n" );
     data->xi2_state = xi_disabled;
 
     mask.mask = NULL;
     mask.mask_len = 0;
-    mask.deviceid = XIAllDevices;
+    mask.deviceid = XIAllMasterDevices;
+
+    /* XInput 2.0 has a problematic behavior where master pointer will
+     * not send raw events to the root window whenever a grab is active
+     */
+    if (xinput2_version_major == 2 && xinput2_version_minor == 0)
+        mask.deviceid = XIAllDevices;
 
     pXISelectEvents( data->display, DefaultRootWindow( data->display ), &mask, 1 );
     pXIFreeDeviceInfo( data->xi2_devices );
     data->x_rel_valuator.number = -1;
     data->y_rel_valuator.number = -1;
+    data->wheel_valuator.number = -1;
     data->xi2_devices = NULL;
     data->xi2_core_pointer = 0;
     data->xi2_current_slave = 0;
 #endif
 }
 
+static void use_xinput2_path(void)
+{
+    struct x11drv_thread_data *thread_data = x11drv_thread_data();
+
+    if (thread_data->xi2_state == xi_enabled)
+        thread_data->xi2_state = xi_extra;
+}
+
+static void disable_xinput2_path(void)
+{
+    struct x11drv_thread_data *thread_data = x11drv_thread_data();
+
+    if (thread_data->xi2_state == xi_extra)
+        thread_data->xi2_state = xi_enabled;
+}
 
 /***********************************************************************
  *		grab_clipping_window
@@ -393,9 +439,9 @@ static BOOL grab_clipping_window( const RECT *clip )
         return TRUE;
 
     /* enable XInput2 unless we are already clipping */
-    if (!data->clip_hwnd) enable_xinput2();
+    if (!data->clip_hwnd) use_xinput2_path();
 
-    if (data->xi2_state != xi_enabled)
+    if (data->xi2_state < xi_extra)
     {
         WARN( "XInput2 not supported, refusing to clip to %s\n", wine_dbgstr_rect(clip) );
         DestroyWindow( msg_hwnd );
@@ -423,7 +469,7 @@ static BOOL grab_clipping_window( const RECT *clip )
     if (!clipping_cursor)
     {
         ERR("Failed to grab pointer\n");
-        disable_xinput2();
+        disable_xinput2_path();
         DestroyWindow( msg_hwnd );
         return FALSE;
     }
@@ -489,7 +535,7 @@ LRESULT clip_cursor_notify( HWND hwnd, HWND new_clip_hwnd )
         TRACE( "clip hwnd reset from %p\n", hwnd );
         data->clip_hwnd = 0;
         data->clip_reset = GetTickCount();
-        disable_xinput2();
+        disable_xinput2_path();
         DestroyWindow( hwnd );
     }
     else if (hwnd == GetForegroundWindow())  /* request to clip */
@@ -1724,41 +1770,52 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
 {
     XIRawEvent *event = xev->data;
     const double *values = event->valuators.values;
+    const double *raw_values = event->raw_values;
     RECT virtual_rect;
     INPUT input;
     POINT pt;
+    RAWINPUT raw_input;
     int i;
-    double dx = 0, dy = 0, val;
+    double dx = 0, dy = 0, raw_dx = 0, raw_dy = 0, raw_dwheel = 0, val, raw_val;
     struct x11drv_thread_data *thread_data = x11drv_thread_data();
-    struct x11drv_valuator_data *x_rel, *y_rel;
+    struct x11drv_valuator_data *x_rel, *y_rel, *wheel;
 
-    if (thread_data->x_rel_valuator.number < 0 || thread_data->y_rel_valuator.number < 0) return FALSE;
+    if (thread_data->x_rel_valuator.number < 0 || thread_data->y_rel_valuator.number < 0 || thread_data->wheel_valuator.number < 0) return FALSE;
     if (!event->valuators.mask_len) return FALSE;
-    if (thread_data->xi2_state != xi_enabled) return FALSE;
+    if (thread_data->xi2_state < xi_enabled) return FALSE;
 
-    /* If there is no slave currently detected, no previous motion nor device
-     * change events were received. Look it up now on the device list in this
-     * case.
-     */
-    if (!thread_data->xi2_current_slave)
+    if (xinput2_version_major == 2 && xinput2_version_minor == 0)
     {
         XIDeviceInfo *devices = thread_data->xi2_devices;
 
-        for (i = 0; i < thread_data->xi2_device_count; i++)
+        /* If there is no slave currently detected, no previous motion nor device
+         * change events were received. Look it up now on the device list in this
+         * case.
+         */
+        for (i = 0; !thread_data->xi2_current_slave && i < thread_data->xi2_device_count; i++)
         {
             if (devices[i].use != XISlavePointer) continue;
             if (devices[i].deviceid != event->deviceid) continue;
             if (devices[i].attachment != thread_data->xi2_core_pointer) continue;
             thread_data->xi2_current_slave = event->deviceid;
-            break;
         }
-    }
 
-    if (event->deviceid != thread_data->xi2_current_slave) return FALSE;
+        /* Only listen to slave device events on XInput == 2.0 */
+        if (event->deviceid != thread_data->xi2_current_slave)
+            return FALSE;
+    }
+    else
+    {
+        /* Only listen to master device events on XInput >= 2.1 */
+        if (event->deviceid != thread_data->xi2_core_pointer)
+            return FALSE;
+    }
 
     x_rel = &thread_data->x_rel_valuator;
     y_rel = &thread_data->y_rel_valuator;
+    wheel = &thread_data->wheel_valuator;
 
+    input.type = INPUT_MOUSE;
     input.u.mi.mouseData   = 0;
     input.u.mi.dwFlags     = MOUSEEVENTF_MOVE;
     input.u.mi.time        = EVENT_x11_time_to_win32_time( event->time );
@@ -1765,44 +1822,154 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
     input.u.mi.dx          = 0;
     input.u.mi.dy          = 0;
 
+    raw_input.header.dwType = RIM_TYPEMOUSE;
+    raw_input.data.mouse.u.usButtonFlags = 0;
+    raw_input.data.mouse.u.usButtonData = 0;
+    raw_input.data.mouse.ulExtraInformation = 0;
+    raw_input.data.mouse.ulRawButtons = 0;
+    raw_input.data.mouse.usFlags = 0;
+    raw_input.data.mouse.lLastX = 0;
+    raw_input.data.mouse.lLastY = 0;
+
     virtual_rect = get_virtual_screen_rect();
 
-    for (i = 0; i <= max ( x_rel->number, y_rel->number ); i++)
+    for (i = 0; i <= max( wheel->number, max( x_rel->number, y_rel->number ) ); i++)
     {
         if (!XIMaskIsSet( event->valuators.mask, i )) continue;
         val = *values++;
+        raw_val = *raw_values++;
         if (i == x_rel->number)
         {
-            input.u.mi.dx = dx = val;
+            dx = val;
             if (x_rel->min < x_rel->max)
-                input.u.mi.dx = val * (virtual_rect.right - virtual_rect.left)
+                dx = val * (virtual_rect.right - virtual_rect.left)
                                     / (x_rel->max - x_rel->min);
+
+            raw_input.data.mouse.lLastX = raw_dx = raw_val;
         }
         if (i == y_rel->number)
         {
-            input.u.mi.dy = dy = val;
+            dy = val;
             if (y_rel->min < y_rel->max)
-                input.u.mi.dy = val * (virtual_rect.bottom - virtual_rect.top)
+                dy = val * (virtual_rect.bottom - virtual_rect.top)
                                     / (y_rel->max - y_rel->min);
+
+            raw_input.data.mouse.lLastY = raw_dy = raw_val;
+        }
+        if (i == wheel->number)
+        {
+            /* NOTE: Testing showed a 8x factor between X11 and Windows
+             * values, but that may be device specific
+             */
+            raw_dwheel = raw_val * -8;
         }
     }
 
     if (broken_rawevents && is_old_motion_event( xev->serial ))
     {
-        TRACE( "pos %d,%d old serial %lu, ignoring\n", input.u.mi.dx, input.u.mi.dy, xev->serial );
+        TRACE( "pos %d,%d old serial %lu, ignoring\n", (LONG) dx, (LONG) dy, xev->serial );
         return FALSE;
     }
 
     pt.x = input.u.mi.dx;
     pt.y = input.u.mi.dy;
     fs_hack_scale_real_to_user(&pt);
     input.u.mi.dx = pt.x;
     input.u.mi.dy = pt.y;
 
-    TRACE( "pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
+    /* Accumulate the fractional parts so they aren't lost after casting
+     *  successive motion values to integral fields.
+     *
+     * Note: It looks like raw_dx and raw_dy are already integral values
+     * but that may be wrong.
+     */
+
+    x_rel->accum += dx;
+    y_rel->accum += dy;
+    if (fabs(x_rel->accum) < 1.0 && fabs(y_rel->accum) < 1.0)
+    {
+        TRACE( "accumulating raw motion (event %f,%f, accum %f,%f)\n", dx, dy, x_rel->accum, y_rel->accum );
+    }
+    else
+    {
+        input.u.mi.dx = x_rel->accum;
+        input.u.mi.dy = y_rel->accum;
+        x_rel->accum -= input.u.mi.dx;
+        y_rel->accum -= input.u.mi.dy;
+
+        if (thread_data->xi2_state == xi_extra)
+        {
+            TRACE( "pos %d,%d (event %f,%f)\n", input.u.mi.dx, input.u.mi.dy, dx, dy );
+            __wine_send_input( 0, &input );
+        }
+    }
+
+    wheel->accum += raw_dwheel;
+    if (fabs(wheel->accum) < 1.0)
+    {
+        TRACE("accumulating wheel motion (event %f, accum %f)\n", raw_dwheel, wheel->accum);
+    }
+    else
+    {
+        raw_input.data.mouse.u.usButtonFlags = RI_MOUSE_WHEEL;
+        raw_input.data.mouse.u.usButtonData  = wheel->accum;
+        wheel->accum -= raw_dwheel;
+    }
+
+    TRACE("raw event %f,%f + %f\n",  raw_dx, raw_dy, raw_dwheel);
+    __wine_send_raw_input( &raw_input );
+
+    return TRUE;
+}
+
+/***********************************************************************
+ *           X11DRV_RawButton
+ */
+static BOOL X11DRV_RawButton( XGenericEventCookie *xev )
+{
+    RAWINPUT ri;
+
+    static const unsigned short raw_button_press_flags[] = {
+        0,                              /* 0 = unused */
+        RI_MOUSE_LEFT_BUTTON_DOWN,      /* 1 */
+        RI_MOUSE_MIDDLE_BUTTON_DOWN,    /* 2 */
+        RI_MOUSE_RIGHT_BUTTON_DOWN,     /* 3 */
+        0,                              /* 4 = unknown */
+        0,                              /* 5 = unknown */
+        0,                              /* 6 = unknown */
+        0,                              /* 7 = unknown */
+        RI_MOUSE_BUTTON_4_DOWN,         /* 8 */
+        RI_MOUSE_BUTTON_5_DOWN          /* 9 */
+    };
+
+    static const unsigned short raw_button_release_flags[] = {
+        0,                            /* 0 = unused */
+        RI_MOUSE_LEFT_BUTTON_UP,      /* 1 */
+        RI_MOUSE_MIDDLE_BUTTON_UP,    /* 2 */
+        RI_MOUSE_RIGHT_BUTTON_UP,     /* 3 */
+        0,                            /* 4 = unknown */
+        0,                            /* 5 = unknown */
+        0,                            /* 6 = unknown */
+        0,                            /* 7 = unknown */
+        RI_MOUSE_BUTTON_4_UP,         /* 8 */
+        RI_MOUSE_BUTTON_5_UP          /* 9 */
+    };
+
+    int detail = ((XIRawEvent*)xev->data)->detail;
+    if (detail > 9) return TRUE;
+
+    ri.header.dwType = RIM_TYPEMOUSE;
+    ri.data.mouse.u.usButtonFlags = xev->evtype == XI_RawButtonPress ? raw_button_press_flags[detail] : raw_button_release_flags[detail] ;
+    ri.data.mouse.u.usButtonData = 0;
+    ri.data.mouse.lLastX = 0;
+    ri.data.mouse.lLastY = 0;
+    ri.data.mouse.usFlags = 0;
+    ri.data.mouse.ulRawButtons = 0;
+    ri.data.mouse.ulExtraInformation = 0;
+
+    if (ri.data.mouse.u.usButtonFlags)
+        __wine_send_raw_input( &ri );
 
-    input.type = INPUT_MOUSE;
-    __wine_send_input( 0, &input );
     return TRUE;
 }
 
@@ -1864,6 +2031,11 @@ BOOL X11DRV_GenericEvent( HWND hwnd, XEvent *xev )
     case XI_RawMotion:
         ret = X11DRV_RawMotion( event );
         break;
+    case XI_RawButtonPress:
+        /* fall through */
+    case XI_RawButtonRelease:
+        ret = X11DRV_RawButton( event );
+        break;
 
     default:
         TRACE( "Unhandled event %#x\n", event->evtype );
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 0d3695bdcf..8a59874251 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -194,6 +194,8 @@ extern BOOL CDECL X11DRV_UnrealizePalette( HPALETTE hpal ) DECLSPEC_HIDDEN;
 
 extern void X11DRV_Xcursor_Init(void) DECLSPEC_HIDDEN;
 extern void X11DRV_XInput2_Init(void) DECLSPEC_HIDDEN;
+extern void X11DRV_XInput2_Enable(void) DECLSPEC_HIDDEN;
+extern void X11DRV_XInput2_Disable(void) DECLSPEC_HIDDEN;
 
 extern DWORD copy_image_bits( BITMAPINFO *info, BOOL is_r8g8b8, XImage *image,
                               const struct gdi_image_bits *src_bits, struct gdi_image_bits *dst_bits,
@@ -318,6 +320,7 @@ struct x11drv_valuator_data
     double min;
     double max;
     int number;
+    double accum;
 };
 
 struct x11drv_thread_data
@@ -335,11 +338,12 @@ struct x11drv_thread_data
     HWND     clip_hwnd;            /* message window stored in desktop while clipping is active */
     DWORD    clip_reset;           /* time when clipping was last reset */
     HKL      kbd_layout;           /* active keyboard layout */
-    enum { xi_unavailable = -1, xi_unknown, xi_disabled, xi_enabled } xi2_state; /* XInput2 state */
+    enum { xi_unavailable = -1, xi_unknown, xi_disabled, xi_enabled, xi_extra } xi2_state; /* XInput2 state */
     void    *xi2_devices;          /* list of XInput2 devices (valid when state is enabled) */
     int      xi2_device_count;
     struct x11drv_valuator_data x_rel_valuator;
     struct x11drv_valuator_data y_rel_valuator;
+    struct x11drv_valuator_data wheel_valuator;
     int      xi2_core_pointer;     /* XInput2 core pointer id */
     int      xi2_current_slave;    /* Current slave driving the Core pointer */
 };
@@ -425,6 +429,7 @@ enum x11drv_atoms
     XATOM_RAW_CAP_HEIGHT,
     XATOM_Rel_X,
     XATOM_Rel_Y,
+    XATOM_Rel_Vert_Scroll,
     XATOM_WM_PROTOCOLS,
     XATOM_WM_DELETE_WINDOW,
     XATOM_WM_STATE,
diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index 21807af3f1..86b6efac08 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -120,6 +120,7 @@ static const char * const atom_names[NB_XATOMS - FIRST_XATOM] =
     "RAW_CAP_HEIGHT",
     "Rel X",
     "Rel Y",
+    "Rel Vert Scroll",
     "WM_PROTOCOLS",
     "WM_DELETE_WINDOW",
     "WM_STATE",
@@ -611,6 +612,8 @@ void CDECL X11DRV_ThreadDetach(void)
 
     if (data)
     {
+        X11DRV_XInput2_Disable();
+
         if (data->xim) XCloseIM( data->xim );
         if (data->font_set) XFreeFontSet( data->display, data->font_set );
         XCloseDisplay( data->display );
@@ -681,6 +684,8 @@ struct x11drv_thread_data *x11drv_init_thread_data(void)
 
     if (use_xim) X11DRV_SetupXIM();
 
+    X11DRV_XInput2_Enable();
+
     return data;
 }
 
diff --git a/include/winuser.h b/include/winuser.h
index 51c73d25c2..259db275c4 100644
--- a/include/winuser.h
+++ b/include/winuser.h
@@ -4390,6 +4390,7 @@ WORD        WINAPI SYSTEM_KillSystemTimer( WORD );
 
 #ifdef __WINESRC__
 WINUSERAPI BOOL CDECL __wine_send_input( HWND hwnd, const INPUT *input );
+WINUSERAPI BOOL CDECL __wine_send_raw_input( const RAWINPUT *raw_input );
 #endif
 
 #ifdef __cplusplus
diff --git a/server/protocol.def b/server/protocol.def
index 8157199f2f..15cd48bbb5 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -286,30 +286,38 @@ struct hw_msg_source
     unsigned int    origin;        /* source origin (IMO_* values) */
 };
 
+typedef union
+{
+    int type;
+    struct
+    {
+        int            type;    /* RIM_TYPEKEYBOARD */
+        unsigned int   message; /* message generated by this rawinput event */
+        unsigned short vkey;    /* virtual key code */
+        unsigned short scan;    /* scan code */
+    } kbd;
+    struct
+    {
+        int            type;            /* RIM_TYPEMOUSE */
+        int            x;               /* x coordinate */
+        int            y;               /* y coordinate */
+        unsigned short button_flags;    /* mouse button */
+        unsigned short button_data;     /* event details */
+    } mouse;
+    struct
+    {
+        int type; /* RIM_TYPEHID */
+        /* TODO: fill this in if/when necessary */
+    } hid;
+} hw_rawinput_t;
+
 struct hardware_msg_data
 {
     lparam_t             info;      /* extra info */
     unsigned int         hw_id;     /* unique id */
     unsigned int         flags;     /* hook flags */
     struct hw_msg_source source;    /* message source */
-    union
-    {
-        int type;
-        struct
-        {
-            int            type;    /* RIM_TYPEKEYBOARD */
-            unsigned int   message; /* message generated by this rawinput event */
-            unsigned short vkey;    /* virtual key code */
-            unsigned short scan;    /* scan code */
-        } kbd;
-        struct
-        {
-            int            type;    /* RIM_TYPEMOUSE */
-            int            x;       /* x coordinate */
-            int            y;       /* y coordinate */
-            unsigned int   data;    /* mouse data */
-        } mouse;
-    } rawinput;
+    hw_rawinput_t        rawinput;
 };
 
 struct callback_msg_data
@@ -2317,6 +2325,11 @@ enum message_type
 #define SEND_HWMSG_INJECTED    0x01
 
 
+@REQ(send_rawinput_message)
+    hw_rawinput_t input;
+@END
+
+
 /* Get a message from the current queue */
 @REQ(get_message)
     unsigned int    flags;     /* PM_* flags */
diff --git a/server/queue.c b/server/queue.c
index 96587d11d1..70b4f88302 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -372,6 +372,9 @@ static void set_cursor_pos( struct desktop *desktop, int x, int y )
     static const struct hw_msg_source source = { IMDT_UNAVAILABLE, IMO_SYSTEM };
     struct message *msg;
 
+    if (current->process->rawinput_mouse && 
+        current->process->rawinput_mouse->flags & RIDEV_NOLEGACY) return;
+
     if (!(msg = alloc_hardware_message( 0, source, get_tick_count() ))) return;
 
     msg->msg = WM_MOUSEMOVE;
@@ -1596,6 +1599,8 @@ static int send_hook_ll_message( struct desktop *desktop, struct message *hardwa
     return 1;
 }
 
+static int emulate_raw_mouse = 1;
+
 /* queue a hardware message for a mouse event */
 static int queue_mouse_message( struct desktop *desktop, user_handle_t win, const hw_input_t *input,
                                 unsigned int origin, struct msg_queue *sender )
@@ -1624,6 +1629,16 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
         WM_MOUSEHWHEEL   /* 0x1000 = MOUSEEVENTF_HWHEEL */
     };
 
+    static const unsigned int raw_button_flags[] =     {
+        0,                            /* 0x0001 = MOUSEEVENTF_MOVE */
+        RI_MOUSE_LEFT_BUTTON_DOWN,    /* 0x0002 = MOUSEEVENTF_LEFTDOWN */
+        RI_MOUSE_LEFT_BUTTON_UP,      /* 0x0004 = MOUSEEVENTF_LEFTUP */
+        RI_MOUSE_RIGHT_BUTTON_DOWN,   /* 0x0008 = MOUSEEVENTF_RIGHTDOWN */
+        RI_MOUSE_RIGHT_BUTTON_UP,     /* 0x0010 = MOUSEEVENTF_RIGHTUP */
+        RI_MOUSE_MIDDLE_BUTTON_DOWN,  /* 0x0020 = MOUSEEVENTF_MIDDLEDOWN */
+        RI_MOUSE_MIDDLE_BUTTON_UP,    /* 0x0040 = MOUSEEVENTF_MIDDLEUP */
+    };
+
     desktop->cursor.last_change = get_tick_count();
     flags = input->mouse.flags;
     time  = input->mouse.time;
@@ -1651,7 +1666,8 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
         y = desktop->cursor.y;
     }
 
-    if ((device = current->process->rawinput_mouse))
+    device = current->process->rawinput_mouse;
+    if (device && emulate_raw_mouse)
     {
         if (!(msg = alloc_hardware_message( input->mouse.info, source, time ))) return 0;
         msg_data = msg->data;
@@ -1661,15 +1677,50 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
         msg->wparam    = RIM_INPUT;
         msg->lparam    = 0;
 
-        msg_data->flags               = flags;
+        msg_data->flags               = 0;
         msg_data->rawinput.type       = RIM_TYPEMOUSE;
         msg_data->rawinput.mouse.x    = x - desktop->cursor.x;
         msg_data->rawinput.mouse.y    = y - desktop->cursor.y;
-        msg_data->rawinput.mouse.data = input->mouse.data;
+        msg_data->rawinput.mouse.button_flags = 0;
+        msg_data->rawinput.mouse.button_data = 0;
+
+        for (i = 1; i < ARRAY_SIZE(raw_button_flags); ++i)
+        {
+            if (flags & (1 << i))
+                msg_data->rawinput.mouse.button_flags |= raw_button_flags[i];
+        }
+
+        if (flags & MOUSEEVENTF_WHEEL)
+        {
+            msg_data->rawinput.mouse.button_flags |= RI_MOUSE_WHEEL;
+            msg_data->rawinput.mouse.button_data   = input->mouse.data;
+        }
+        if (flags & MOUSEEVENTF_HWHEEL)
+        {
+            msg_data->rawinput.mouse.button_flags |= RI_MOUSE_HORIZONTAL_WHEEL;
+            msg_data->rawinput.mouse.button_data   = input->mouse.data;
+        }
+        if (flags & MOUSEEVENTF_XDOWN)
+        {
+            if (input->mouse.data == XBUTTON1)
+                msg_data->rawinput.mouse.button_flags |= RI_MOUSE_BUTTON_4_DOWN;
+            else if (input->mouse.data == XBUTTON2)
+                msg_data->rawinput.mouse.button_flags |= RI_MOUSE_BUTTON_5_DOWN;
+        }
+        if (flags & MOUSEEVENTF_XUP)
+        {
+            if (input->mouse.data == XBUTTON1)
+                msg_data->rawinput.mouse.button_flags |= RI_MOUSE_BUTTON_4_UP;
+            else if (input->mouse.data == XBUTTON2)
+                msg_data->rawinput.mouse.button_flags |= RI_MOUSE_BUTTON_5_UP;
+        }
 
         queue_hardware_message( desktop, msg, 0 );
     }
 
+    if (device && device->flags & RIDEV_NOLEGACY)
+        return FALSE;
+
     for (i = 0; i < ARRAY_SIZE( messages ); i++)
     {
         if (!messages[i]) continue;
@@ -1793,6 +1844,9 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
         msg_data->rawinput.kbd.scan    = input->kbd.scan;
 
         queue_hardware_message( desktop, msg, 0 );
+
+        if (device->flags & RIDEV_NOLEGACY)
+            return FALSE;
     }
 
     if (!(msg = alloc_hardware_message( input->kbd.info, source, time ))) return 0;
@@ -2370,6 +2424,55 @@ DECL_HANDLER(send_hardware_message)
     release_object( desktop );
 }
 
+/* send a hardware rawinput message to the queue thread */
+DECL_HANDLER(send_rawinput_message)
+{
+    const struct rawinput_device *device;
+    struct hardware_msg_data *msg_data;
+    struct message *msg;
+    struct desktop *desktop;
+    struct hw_msg_source source = { IMDT_MOUSE, IMO_HARDWARE };
+
+    desktop = get_thread_desktop( current, 0 );
+
+    switch (req->input.type)
+    {
+    case RIM_TYPEMOUSE:
+        emulate_raw_mouse = 0;
+        if ((device = current->process->rawinput_mouse))
+        {
+            struct thread *thread = device->target ? get_window_thread( device->target ) : NULL;
+            if ((current->queue->input != desktop->foreground_input) || (thread && thread != current))
+                goto done;
+
+            if (!(msg = alloc_hardware_message( 0, source, 0 ))) goto done;
+            msg_data = msg->data;
+
+            msg->win       = device->target;
+            msg->msg       = WM_INPUT;
+            msg->wparam    = RIM_INPUT;
+            msg->lparam    = 0;
+
+            msg_data->flags               = 0;
+            msg_data->rawinput.type       = RIM_TYPEMOUSE;
+            msg_data->rawinput.mouse.x    = req->input.mouse.x;
+            msg_data->rawinput.mouse.y    = req->input.mouse.y;
+            msg_data->rawinput.mouse.button_flags = req->input.mouse.button_flags;
+            msg_data->rawinput.mouse.button_data = req->input.mouse.button_data;
+
+            queue_hardware_message( desktop, msg, 0 );
+
+            done:
+            if (thread) release_object( thread );
+        }
+        break;
+    default:
+        set_error( STATUS_INVALID_PARAMETER );
+    }
+
+    release_object(desktop);
+}
+
 /* post a quit message to the current queue */
 DECL_HANDLER(post_quit_message)
 {
diff --git a/server/trace.c b/server/trace.c
index 0df649ea29..d849d89772 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -405,6 +405,27 @@ static void dump_hw_input( const char *prefix, const hw_input_t *input )
     }
 }
 
+static void dump_hw_rawinput( const char *prefix, const hw_rawinput_t *rawinput )
+{
+    switch (rawinput->type)
+    {
+    case RIM_TYPEMOUSE:
+        fprintf( stderr, "%s{type=MOUSE,x=%d,y=%d,button_flags=%04hx,button_data=%04hx}",
+                 prefix, rawinput->mouse.x, rawinput->mouse.y, rawinput->mouse.button_flags,
+                 rawinput->mouse.button_data);
+        break;
+    case RIM_TYPEKEYBOARD:
+        fprintf( stderr, "%s{type=KEYBOARD}\n", prefix);
+        break;
+    case RIM_TYPEHID:
+        fprintf( stderr, "%s{type=HID}\n", prefix);
+        break;
+    default:
+        fprintf( stderr, "%s{type=%04x}", prefix, rawinput->type);
+        break;
+    }
+}
+
 static void dump_luid( const char *prefix, const luid_t *luid )
 {
     fprintf( stderr, "%s%d.%u", prefix, luid->high_part, luid->low_part );
diff --git a/tools/make_requests b/tools/make_requests
index faeabe5852..8b1f1a263b 100755
--- a/tools/make_requests
+++ b/tools/make_requests
@@ -53,6 +53,7 @@ my %formats =
     "ioctl_code_t"  => [  4,   4,  "&dump_ioctl_code" ],
     "client_cpu_t"  => [  4,   4,  "&dump_client_cpu" ],
     "hw_input_t"    => [  32,  8,  "&dump_hw_input" ],
+    "hw_rawinput_t" => [  16,  8,  "&dump_hw_rawinput" ]
 );
 
 my @requests = ();
diff --git a/dlls/user32/rawinput.c b/dlls/user32/rawinput.c
index 58480b8ae7e..c231e2059cb 100644
--- a/dlls/user32/rawinput.c
+++ b/dlls/user32/rawinput.c
@@ -271,7 +271,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH RegisterRawInputDevices(RAWINPUTDEVICE *devices, U
         TRACE("device %u: page %#x, usage %#x, flags %#x, target %p.\n",
                 i, devices[i].usUsagePage, devices[i].usUsage,
                 devices[i].dwFlags, devices[i].hwndTarget);
-        if (devices[i].dwFlags & ~(RIDEV_REMOVE|RIDEV_NOLEGACY))
+        if (devices[i].dwFlags & ~(RIDEV_REMOVE|RIDEV_NOLEGACY|RIDEV_INPUTSINK))
             FIXME("Unhandled flags %#x for device %u.\n", devices[i].dwFlags, i);
 
         d[i].usage_page = devices[i].usUsagePage;
diff --git a/server/queue.c b/server/queue.c
index 70b4f883022..811bc715816 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -2442,7 +2442,9 @@ DECL_HANDLER(send_rawinput_message)
         if ((device = current->process->rawinput_mouse))
         {
             struct thread *thread = device->target ? get_window_thread( device->target ) : NULL;
-            if ((current->queue->input != desktop->foreground_input) || (thread && thread != current))
+            if ((current->queue->input != desktop->foreground_input && !(device->flags & RIDEV_INPUTSINK))
+             || (thread && thread != current)
+             || (!thread && device->flags & RIDEV_INPUTSINK))
                 goto done;
 
             if (!(msg = alloc_hardware_message( 0, source, 0 ))) goto done;
