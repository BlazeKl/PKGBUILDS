diff --git a/dlls/api-ms-win-core-path-l1-1-0/api-ms-win-core-path-l1-1-0.spec b/dlls/api-ms-win-core-path-l1-1-0/api-ms-win-core-path-l1-1-0.spec
index 61eb22031e..4f375e0c30 100644
--- a/dlls/api-ms-win-core-path-l1-1-0/api-ms-win-core-path-l1-1-0.spec
+++ b/dlls/api-ms-win-core-path-l1-1-0/api-ms-win-core-path-l1-1-0.spec
@@ -1,20 +1,20 @@
-@ stub PathAllocCanonicalize
-@ stub PathAllocCombine
+@ stdcall PathAllocCanonicalize(wstr long ptr) kernelbase.PathAllocCanonicalize
+@ stdcall PathAllocCombine(wstr wstr long ptr) kernelbase.PathAllocCombine
 @ stdcall PathCchAddBackslash(wstr long) kernelbase.PathCchAddBackslash
 @ stdcall PathCchAddBackslashEx(wstr long ptr ptr) kernelbase.PathCchAddBackslashEx
 @ stdcall PathCchAddExtension(wstr long wstr) kernelbase.PathCchAddExtension
-@ stub PathCchAppend
-@ stub PathCchAppendEx
-@ stub PathCchCanonicalize
-@ stub PathCchCanonicalizeEx
-@ stub PathCchCombine
-@ stub PathCchCombineEx
+@ stdcall PathCchAppend(wstr long wstr) kernelbase.PathCchAppend
+@ stdcall PathCchAppendEx(wstr long wstr long) kernelbase.PathCchAppendEx
+@ stdcall PathCchCanonicalize(ptr long wstr) kernelbase.PathCchCanonicalize
+@ stdcall PathCchCanonicalizeEx(ptr long wstr long) kernelbase.PathCchCanonicalizeEx
+@ stdcall PathCchCombine(ptr long wstr wstr) kernelbase.PathCchCombine
+@ stdcall PathCchCombineEx(ptr long wstr wstr long) kernelbase.PathCchCombineEx
 @ stdcall PathCchFindExtension(wstr long ptr) kernelbase.PathCchFindExtension
 @ stdcall PathCchIsRoot(wstr) kernelbase.PathCchIsRoot
-@ stub PathCchRemoveBackslash
-@ stub PathCchRemoveBackslashEx
+@ stdcall PathCchRemoveBackslash(wstr long) kernelbase.PathCchRemoveBackslash
+@ stdcall PathCchRemoveBackslashEx(wstr long ptr ptr) kernelbase.PathCchRemoveBackslashEx
 @ stdcall PathCchRemoveExtension(wstr long) kernelbase.PathCchRemoveExtension
-@ stub PathCchRemoveFileSpec
+@ stdcall PathCchRemoveFileSpec(wstr long) kernelbase.PathCchRemoveFileSpec
 @ stdcall PathCchRenameExtension(wstr long wstr) kernelbase.PathCchRenameExtension
 @ stdcall PathCchSkipRoot(wstr ptr) kernelbase.PathCchSkipRoot
 @ stdcall PathCchStripPrefix(wstr long) kernelbase.PathCchStripPrefix
diff --git a/dlls/kernelbase/kernelbase.spec b/dlls/kernelbase/kernelbase.spec
index ffb5a95721..d1bff9fec5 100644
--- a/dlls/kernelbase/kernelbase.spec
+++ b/dlls/kernelbase/kernelbase.spec
@@ -1023,8 +1023,8 @@
 @ stdcall PathAddBackslashW(wstr) shlwapi.PathAddBackslashW
 @ stdcall PathAddExtensionA(str str) shlwapi.PathAddExtensionA
 @ stdcall PathAddExtensionW(wstr wstr) shlwapi.PathAddExtensionW
-# @ stub PathAllocCanonicalize
-# @ stub PathAllocCombine
+@ stdcall PathAllocCanonicalize(wstr long ptr)
+@ stdcall PathAllocCombine(wstr wstr long ptr)
 @ stdcall PathAppendA(str str) shlwapi.PathAppendA
 @ stdcall PathAppendW(wstr wstr) shlwapi.PathAppendW
 @ stdcall PathCanonicalizeA(ptr str) shlwapi.PathCanonicalizeA
@@ -1032,18 +1032,18 @@
 @ stdcall PathCchAddBackslash(wstr long)
 @ stdcall PathCchAddBackslashEx(wstr long ptr ptr)
 @ stdcall PathCchAddExtension(wstr long wstr)
-# @ stub PathCchAppend
-# @ stub PathCchAppendEx
-# @ stub PathCchCanonicalize
-# @ stub PathCchCanonicalizeEx
-# @ stub PathCchCombine
-# @ stub PathCchCombineEx
+@ stdcall PathCchAppend(wstr long wstr)
+@ stdcall PathCchAppendEx(wstr long wstr long)
+@ stdcall PathCchCanonicalize(ptr long wstr)
+@ stdcall PathCchCanonicalizeEx(ptr long wstr long)
+@ stdcall PathCchCombine(ptr long wstr wstr)
+@ stdcall PathCchCombineEx(ptr long wstr wstr long)
 @ stdcall PathCchFindExtension(wstr long ptr)
 @ stdcall PathCchIsRoot(wstr)
-# @ stub PathCchRemoveBackslash
-# @ stub PathCchRemoveBackslashEx
+@ stdcall PathCchRemoveBackslash(wstr long)
+@ stdcall PathCchRemoveBackslashEx(wstr long ptr ptr)
 @ stdcall PathCchRemoveExtension(wstr long)
-# @ stub PathCchRemoveFileSpec
+@ stdcall PathCchRemoveFileSpec(wstr long)
 @ stdcall PathCchRenameExtension(wstr long wstr)
 @ stdcall PathCchSkipRoot(wstr ptr)
 @ stdcall PathCchStripPrefix(wstr long)
diff --git a/dlls/kernelbase/path.c b/dlls/kernelbase/path.c
index ff8e0dddd1..a1deb18551 100644
--- a/dlls/kernelbase/path.c
+++ b/dlls/kernelbase/path.c
@@ -128,6 +128,251 @@ static const WCHAR *get_root_end(const WCHAR *path)
         return NULL;
 }
 
+HRESULT WINAPI PathAllocCanonicalize(const WCHAR *path_in, DWORD flags, WCHAR **path_out)
+{
+    WCHAR *buffer, *dst;
+    const WCHAR *src;
+    const WCHAR *root_end;
+    SIZE_T buffer_size, length;
+
+    TRACE("%s %#x %p\n", debugstr_w(path_in), flags, path_out);
+
+    if (!path_in || !path_out
+        || ((flags & PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS) && (flags & PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS))
+        || (flags & (PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS | PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS)
+            && !(flags & PATHCCH_ALLOW_LONG_PATHS))
+        || ((flags & PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH) && (flags & PATHCCH_ALLOW_LONG_PATHS)))
+    {
+        if (path_out) *path_out = NULL;
+        return E_INVALIDARG;
+    }
+
+    length = strlenW(path_in);
+    if ((length + 1 > MAX_PATH && !(flags & (PATHCCH_ALLOW_LONG_PATHS | PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH)))
+        || (length + 1 > PATHCCH_MAX_CCH))
+    {
+        *path_out = NULL;
+        return HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
+    }
+
+    /* PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH implies PATHCCH_DO_NOT_NORMALIZE_SEGMENTS */
+    if (flags & PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH) flags |= PATHCCH_DO_NOT_NORMALIZE_SEGMENTS;
+
+    /* path length + possible \\?\ addition + possible \ addition + NUL */
+    buffer_size = (length + 6) * sizeof(WCHAR);
+    buffer = LocalAlloc(LMEM_ZEROINIT, buffer_size);
+    if (!buffer)
+    {
+        *path_out = NULL;
+        return E_OUTOFMEMORY;
+    }
+
+    src = path_in;
+    dst = buffer;
+
+    root_end = get_root_end(path_in);
+    if (root_end) root_end = buffer + (root_end - path_in);
+
+    /* Copy path root */
+    if (root_end)
+    {
+        memcpy(dst, src, (root_end - buffer + 1) * sizeof(WCHAR));
+        src += root_end - buffer + 1;
+        if(PathCchStripPrefix(dst, length + 6) == S_OK)
+        {
+            /* Fill in \ in X:\ if the \ is missing */
+            if(isalphaW(dst[0]) && dst[1] == ':' && dst[2]!= '\\')
+            {
+                dst[2] = '\\';
+                dst[3] = 0;
+            }
+            dst = buffer + strlenW(buffer);
+            root_end = dst;
+        }
+        else
+            dst += root_end - buffer + 1;
+    }
+
+    while (*src)
+    {
+        if (src[0] == '.')
+        {
+            if (src[1] == '.')
+            {
+                /* Keep one . after * */
+                if (dst > buffer && dst[-1] == '*')
+                {
+                    *dst++ = *src++;
+                    continue;
+                }
+
+                /* Keep the . if one of the following is true:
+                 * 1. PATHCCH_DO_NOT_NORMALIZE_SEGMENTS
+                 * 2. in form of a..b,
+                 */
+                if (dst > buffer
+                    && (((flags & PATHCCH_DO_NOT_NORMALIZE_SEGMENTS) && dst[-1] != '\\')
+                        || (dst[-1] != '\\' && src[2] != '\\' && src[2])))
+                {
+                    *dst++ = *src++;
+                    *dst++ = *src++;
+                    continue;
+                }
+
+                /* Remove the \ before .. if the \ is not part of root */
+                if (dst > buffer && dst[-1] == '\\' && (!root_end || dst - 1 > root_end))
+                {
+                    *--dst = '\0';
+                    /* Remove characters until a \ is encountered */
+                    while (dst > buffer)
+                    {
+                        if (dst[-1] == '\\')
+                        {
+                            *--dst = 0;
+                            break;
+                        }
+                        else
+                            *--dst = 0;
+                    }
+                }
+                /* Remove the extra \ after .. if the \ before .. wasn't deleted */
+                else if (src[2] == '\\')
+                    src++;
+
+                src += 2;
+            }
+            else
+            {
+                /* Keep the . if one of the following is true:
+                 * 1. PATHCCH_DO_NOT_NORMALIZE_SEGMENTS
+                 * 2. in form of a.b, which is used in domain names
+                 * 3. *.
+                 */
+                if (dst > buffer
+                    && ((flags & PATHCCH_DO_NOT_NORMALIZE_SEGMENTS && dst[-1] != '\\')
+                        || (dst[-1] != '\\' && src[1] != '\\' && src[1]) || (dst[-1] == '*')))
+                {
+                    *dst++ = *src++;
+                    continue;
+                }
+
+                /* Remove the \ before . if the \ is not part of root */
+                if (dst > buffer && dst[-1] == '\\' && (!root_end || dst - 1 > root_end)) dst--;
+                /* Remove the extra \ after . if the \ before . wasn't deleted */
+                else if (src[1] == '\\')
+                    src++;
+
+                src++;
+            }
+
+            /* If X:\ is not complete, then complete it */
+            if (isalphaW(buffer[0]) && buffer[1] == ':' && buffer[2] != '\\')
+            {
+                root_end = buffer + 2;
+                dst = buffer + 3;
+                buffer[2] = '\\';
+                /* If next character is \, use the \ to fill in */
+                if (src[0] == '\\') src++;
+            }
+        }
+        /* Copy over */
+        else
+            *dst++ = *src++;
+    }
+    /* End the path */
+    *dst = 0;
+
+    /* If result path is empty, fill in \ */
+    if (!*buffer)
+    {
+        buffer[0] = '\\';
+        buffer[1] = 0;
+    }
+
+    /* Extend the path if needed */
+    length = strlenW(buffer);
+    if (((length + 1 > MAX_PATH && isalphaW(buffer[0]) && buffer[1] == ':')
+         || (isalphaW(buffer[0]) && buffer[1] == ':' && flags & PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH))
+        && !(flags & PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS))
+    {
+        memmove(buffer + 4, buffer, (length + 1) * sizeof(WCHAR));
+        buffer[0] = '\\';
+        buffer[1] = '\\';
+        buffer[2] = '?';
+        buffer[3] = '\\';
+    }
+
+    /* Add a trailing backslash to the path if needed */
+    if (flags & PATHCCH_ENSURE_TRAILING_SLASH)
+        PathCchAddBackslash(buffer, buffer_size);
+
+    *path_out = buffer;
+    return S_OK;
+}
+
+HRESULT WINAPI PathAllocCombine(const WCHAR *path1, const WCHAR *path2, DWORD flags, WCHAR **out)
+{
+    SIZE_T length1, size2;
+    WCHAR *new_path1;
+    BOOL from_path2 = FALSE;
+    HRESULT hr;
+
+    TRACE("%s %s %#x %p\n", wine_dbgstr_w(path1), wine_dbgstr_w(path2), flags, out);
+
+    if ((!path1 && !path2) || !out)
+    {
+        if (out) *out = NULL;
+        return E_INVALIDARG;
+    }
+
+    if (!path1 || !path2)
+    {
+        hr = PathAllocCanonicalize(path1 ? path1 : path2, flags, out);
+        return FAILED(hr) ? hr : S_OK;
+    }
+
+    /* If path2 is fully qualified, use path2 only */
+    if (path2 && ((isalphaW(path2[0]) && path2[1] == ':') || (path2[0] == '\\' && path2[1] == '\\')))
+    {
+        path1 = path2;
+        path2 = NULL;
+        from_path2 = TRUE;
+    }
+
+    size2 = path2 ? strlenW(path2) : 0;
+    /* path1 length + path2 length + possible backslash + NULL */
+    length1 = strlenW(path1) + size2 + 2;
+
+    new_path1 = HeapAlloc(GetProcessHeap(), 0, length1 * sizeof(WCHAR));
+    if(!new_path1)
+    {
+        *out = NULL;
+        return E_OUTOFMEMORY;
+    }
+
+    lstrcpyW(new_path1, path1);
+    PathCchStripPrefix(new_path1, length1);
+    if (from_path2) PathCchAddBackslashEx(new_path1, length1, NULL, NULL);
+
+    if (path2 && path2[0])
+    {
+        PathCchAddBackslashEx(new_path1, length1, NULL, NULL);
+
+        if (path2[0] == '\\' && path2[1] != '\\')
+        {
+            PathCchStripToRoot(new_path1, length1);
+            PathCchAddBackslashEx(new_path1, length1, NULL, NULL);
+            lstrcatW(new_path1, path2 + 1);
+        }
+        else
+            lstrcatW(new_path1, path2);
+    }
+
+    hr = PathAllocCanonicalize(new_path1, flags, out);
+    HeapFree(GetProcessHeap(), 0, new_path1);
+    return FAILED(hr) ? hr : S_OK;
+}
+
 HRESULT WINAPI PathCchAddBackslash(WCHAR *path, SIZE_T size)
 {
     return PathCchAddBackslashEx(path, size, NULL, NULL);
@@ -209,6 +454,127 @@ HRESULT WINAPI PathCchAddExtension(WCHAR *path, SIZE_T size, const WCHAR *extens
     return S_OK;
 }
 
+HRESULT WINAPI PathCchAppend(WCHAR *path1, SIZE_T size, const WCHAR *path2)
+{
+    TRACE("%s %lu %s\n", wine_dbgstr_w(path1), size, wine_dbgstr_w(path2));
+
+    return PathCchAppendEx(path1, size, path2, PATHCCH_NONE);
+}
+
+HRESULT WINAPI PathCchAppendEx(WCHAR *path1, SIZE_T size, const WCHAR *path2, DWORD flags)
+{
+    HRESULT hr;
+    WCHAR *result;
+
+    TRACE("%s %lu %s %#x\n", wine_dbgstr_w(path1), size, wine_dbgstr_w(path2), flags);
+
+    if (!path1 || !size) return E_INVALIDARG;
+
+    /* Create a temporary buffer for result because we need to keep path1 unchanged if error occurs.
+     * And PathCchCombineEx writes empty result if there is error so we can't just use path1 as output
+     * buffer for PathCchCombineEx */
+    result = HeapAlloc(GetProcessHeap(), 0, size * sizeof(WCHAR));
+    if (!result) return E_OUTOFMEMORY;
+
+    /* Avoid the single backslash behavior with PathCchCombineEx when appending */
+    if (path2 && path2[0] == '\\' && path2[1] != '\\') path2++;
+
+    hr = PathCchCombineEx(result, size, path1, path2, flags);
+    if (SUCCEEDED(hr)) memcpy(path1, result, size * sizeof(WCHAR));
+
+    HeapFree(GetProcessHeap(), 0, result);
+    return FAILED(hr) ? hr : S_OK;
+}
+
+HRESULT WINAPI PathCchCanonicalize(WCHAR *out, SIZE_T size, const WCHAR *in)
+{
+    TRACE("%p %lu %s\n", out, size, wine_dbgstr_w(in));
+
+    /* Not X:\ and path > MAX_PATH - 4, return HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE) */
+    if (strlenW(in) > MAX_PATH - 4 && !(isalphaW(in[0]) && in[1] == ':' && in[2] == '\\'))
+        return HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
+
+    return PathCchCanonicalizeEx(out, size, in, PATHCCH_NONE);
+}
+
+HRESULT WINAPI PathCchCanonicalizeEx(WCHAR *out, SIZE_T size, const WCHAR *in, DWORD flags)
+{
+    WCHAR *buffer;
+    SIZE_T length;
+    HRESULT hr;
+
+    TRACE("%p %lu %s %#x\n", out, size, wine_dbgstr_w(in), flags);
+
+    if (!size) return E_INVALIDARG;
+
+    hr = PathAllocCanonicalize(in, flags, &buffer);
+    if (FAILED(hr)) return hr;
+
+    length = strlenW(buffer);
+    if (size < length + 1)
+    {
+        /* No root and path > MAX_PATH - 4, return HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE) */
+        if (length > MAX_PATH - 4 && !(in[0] == '\\' || (isalphaW(in[0]) && in[1] == ':' && in[2] == '\\')))
+            hr = HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
+        else
+            hr = STRSAFE_E_INSUFFICIENT_BUFFER;
+    }
+
+    if (SUCCEEDED(hr))
+    {
+        memcpy(out, buffer, (length + 1) * sizeof(WCHAR));
+
+        /* Fill a backslash at the end of X: */
+        if (isalphaW(out[0]) && out[1] == ':' && !out[2] && size > 3)
+        {
+            out[2] = '\\';
+            out[3] = 0;
+        }
+    }
+
+    LocalFree(buffer);
+    return hr;
+}
+
+HRESULT WINAPI PathCchCombine(WCHAR *out, SIZE_T size, const WCHAR *path1, const WCHAR *path2)
+{
+    TRACE("%p %s %s\n", out, wine_dbgstr_w(path1), wine_dbgstr_w(path2));
+
+    return PathCchCombineEx(out, size, path1, path2, PATHCCH_NONE);
+}
+
+HRESULT WINAPI PathCchCombineEx(WCHAR *out, SIZE_T size, const WCHAR *path1, const WCHAR *path2, DWORD flags)
+{
+    HRESULT hr;
+    WCHAR *buffer;
+    SIZE_T length;
+
+    TRACE("%p %s %s %#x\n", out, wine_dbgstr_w(path1), wine_dbgstr_w(path2), flags);
+
+    if (!out || !size || size > PATHCCH_MAX_CCH) return E_INVALIDARG;
+
+    hr = PathAllocCombine(path1, path2, flags, &buffer);
+    if (FAILED(hr))
+    {
+        out[0] = 0;
+        return hr;
+    }
+
+    length = strlenW(buffer);
+    if (length + 1 > size)
+    {
+        out[0] = 0;
+        HeapFree(GetProcessHeap(), 0, buffer);
+        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
+    }
+    else
+    {
+        memcpy(out, buffer, (length + 1) * sizeof(WCHAR));
+        HeapFree(GetProcessHeap(), 0, buffer);
+        return S_OK;
+    }
+}
+
 HRESULT WINAPI PathCchFindExtension(const WCHAR *path, SIZE_T size, const WCHAR **extension)
 {
     const WCHAR *lastpoint = NULL;
@@ -280,6 +646,55 @@ BOOL WINAPI PathCchIsRoot(const WCHAR *path)
         return FALSE;
 }
 
+HRESULT WINAPI PathCchRemoveBackslash(WCHAR *path, SIZE_T path_size)
+{
+    WCHAR *path_end;
+    SIZE_T free_size;
+
+    TRACE("%s %lu\n", debugstr_w(path), path_size);
+
+    return PathCchRemoveBackslashEx(path, path_size, &path_end, &free_size);
+}
+
+HRESULT WINAPI PathCchRemoveBackslashEx(WCHAR *path, SIZE_T path_size, WCHAR **path_end, SIZE_T *free_size)
+{
+    const WCHAR *root_end;
+    SIZE_T path_length;
+
+    TRACE("%s %lu %p %p\n", debugstr_w(path), path_size, path_end, free_size);
+
+    if (!path_size || !path_end || !free_size)
+    {
+        if (path_end) *path_end = NULL;
+        if (free_size) *free_size = 0;
+        return E_INVALIDARG;
+    }
+
+    path_length = strnlenW(path, path_size);
+    if (path_length == path_size && !path[path_length]) return E_INVALIDARG;
+
+    root_end = get_root_end(path);
+    if (path_length > 0 && path[path_length - 1] == '\\')
+    {
+        *path_end = path + path_length - 1;
+        *free_size = path_size - path_length + 1;
+        /* If the last character is beyond end of root */
+        if (!root_end || path + path_length - 1 > root_end)
+        {
+            path[path_length - 1] = 0;
+            return S_OK;
+        }
+        else
+            return S_FALSE;
+    }
+    else
+    {
+        *path_end = path + path_length;
+        *free_size = path_size - path_length;
+        return S_FALSE;
+    }
+}
+
 HRESULT WINAPI PathCchRemoveExtension(WCHAR *path, SIZE_T size)
 {
     const WCHAR *extension;
@@ -299,6 +714,43 @@ HRESULT WINAPI PathCchRemoveExtension(WCHAR *path, SIZE_T size)
     return next == extension ? S_FALSE : S_OK;
 }
 
+HRESULT WINAPI PathCchRemoveFileSpec(WCHAR *path, SIZE_T size)
+{
+    const WCHAR *root_end = NULL;
+    SIZE_T length;
+    WCHAR *last;
+
+    TRACE("%s %lu\n", wine_dbgstr_w(path), size);
+
+    if (!path || !size || size > PATHCCH_MAX_CCH) return E_INVALIDARG;
+
+    if (PathCchIsRoot(path)) return S_FALSE;
+
+    PathCchSkipRoot(path, &root_end);
+
+    /* The backslash at the end of UNC and \\* are not considered part of root in this case */
+    if (root_end && root_end > path && root_end[-1] == '\\'
+        && (is_prefixed_unc(path) || (path[0] == '\\' && path[1] == '\\' && path[2] != '?')))
+        root_end--;
+
+    length = strlenW(path);
+    last = path + length - 1;
+    while (last >= path && (!root_end || last >= root_end))
+    {
+        if (last - path >= size) return E_INVALIDARG;
+
+        if (*last == '\\')
+        {
+            *last-- = 0;
+            break;
+        }
+
+        *last-- = 0;
+    }
+
+    return last != path + length - 1 ? S_OK : S_FALSE;
+}
+
 HRESULT WINAPI PathCchRenameExtension(WCHAR *path, SIZE_T size, const WCHAR *extension)
 {
     HRESULT hr;
diff --git a/dlls/kernelbase/tests/path.c b/dlls/kernelbase/tests/path.c
index 6d37bbf8ef..d7c075791b 100644
--- a/dlls/kernelbase/tests/path.c
+++ b/dlls/kernelbase/tests/path.c
@@ -30,26 +30,341 @@
 
 #include "wine/test.h"
 
+HRESULT (WINAPI *pPathAllocCanonicalize)(const WCHAR *path_in, DWORD flags, WCHAR **path_out);
+HRESULT (WINAPI *pPathAllocCombine)(const WCHAR *path1, const WCHAR *path2, DWORD flags, WCHAR **out);
 HRESULT (WINAPI *pPathCchAddBackslash)(WCHAR *out, SIZE_T size);
 HRESULT (WINAPI *pPathCchAddBackslashEx)(WCHAR *out, SIZE_T size, WCHAR **endptr, SIZE_T *remaining);
 HRESULT (WINAPI *pPathCchAddExtension)(WCHAR *path, SIZE_T size, const WCHAR *extension);
+HRESULT (WINAPI *pPathCchAppend)(WCHAR *path1, SIZE_T size, const WCHAR *path2);
+HRESULT (WINAPI *pPathCchAppendEx)(WCHAR *path1, SIZE_T size, const WCHAR *path2, DWORD flags);
+HRESULT (WINAPI *pPathCchCombine)(WCHAR *out, SIZE_T size, const WCHAR *path1, const WCHAR *path2);
+HRESULT (WINAPI *pPathCchCombineEx)(WCHAR *out, SIZE_T size, const WCHAR *path1, const WCHAR *path2, DWORD flags);
+HRESULT (WINAPI *pPathCchCanonicalize)(WCHAR *out, SIZE_T size, const WCHAR *in);
+HRESULT (WINAPI *pPathCchCanonicalizeEx)(WCHAR *out, SIZE_T size, const WCHAR *in, DWORD flags);
 HRESULT (WINAPI *pPathCchCombineEx)(WCHAR *out, SIZE_T size, const WCHAR *path1, const WCHAR *path2, DWORD flags);
 HRESULT (WINAPI *pPathCchFindExtension)(const WCHAR *path, SIZE_T size, const WCHAR **extension);
 BOOL    (WINAPI *pPathCchIsRoot)(const WCHAR *path);
+HRESULT (WINAPI *pPathCchRemoveBackslash)(WCHAR *path, SIZE_T path_size);
+HRESULT (WINAPI *pPathCchRemoveBackslashEx)(WCHAR *path, SIZE_T path_size, WCHAR **path_end, SIZE_T *free_size);
 HRESULT (WINAPI *pPathCchRemoveExtension)(WCHAR *path, SIZE_T size);
+HRESULT (WINAPI *pPathCchRemoveFileSpec)(WCHAR *path, SIZE_T size);
 HRESULT (WINAPI *pPathCchRenameExtension)(WCHAR *path, SIZE_T size, const WCHAR *extension);
 HRESULT (WINAPI *pPathCchSkipRoot)(const WCHAR *path, const WCHAR **root_end);
 HRESULT (WINAPI *pPathCchStripPrefix)(WCHAR *path, SIZE_T size);
 HRESULT (WINAPI *pPathCchStripToRoot)(WCHAR *path, SIZE_T size);
 BOOL    (WINAPI *pPathIsUNCEx)(const WCHAR *path, const WCHAR **server);
 
-static const struct
+struct alloccanonicalize_test
 {
-    const char *path1;
-    const char *path2;
-    const char *result;
+    const CHAR *path_in;
+    const CHAR *path_out;
+    DWORD flags;
+    HRESULT hr;
+};
+
+static const struct alloccanonicalize_test alloccanonicalize_tests[] =
+{
+    /* Malformed path */
+    {"C:a", "C:a", 0, S_OK},
+    {"\\\\?\\C:", "C:\\", 0, S_OK},
+    {"\\\\?C:\\a", "\\\\?C:\\a", 0, S_OK},
+    {"\\\\?UNC\\a", "\\\\?UNC\\a", 0, S_OK},
+    {"\\\\?\\UNCa", "\\\\?\\UNCa", 0, S_OK},
+    {"\\\\?C:a", "\\\\?C:a", 0, S_OK},
+
+    /* No . */
+    {"", "\\", 0, S_OK},
+    {"C:", "C:", 0, S_OK},
+    {"C:\\", "C:\\", 0, S_OK},
+    {"\\\\?\\C:\\a", "C:\\a", 0, S_OK},
+    {"\\\\?\\UNC\\a", "\\\\a", 0, S_OK},
+
+    /* . */
+    {".", "\\", 0, S_OK},
+    {"..", "\\", 0, S_OK},
+    {"...", "\\", 0, S_OK},
+    {"*.", "*.", 0, S_OK},
+    {"*..", "*.", 0, S_OK},
+    {"*...", "*.", 0, S_OK},
+    {"a.", "a", 0, S_OK},
+    {"a.b", "a.b", 0, S_OK},
+    {"a\\.", "a", 0, S_OK},
+    {"a\\.\\b", "a\\b", 0, S_OK},
+    {"C:.", "C:\\", 0, S_OK},
+    {"C:\\.", "C:\\", 0, S_OK},
+    {"C:\\.\\", "C:\\", 0, S_OK},
+    {"C:\\a.", "C:\\a", 0, S_OK},
+    {"C:\\a\\.", "C:\\a", 0, S_OK},
+    {"C:\\a\\\\.", "C:\\a\\", 0, S_OK},
+    {"C:\\a\\\\\\.", "C:\\a\\\\", 0, S_OK},
+    {"\\.", "\\", 0, S_OK},
+    {"\\\\.", "\\\\", 0, S_OK},
+    {"\\\\.\\", "\\\\", 0, S_OK},
+    {"\\\\\\.", "\\\\", 0, S_OK},
+    {"\\\\.\\\\", "\\\\\\", 0, S_OK},
+    {"\\\\\\\\.", "\\\\\\", 0, S_OK},
+    {"\\?\\.", "\\?", 0, S_OK},
+    {"\\\\?\\.", "\\\\?", 0, S_OK},
+    {"\\192.168.1.1\\a", "\\192.168.1.1\\a", 0, S_OK},
+    {"\\a.168.1.1\\a", "\\a.168.1.1\\a", 0, S_OK},
+    {"\\\\192.168.1.1\\a", "\\\\192.168.1.1\\a", 0, S_OK},
+    {"\\\\a.168.1.1\\b", "\\\\a.168.1.1\\b", 0, S_OK},
+    {"\\\\?\\C:.", "C:\\", 0, S_OK},
+    {"\\\\?\\C:\\.", "C:\\", 0, S_OK},
+    {"\\\\?\\UNC\\.", "\\\\", 0, S_OK},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\.",
+      "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\", 0, S_OK},
+
+    /* .. */
+    {"a..", "a", 0, S_OK},
+    {"a..b", "a..b", 0, S_OK},
+    {"a\\..", "\\", 0, S_OK},
+    {"a\\..\\", "\\", 0, S_OK},
+    {"a\\..\\b", "\\b", 0, S_OK},
+    {"C:..", "C:\\", 0, S_OK},
+    {"C:\\..", "C:\\", 0, S_OK},
+    {"C:\\\\..", "C:\\", 0, S_OK},
+    {"C:\\..\\", "C:\\", 0, S_OK},
+    {"C:\\a\\..", "C:\\", 0, S_OK},
+    {"C:\\a\\\\..", "C:\\a", 0, S_OK},
+    {"C:\\a\\\\\\..", "C:\\a\\", 0, S_OK},
+    {"C:\\a\\..\\b", "C:\\b", 0, S_OK},
+    {"C:\\a\\..\\\\b", "C:\\\\b", 0, S_OK},
+    {"\\..", "\\", 0, S_OK},
+    {"\\\\..", "\\\\", 0, S_OK},
+    {"\\\\\\..", "\\", 0, S_OK},
+    {"\\\\..\\", "\\\\", 0, S_OK},
+    {"\\\\\\..", "\\", 0, S_OK},
+    {"\\\\..\\\\", "\\\\\\", 0, S_OK},
+    {"\\\\\\\\..", "\\\\", 0, S_OK},
+    {"\\?\\..", "\\", 0, S_OK},
+    {"\\a\\..", "\\", 0, S_OK},
+    {"\\\\?\\..", "\\", 0, S_OK},
+    {"\\\\a\\..", "\\", 0, S_OK},
+    {"\\a\\..\\b", "\\b", 0, S_OK},
+    {"\\a\\b\\..", "\\a", 0, S_OK},
+    {"\\?\\UNC\\..", "\\?", 0, S_OK},
+    {"\\?\\C:\\..", "\\?", 0, S_OK},
+    {"\\\\?\\C:..", "C:\\", 0, S_OK},
+    {"\\\\?\\C:\\..", "C:\\", 0, S_OK},
+    {"\\\\?\\UNC\\..", "\\\\", 0, S_OK},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}..",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}", 0, S_OK},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\..",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\", 0, S_OK},
+    {"\\\\?\\UNC\\a\\b\\..", "\\\\a", 0, S_OK},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a\\b\\..",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a", 0, S_OK},
+
+    /* . and .. */
+    {"C:\\a\\.\\b\\..\\", "C:\\a\\", 0, S_OK},
+    {"\\a\\.\\b\\..\\", "\\a\\", 0, S_OK},
+    {"\\?\\a\\.\\b\\..\\", "\\?\\a\\", 0, S_OK},
+    {"\\\\.\\a\\.\\b\\..\\", "\\\\a\\", 0, S_OK},
+    {"\\\\?\\a\\.\\b\\..\\", "\\\\?\\a\\", 0, S_OK},
+    {"\\\\.\\..", "\\\\", 0, S_OK},
+
+    /* PATHCCH_ALLOW_LONG_PATHS */
+    /* Input path with prefix \\?\ and length of MAXPATH + 1, HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE) = 0x800700ce */
+    {"\\\\?\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", NULL, 0, 0x800700ce},
+    /* Input path with prefix C:\ and length of MAXPATH + 1 */
+    {"C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", NULL, 0, 0x800700ce},
+    {"C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "\\\\?\\C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", PATHCCH_ALLOW_LONG_PATHS, S_OK},
+    /* Input path with prefix C: and length of MAXPATH + 1  */
+    {"C:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "\\\\?\\C:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", PATHCCH_ALLOW_LONG_PATHS, S_OK},
+    /* Input path with prefix C:\ and length of MAXPATH + 1 and with .. */
+    {"C:\\..\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", PATHCCH_ALLOW_LONG_PATHS, S_OK},
+    /* Input path with prefix \\?\ and length of MAXPATH + 1 */
+    {"\\\\?\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "\\\\?\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", PATHCCH_ALLOW_LONG_PATHS, S_OK},
+    /* Input path with prefix \ and length of MAXPATH + 1 */
+    {"\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", PATHCCH_ALLOW_LONG_PATHS, S_OK},
+    /* Input path with length of MAXPATH with PATHCCH_ALLOW_LONG_PATHS disabled*/
+    {"C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", 0, S_OK},
+    /* Input path with length of MAXPATH */
+    {"C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", PATHCCH_ALLOW_LONG_PATHS, S_OK},
+
+    /* Flags added after Windows 10 1709 */
+    /* PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS */
+    /* PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS without PATHCCH_ALLOW_LONG_PATHS */
+    {"", NULL, PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS, E_INVALIDARG},
+    /* Input path with prefix C:\ and length of MAXPATH + 1 and PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS */
+    {"C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
+     PATHCCH_ALLOW_LONG_PATHS | PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS, S_OK},
+
+    /* PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS */
+    /* PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS without PATHCCH_ALLOW_LONG_PATHS */
+    {"", NULL, PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS, E_INVALIDARG},
+    /* Both PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS and PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS */
+    {"", "\\", PATHCCH_ALLOW_LONG_PATHS | PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS | PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS,
+     E_INVALIDARG},
+    /* Input path with prefix C:\ and length of MAXPATH + 1 and PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS */
+    {"C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "\\\\?\\C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+     "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
+     PATHCCH_ALLOW_LONG_PATHS | PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS, S_OK},
+    /* Input path with prefix C:\ and length of MAXPATH and PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS */
+    {"C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
+    PATHCCH_ALLOW_LONG_PATHS | PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS, S_OK},
+
+    /* PATHCCH_DO_NOT_NORMALIZE_SEGMENTS */
+    /* No effect for spaces */
+    {"C:\\a \\", "C:\\a \\", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"C:\\a\\ ", "C:\\a\\ ", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"C:\\a ", "C:\\a ", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"C:\\a  ", "C:\\a  ", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"C:\\a. ", "C:\\a. ", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"\\a \\", "\\a \\", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"\\a\\ ", "\\a\\ ", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"\\\\a \\", "\\\\a \\", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"\\\\a\\ ", "\\\\a\\ ", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"\\\\?\\ ", "\\\\?\\ ", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    /* Keep trailing dot */
+    {"*..", "*..", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {".", "\\", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"..", "\\", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"C:.", "C:.", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"C:..", "C:..", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"C:\\a\\.", "C:\\a", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"C:\\a\\..", "C:\\", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"C:\\a.", "C:\\a.", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+    {"C:\\a..", "C:\\a..", PATHCCH_DO_NOT_NORMALIZE_SEGMENTS, S_OK},
+
+    /* PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH */
+    {"C:\\a\\", "\\\\?\\C:\\a\\", PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH, S_OK},
+    {"", NULL, PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH | PATHCCH_ALLOW_LONG_PATHS, E_INVALIDARG},
+    {"\\a\\", "\\a\\", PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH, S_OK},
+    {"\\\\?\\C:\\a\\", "\\\\?\\C:\\a\\", PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH, S_OK},
+    /* Implication of PATHCCH_DO_NOT_NORMALIZE_SEGMENTS by PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH */
+    {"\\a.", "\\a.", PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH, S_OK},
+
+    /* PATHCCH_ENSURE_TRAILING_SLASH */
+    {"\\", "\\", PATHCCH_ENSURE_TRAILING_SLASH, S_OK},
+    {"C:\\", "C:\\", PATHCCH_ENSURE_TRAILING_SLASH, S_OK},
+    {"C:\\a\\.", "C:\\a\\", PATHCCH_ENSURE_TRAILING_SLASH, S_OK},
+    {"C:\\a", "C:\\a\\", PATHCCH_ENSURE_TRAILING_SLASH, S_OK}
+};
+
+static void test_PathAllocCanonicalize(void)
+{
+    WCHAR path_inW[1024], path_maxW[PATHCCH_MAX_CCH + 1];
+    WCHAR *path_outW;
+    CHAR path_outA[1024];
+    BOOL skip_new_flags = TRUE;
+    HRESULT hr;
+    INT i;
+
+    if (!pPathAllocCanonicalize)
+    {
+        win_skip("PathAllocCanonicalize() is not available.\n");
+        return;
+    }
+
+    /* No NULL check for path on Windows */
+    if (0)
+    {
+        hr = pPathAllocCanonicalize(NULL, 0, &path_outW);
+        ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+    }
+
+    MultiByteToWideChar(CP_ACP, 0, "C:\\", -1, path_inW, ARRAY_SIZE(path_inW));
+    hr = pPathAllocCanonicalize(path_inW, 0, NULL);
+    ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+
+    /* Test longest path */
+    for (i = 0; i < ARRAY_SIZE(path_maxW) - 1; i++) path_maxW[i] = 'a';
+    path_maxW[PATHCCH_MAX_CCH] = '\0';
+    path_outW = (WCHAR *)0xdeadbeef;
+    hr = pPathAllocCanonicalize(path_maxW, PATHCCH_ALLOW_LONG_PATHS, &path_outW);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE), "expect hr %#x, got %#x\n",
+       HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE), hr);
+    ok(path_outW == NULL, "expect path_outW null, got %p\n", path_outW);
+
+    path_maxW[PATHCCH_MAX_CCH - 1] = '\0';
+    hr = pPathAllocCanonicalize(path_maxW, PATHCCH_ALLOW_LONG_PATHS, &path_outW);
+    ok(hr == S_OK, "expect hr %#x, got %#x\n", S_OK, hr);
+
+    /* Check if flags added after Windows 10 1709 are supported */
+    MultiByteToWideChar(CP_ACP, 0, "C:\\", -1, path_inW, ARRAY_SIZE(path_inW));
+    hr = pPathAllocCanonicalize(path_inW, PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS, &path_outW);
+    if (hr == E_INVALIDARG) skip_new_flags = FALSE;
+
+    for (i = 0; i < ARRAY_SIZE(alloccanonicalize_tests); i++)
+    {
+        const struct alloccanonicalize_test *t = alloccanonicalize_tests + i;
+
+        if (((PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS | PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS
+              | PATHCCH_DO_NOT_NORMALIZE_SEGMENTS | PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH
+              | PATHCCH_ENSURE_TRAILING_SLASH)
+             & t->flags)
+            && skip_new_flags)
+        {
+            win_skip("Skip testing new flags added after Windows 10 1709\n");
+            return;
+        }
+
+        MultiByteToWideChar(CP_ACP, 0, t->path_in, -1, path_inW, ARRAY_SIZE(path_inW));
+        hr = pPathAllocCanonicalize(path_inW, t->flags, &path_outW);
+        ok(hr == t->hr, "path %s expect result %#x, got %#x\n", t->path_in, t->hr, hr);
+        if (SUCCEEDED(hr))
+        {
+            WideCharToMultiByte(CP_ACP, 0, path_outW, -1, path_outA, ARRAY_SIZE(path_outA), NULL, NULL);
+            ok(!lstrcmpA(path_outA, t->path_out), "path \"%s\" expect output path \"%s\", got \"%s\"\n", t->path_in,
+               t->path_out, path_outA);
+            LocalFree(path_outW);
+        }
+    }
 }
-combine_test[] =
+
+struct combine_test
+{
+    const CHAR *path1;
+    const CHAR *path2;
+    const CHAR *result;
+};
+
+static const struct combine_test combine_tests[] =
 {
     /* normal paths */
     {"C:\\",  "a",     "C:\\a" },
@@ -57,38 +372,197 @@ combine_test[] =
     {"C:",    "a",     "C:\\a" },
     {"C:\\",  ".",     "C:\\" },
     {"C:\\",  "..",    "C:\\" },
-    {"\\a",   "b",      "\\a\\b" },
+    {"C:\\a",  "",     "C:\\a" },
 
     /* normal UNC paths */
     {"\\\\192.168.1.1\\test", "a",  "\\\\192.168.1.1\\test\\a" },
     {"\\\\192.168.1.1\\test", "..", "\\\\192.168.1.1" },
+    {"\\a",   "b",      "\\a\\b" },
+    {"\\", "a", "\\a"},
+    {"\\\\", "a", "\\\\a"},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\", "a",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a"},
 
     /* NT paths */
     {"\\\\?\\C:\\", "a",  "C:\\a" },
     {"\\\\?\\C:\\", "..", "C:\\" },
+    {"\\\\?\\C:", "a", "C:\\a"},
 
     /* NT UNC path */
+    {"\\\\?\\UNC\\", "a", "\\\\a"},
     {"\\\\?\\UNC\\192.168.1.1\\test", "a",  "\\\\192.168.1.1\\test\\a" },
     {"\\\\?\\UNC\\192.168.1.1\\test", "..", "\\\\192.168.1.1" },
+
+    /* Second path begins with a single backslash */
+    {"C:a\\b", "\\1", "C:\\1"},
+    {"C:\\a\\b", "\\1", "C:\\1"},
+    {"\\a\\b", "\\1", "\\1"},
+    {"\\\\a\\b", "\\1", "\\\\a\\b\\1"},
+    {"\\\\a\\b\\c", "\\1", "\\\\a\\b\\1"},
+    {"\\\\?\\UNC\\a", "\\1", "\\\\a\\1"},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}a", "\\1",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\1"},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a", "\\1",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\1"},
+    {"C:\\a\\b", "\\", "C:\\"},
+
+    /* Second path is fully qualified */
+    {"X:\\", "C:", "C:\\"},
+    {"X:\\", "C:\\", "C:\\"},
+    {"X:\\", "\\\\", "\\\\"},
+    {"X:\\", "\\\\?\\C:", "C:\\"},
+    {"X:\\", "\\\\?\\C:\\", "C:\\"},
+    {"X:\\", "\\\\?\\UNC\\", "\\\\"},
+    {"X:\\", "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\"},
+
+    /* Canonicalization */
+    {"C:\\a", ".\\b", "C:\\a\\b"},
+    {"C:\\a", "..\\b", "C:\\b"},
+
+    /* Other */
+    {"", "", "\\"},
+    {"a", "b", "a\\b"}
 };
 
+static void test_PathAllocCombine(void)
+{
+    WCHAR path1W[PATHCCH_MAX_CCH];
+    WCHAR path2W[PATHCCH_MAX_CCH];
+    WCHAR *resultW;
+    CHAR resultA[PATHCCH_MAX_CCH];
+    HRESULT hr;
+    INT i;
+
+    if (!pPathAllocCombine)
+    {
+        win_skip("PathAllocCombine() is not available.\n");
+        return;
+    }
+
+    resultW = (WCHAR *)0xdeadbeef;
+    hr = pPathAllocCombine(NULL, NULL, 0, &resultW);
+    ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+    ok(resultW == NULL, "expect resultW null, got %p\n", resultW);
+
+    MultiByteToWideChar(CP_ACP, 0, "\\a", -1, path1W, ARRAY_SIZE(path1W));
+    hr = pPathAllocCombine(path1W, NULL, 0, &resultW);
+    ok(hr == S_OK, "expect hr %#x, got %#x\n", S_OK, hr);
+    WideCharToMultiByte(CP_ACP, 0, resultW, -1, resultA, ARRAY_SIZE(resultA), NULL, NULL);
+    ok(!lstrcmpA(resultA, "\\a"), "expect \\a, got %s\n", resultA);
+
+    MultiByteToWideChar(CP_ACP, 0, "\\b", -1, path2W, ARRAY_SIZE(path2W));
+    hr = pPathAllocCombine(NULL, path2W, 0, &resultW);
+    ok(hr == S_OK, "expect hr %#x, got %#x\n", S_OK, hr);
+    WideCharToMultiByte(CP_ACP, 0, resultW, -1, resultA, ARRAY_SIZE(resultA), NULL, NULL);
+    ok(!lstrcmpA(resultA, "\\b"), "expect \\b, got %s\n", resultA);
+
+    hr = pPathAllocCombine(path1W, path2W, 0, NULL);
+    ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+
+    for (i = 0; i < ARRAY_SIZE(combine_tests); i++)
+    {
+        const struct combine_test *t = combine_tests + i;
+
+        MultiByteToWideChar(CP_ACP, 0, t->path1, -1, path1W, ARRAY_SIZE(path1W));
+        MultiByteToWideChar(CP_ACP, 0, t->path2, -1, path2W, ARRAY_SIZE(path2W));
+        hr = pPathAllocCombine(path1W, path2W, 0, &resultW);
+        ok(hr == S_OK, "combine \"%s\" \"%s\" expect hr %#x, got %#x\n", t->path1, t->path2, S_OK, hr);
+        if (SUCCEEDED(hr))
+        {
+            WideCharToMultiByte(CP_ACP, 0, resultW, -1, resultA, ARRAY_SIZE(resultA), NULL, NULL);
+            ok(!lstrcmpA(resultA, t->result), "combine \"%s\" \"%s\" expect result \"%s\", got \"%s\"\n", t->path1,
+               t->path2, t->result, resultA);
+            LocalFree(resultW);
+        }
+    }
+}
+
+static void test_PathCchCombine(void)
+{
+    WCHAR expected[PATHCCH_MAX_CCH] = {'C', ':', '\\', 'a', 0};
+    WCHAR p1[PATHCCH_MAX_CCH] = {'C', ':', '\\', 0};
+    WCHAR p2[PATHCCH_MAX_CCH] = {'a', 0};
+    WCHAR output[PATHCCH_MAX_CCH];
+    HRESULT hr;
+    INT i;
+
+    if (!pPathCchCombine)
+    {
+        win_skip("PathCchCombine() is not available.\n");
+        return;
+    }
+
+    hr = pPathCchCombine(output, 5, NULL, NULL);
+    ok(hr == E_INVALIDARG, "Expected E_INVALIDARG, got %08x\n", hr);
+
+    hr = pPathCchCombine(NULL, 2, p1, p2);
+    ok(hr == E_INVALIDARG, "Expected E_INVALIDARG, got %08x\n", hr);
+
+    memset(output, 0xff, sizeof(output));
+    hr = pPathCchCombine(output, 0, p1, p2);
+    ok(hr == E_INVALIDARG, "Expected E_INVALIDARG, got %08x\n", hr);
+    ok(output[0] == 0xffff, "Expected output buffer to be unchanged\n");
+
+    memset(output, 0xff, sizeof(output));
+    hr = pPathCchCombine(output, 1, p1, p2);
+    ok(hr == STRSAFE_E_INSUFFICIENT_BUFFER, "Expected STRSAFE_E_INSUFFICIENT_BUFFER, got %08x\n", hr);
+    ok(output[0] == 0, "Expected output buffer to contain NULL string\n");
+
+    memset(output, 0xff, sizeof(output));
+    hr = pPathCchCombine(output, 4, p1, p2);
+    ok(hr == STRSAFE_E_INSUFFICIENT_BUFFER, "Expected STRSAFE_E_INSUFFICIENT_BUFFER, got %08x\n", hr);
+    ok(output[0] == 0x0, "Expected output buffer to contain NULL string\n");
+
+    memset(output, 0xff, sizeof(output));
+    hr = pPathCchCombine(output, 5, p1, p2);
+    ok(hr == S_OK, "Expected S_OK, got %08x\n", hr);
+    ok(!lstrcmpW(output, expected), "Combination of %s + %s returned %s, expected %s\n", wine_dbgstr_w(p1),
+       wine_dbgstr_w(p2), wine_dbgstr_w(output), wine_dbgstr_w(expected));
+
+    hr = pPathCchCombine(output, PATHCCH_MAX_CCH + 1, p1, p2);
+    ok(hr == E_INVALIDARG, "Expected E_INVALIDARG, got %08x\n", hr);
+
+    hr = pPathCchCombine(output, PATHCCH_MAX_CCH, p1, p2);
+    ok(hr == S_OK, "Expected S_OK, got %08x\n", hr);
+
+    for (i = 0; i < ARRAY_SIZE(combine_tests); i++)
+    {
+        MultiByteToWideChar(CP_ACP, 0, combine_tests[i].path1, -1, p1, ARRAY_SIZE(p1));
+        MultiByteToWideChar(CP_ACP, 0, combine_tests[i].path2, -1, p2, ARRAY_SIZE(p2));
+        MultiByteToWideChar(CP_ACP, 0, combine_tests[i].result, -1, expected, ARRAY_SIZE(expected));
+
+        hr = pPathCchCombine(output, ARRAY_SIZE(output), p1, p2);
+        ok(hr == S_OK, "Expected S_OK, got %08x\n", hr);
+        ok(!lstrcmpW(output, expected), "Combining %s with %s returned %s, expected %s\n", wine_dbgstr_w(p1),
+           wine_dbgstr_w(p2), wine_dbgstr_w(output), wine_dbgstr_w(expected));
+    }
+}
+
 static void test_PathCchCombineEx(void)
 {
-    WCHAR expected[MAX_PATH] = {'C',':','\\','a',0};
-    WCHAR p1[MAX_PATH] = {'C',':','\\',0};
-    WCHAR p2[MAX_PATH] = {'a',0};
-    WCHAR output[MAX_PATH];
+    WCHAR expected[PATHCCH_MAX_CCH] = {'C',':','\\','a',0};
+    WCHAR p1[PATHCCH_MAX_CCH] = {'C',':','\\',0};
+    WCHAR p2[PATHCCH_MAX_CCH] = {'a',0};
+    WCHAR output[PATHCCH_MAX_CCH];
     HRESULT hr;
-    int i;
+    INT i;
 
     if (!pPathCchCombineEx)
     {
-        skip("PathCchCombineEx() is not available.\n");
+        win_skip("PathCchCombineEx() is not available.\n");
         return;
     }
 
+    output[0] = 0xff;
+    hr = pPathCchCombineEx(output, 5, NULL, NULL, 0);
+    ok(hr == E_INVALIDARG, "Expected E_INVALIDARG, got %08x\n", hr);
+    ok(output[0] == 0, "Expected output buffer to be empty\n");
+
+    output[0] = 0xff;
     hr = pPathCchCombineEx(NULL, 2, p1, p2, 0);
     ok(hr == E_INVALIDARG, "Expected E_INVALIDARG, got %08x\n", hr);
+    ok(output[0] == 0xff, "Expected output buffer to be unchanged\n");
 
     memset(output, 0xff, sizeof(output));
     hr = pPathCchCombineEx(output, 0, p1, p2, 0);
@@ -105,6 +579,14 @@ static void test_PathCchCombineEx(void)
     ok(hr == STRSAFE_E_INSUFFICIENT_BUFFER, "Expected STRSAFE_E_INSUFFICIENT_BUFFER, got %08x\n", hr);
     ok(output[0] == 0x0, "Expected output buffer to contain NULL string\n");
 
+    output[0] = 0xff;
+    hr = pPathCchCombineEx(output, PATHCCH_MAX_CCH + 1, p1, p2, 0);
+    ok(hr == E_INVALIDARG, "Expected E_INVALIDARG, got %08x\n", hr);
+    ok(output[0] == 0xff, "Expected output buffer to be 0xff\n");
+
+    hr = pPathCchCombineEx(output, PATHCCH_MAX_CCH, p1, p2, 0);
+    ok(hr == S_OK, "Expected S_OK, got %08x\n", hr);
+
     memset(output, 0xff, sizeof(output));
     hr = pPathCchCombineEx(output, 5, p1, p2, 0);
     ok(hr == S_OK, "Expected S_OK, got %08x\n", hr);
@@ -112,11 +594,11 @@ static void test_PathCchCombineEx(void)
         "Combination of %s + %s returned %s, expected %s\n",
         wine_dbgstr_w(p1), wine_dbgstr_w(p2), wine_dbgstr_w(output), wine_dbgstr_w(expected));
 
-    for (i = 0; i < ARRAY_SIZE(combine_test); i++)
+    for (i = 0; i < ARRAY_SIZE(combine_tests); i++)
     {
-        MultiByteToWideChar(CP_ACP, 0, combine_test[i].path1, -1, p1, MAX_PATH);
-        MultiByteToWideChar(CP_ACP, 0, combine_test[i].path2, -1, p2, MAX_PATH);
-        MultiByteToWideChar(CP_ACP, 0, combine_test[i].result, -1, expected, MAX_PATH);
+        MultiByteToWideChar(CP_ACP, 0, combine_tests[i].path1, -1, p1, MAX_PATH);
+        MultiByteToWideChar(CP_ACP, 0, combine_tests[i].path2, -1, p2, MAX_PATH);
+        MultiByteToWideChar(CP_ACP, 0, combine_tests[i].result, -1, expected, MAX_PATH);
 
         hr = pPathCchCombineEx(output, MAX_PATH, p1, p2, 0);
         ok(hr == S_OK, "Expected S_OK, got %08x\n", hr);
@@ -307,6 +789,173 @@ static const struct addextension_test addextension_tests[] =
     {"C:\\1.exe", " ", NULL, E_INVALIDARG}
 };
 
+struct append_test
+{
+    const CHAR *path1;
+    const CHAR *path2;
+    const CHAR *result;
+};
+
+static const struct append_test append_tests[] =
+{
+    /* normal paths */
+    {"C:\\", "a", "C:\\a"},
+    {"C:\\b", "..\\a", "C:\\a"},
+    {"C:", "a", "C:\\a"},
+    {"C:\\", ".", "C:\\"},
+    {"C:\\", "..", "C:\\"},
+    {"C:\\a", "", "C:\\a"},
+
+    /* normal UNC paths */
+    {"\\\\192.168.1.1\\test", "a", "\\\\192.168.1.1\\test\\a"},
+    {"\\\\192.168.1.1\\test", "..", "\\\\192.168.1.1"},
+    {"\\a", "b", "\\a\\b"},
+    {"\\", "a", "\\a"},
+    {"\\\\", "a", "\\\\a"},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\", "a",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a"},
+
+    /* NT paths */
+    {"\\\\?\\C:\\", "a", "C:\\a"},
+    {"\\\\?\\C:\\", "..", "C:\\"},
+    {"\\\\?\\C:", "a", "C:\\a"},
+
+    /* NT UNC path */
+    {"\\\\?\\UNC\\", "a", "\\\\a"},
+    {"\\\\?\\UNC\\192.168.1.1\\test", "a", "\\\\192.168.1.1\\test\\a"},
+    {"\\\\?\\UNC\\192.168.1.1\\test", "..", "\\\\192.168.1.1"},
+
+    /* Second path begins with a single backslash */
+    {"C:a\\b", "\\1", "C:a\\b\\1"},
+    {"C:\\a\\b", "\\1", "C:\\a\\b\\1"},
+    {"\\a\\b", "\\1", "\\a\\b\\1"},
+    {"\\\\a\\b", "\\1", "\\\\a\\b\\1"},
+    {"\\\\a\\b\\c", "\\1", "\\\\a\\b\\c\\1"},
+    {"\\\\?\\UNC\\a", "\\1", "\\\\a\\1"},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}a", "\\1",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}a\\1"},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a", "\\1",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a\\1"},
+    {"C:\\a\\b", "\\", "C:\\a\\b"},
+
+    /* Second path is fully qualified */
+    {"X:\\", "C:", "C:\\"},
+    {"X:\\", "C:\\", "C:\\"},
+    {"X:\\", "\\\\", "\\\\"},
+    {"X:\\", "\\\\?\\C:", "C:\\"},
+    {"X:\\", "\\\\?\\C:\\", "C:\\"},
+    {"X:\\", "\\\\?\\UNC\\", "\\\\"},
+    {"X:\\", "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\"},
+
+    /* Canonicalization */
+    {"C:\\a", ".\\b", "C:\\a\\b"},
+    {"C:\\a", "..\\b", "C:\\b"},
+
+    /* Other */
+    {"", "", "\\"},
+    {"a", "b", "a\\b"}
+};
+
+static void test_PathCchAppend(void)
+{
+    WCHAR path1W[PATHCCH_MAX_CCH];
+    WCHAR path2W[PATHCCH_MAX_CCH];
+    CHAR path1A[PATHCCH_MAX_CCH];
+    HRESULT hr;
+    INT i;
+
+    if (!pPathCchAppend)
+    {
+        win_skip("PathCchAppend() is not available.\n");
+        return;
+    }
+
+    MultiByteToWideChar(CP_ACP, 0, "\\a", -1, path1W, ARRAY_SIZE(path1W));
+    MultiByteToWideChar(CP_ACP, 0, "\\b", -1, path2W, ARRAY_SIZE(path2W));
+    hr = pPathCchAppend(NULL, PATHCCH_MAX_CCH, path2W);
+    ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+
+    hr = pPathCchAppend(path1W, 0, path2W);
+    ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+
+    hr = pPathCchAppend(path1W, PATHCCH_MAX_CCH + 1, path2W);
+    ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+
+    hr = pPathCchAppend(path1W, PATHCCH_MAX_CCH, NULL);
+    ok(hr == S_OK, "expect hr %#x, got %#x\n", S_OK, hr);
+    WideCharToMultiByte(CP_ACP, 0, path1W, -1, path1A, ARRAY_SIZE(path1A), NULL, NULL);
+    ok(!lstrcmpA(path1A, "\\a"), "expect \\a, got %s\n", path1A);
+
+    for (i = 0; i < ARRAY_SIZE(append_tests); i++)
+    {
+        const struct append_test *t = append_tests + i;
+
+        MultiByteToWideChar(CP_ACP, 0, t->path1, -1, path1W, ARRAY_SIZE(path1W));
+        MultiByteToWideChar(CP_ACP, 0, t->path2, -1, path2W, ARRAY_SIZE(path2W));
+        hr = pPathCchAppend(path1W, PATHCCH_MAX_CCH, path2W);
+        ok(hr == S_OK, "append \"%s\" \"%s\" expect hr %#x, got %#x\n", t->path1, t->path2, S_OK, hr);
+        if (SUCCEEDED(hr))
+        {
+            WideCharToMultiByte(CP_ACP, 0, path1W, -1, path1A, ARRAY_SIZE(path1A), NULL, NULL);
+            ok(!lstrcmpA(path1A, t->result), "append \"%s\" \"%s\" expect result \"%s\", got \"%s\"\n", t->path1,
+               t->path2, t->result, path1A);
+        }
+    }
+}
+
+static void test_PathCchAppendEx(void)
+{
+    WCHAR path1W[PATHCCH_MAX_CCH];
+    WCHAR path2W[PATHCCH_MAX_CCH];
+    CHAR path1A[PATHCCH_MAX_CCH];
+    HRESULT hr;
+    INT i;
+
+    if (!pPathCchAppendEx)
+    {
+        win_skip("PathCchAppendEx() is not available.\n");
+        return;
+    }
+
+    MultiByteToWideChar(CP_ACP, 0, "\\a", -1, path1W, ARRAY_SIZE(path1W));
+    MultiByteToWideChar(CP_ACP, 0, "\\b", -1, path2W, ARRAY_SIZE(path2W));
+    hr = pPathCchAppendEx(NULL, ARRAY_SIZE(path1W), path2W, 0);
+    ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+
+    hr = pPathCchAppendEx(path1W, 0, path2W, 0);
+    ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+    ok(path1W[0] == '\\', "expect path1 unchanged\n");
+
+    hr = pPathCchAppendEx(path1W, PATHCCH_MAX_CCH + 1, path2W, 0);
+    ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+    ok(path1W[0] == '\\', "expect path1 unchanged\n");
+
+    hr = pPathCchAppendEx(path1W,  ARRAY_SIZE(path1W), NULL, 0);
+    ok(hr == S_OK, "expect hr %#x, got %#x\n", S_OK, hr);
+    WideCharToMultiByte(CP_ACP, 0, path1W, -1, path1A, ARRAY_SIZE(path1A), NULL, NULL);
+    ok(!lstrcmpA(path1A, "\\a"), "expect \\a, got %s\n", path1A);
+
+    hr = pPathCchAppendEx(path1W, PATHCCH_MAX_CCH, path2W, 0);
+    ok(hr == S_OK, "expect hr %#x, got %#x\n", S_OK, hr);
+
+    for (i = 0; i < ARRAY_SIZE(append_tests); i++)
+    {
+        const struct append_test *t = append_tests + i;
+
+        MultiByteToWideChar(CP_ACP, 0, t->path1, -1, path1W, ARRAY_SIZE(path1W));
+        MultiByteToWideChar(CP_ACP, 0, t->path2, -1, path2W, ARRAY_SIZE(path2W));
+        hr = pPathCchAppendEx(path1W, PATHCCH_MAX_CCH, path2W, 0);
+        ok(hr == S_OK, "append \"%s\" \"%s\" expect hr %#x, got %#x\n", t->path1, t->path2, S_OK, hr);
+        if (SUCCEEDED(hr))
+        {
+            WideCharToMultiByte(CP_ACP, 0, path1W, -1, path1A, ARRAY_SIZE(path1A), NULL, NULL);
+            ok(!lstrcmpA(path1A, t->result), "append \"%s\" \"%s\" expect result \"%s\", got \"%s\"\n", t->path1,
+               t->path2, t->result, path1A);
+        }
+    }
+}
+
 static void test_PathCchAddExtension(void)
 {
     WCHAR pathW[PATHCCH_MAX_CCH + 1];
@@ -360,6 +1009,248 @@ static void test_PathCchAddExtension(void)
     }
 }
 
+static void test_PathCchCanonicalize(void)
+{
+    WCHAR path_inW[MAX_PATH], path_outW[MAX_PATH];
+    CHAR path_outA[MAX_PATH];
+    HRESULT hr;
+    INT i;
+
+    if (!pPathCchCanonicalize)
+    {
+        win_skip("PathCchCanonicalize() is not available.\n");
+        return;
+    }
+
+    /* No NULL check for path pointers on Windows */
+    if (0)
+    {
+        hr = pPathCchCanonicalize(NULL, ARRAY_SIZE(path_outW), path_inW);
+        ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+
+        /* MSDN says NULL path_in result in a backslash added to path_out, but the fact is that it would crash */
+        hr = pPathCchCanonicalize(path_outW, ARRAY_SIZE(path_outW), NULL);
+        ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+    }
+
+    hr = pPathCchCanonicalize(path_outW, 0, path_inW);
+    ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+
+    /* Test path length */
+    for (i = 0; i < MAX_PATH - 3; i++) path_inW[i] = 'a';
+    path_inW[MAX_PATH - 3] = '\0';
+    memset(path_outW, 0, sizeof(path_outW));
+    hr = pPathCchCanonicalize(path_outW, ARRAY_SIZE(path_outW), path_inW);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE), "expect hr %#x, got %#x %s\n",
+       HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE), hr, wine_dbgstr_w(path_outW));
+    ok(lstrlenW(path_outW) == 0, "got %d\n", lstrlenW(path_outW));
+
+    path_inW[0] = 'C';
+    path_inW[1] = ':';
+    path_inW[2] = '\\';
+    hr = pPathCchCanonicalize(path_outW, ARRAY_SIZE(path_outW), path_inW);
+    ok(hr == S_OK, "expect hr %#x, got %#x\n", S_OK, hr);
+
+    path_inW[MAX_PATH - 4] = '\0';
+    hr = pPathCchCanonicalize(path_outW, ARRAY_SIZE(path_outW), path_inW);
+    ok(hr == S_OK, "expect hr %#x, got %#x\n", S_OK, hr);
+
+    /* Insufficient buffer size handling */
+    hr = pPathCchCanonicalize(path_outW, 1, path_inW);
+    ok(hr == STRSAFE_E_INSUFFICIENT_BUFFER, "expect hr %#x, got %#x\n", STRSAFE_E_INSUFFICIENT_BUFFER, hr);
+
+    for (i = 0; i < ARRAY_SIZE(alloccanonicalize_tests); i++)
+    {
+        const struct alloccanonicalize_test *t = alloccanonicalize_tests + i;
+
+        /* Skip testing X: path input, this case is different compared to PathAllocCanonicalize */
+        /* Skip test cases where a flag is used */
+        if (!lstrcmpA("C:", t->path_in) || t->flags) continue;
+
+        MultiByteToWideChar(CP_ACP, 0, t->path_in, -1, path_inW, ARRAY_SIZE(path_inW));
+        hr = pPathCchCanonicalize(path_outW, ARRAY_SIZE(path_outW), path_inW);
+        ok(hr == t->hr, "path %s expect result %#x, got %#x\n", t->path_in, t->hr, hr);
+        if (SUCCEEDED(hr))
+        {
+            WideCharToMultiByte(CP_ACP, 0, path_outW, -1, path_outA, ARRAY_SIZE(path_outA), NULL, NULL);
+            ok(!lstrcmpA(path_outA, t->path_out), "path \"%s\" expect output path \"%s\", got \"%s\"\n", t->path_in,
+               t->path_out, path_outA);
+        }
+    }
+
+    /* X: path input */
+    /* Fill a \ at the end of X: if there is enough space */
+    MultiByteToWideChar(CP_ACP, 0, "C:", -1, path_inW, ARRAY_SIZE(path_inW));
+    hr = pPathCchCanonicalize(path_outW, ARRAY_SIZE(path_outW), path_inW);
+    ok(hr == S_OK, "path %s expect result %#x, got %#x\n", "C:", S_OK, hr);
+    if (SUCCEEDED(hr))
+    {
+        WideCharToMultiByte(CP_ACP, 0, path_outW, -1, path_outA, ARRAY_SIZE(path_outA), NULL, NULL);
+        ok(!lstrcmpA(path_outA, "C:\\"), "path \"%s\" expect output path \"%s\", got \"%s\"\n", "C:", "C:\\",
+           path_outA);
+    }
+
+    /* Don't fill a \ at the end of X: if there isn't enough space */
+    MultiByteToWideChar(CP_ACP, 0, "C:", -1, path_inW, ARRAY_SIZE(path_inW));
+    hr = pPathCchCanonicalize(path_outW, 3, path_inW);
+    ok(hr == S_OK, "path %s expect result %#x, got %#x\n", "C:", S_OK, hr);
+    if (SUCCEEDED(hr))
+    {
+        WideCharToMultiByte(CP_ACP, 0, path_outW, -1, path_outA, ARRAY_SIZE(path_outA), NULL, NULL);
+        ok(!lstrcmpA(path_outA, "C:"), "path \"%s\" expect output path \"%s\", got \"%s\"\n", "C:", "C:\\", path_outA);
+    }
+
+    /* Don't fill a \ at the end of X: if there is character following X: */
+    MultiByteToWideChar(CP_ACP, 0, "C:a", -1, path_inW, ARRAY_SIZE(path_inW));
+    hr = pPathCchCanonicalize(path_outW, ARRAY_SIZE(path_outW), path_inW);
+    ok(hr == S_OK, "path %s expect result %#x, got %#x\n", "C:a", S_OK, hr);
+    if (SUCCEEDED(hr))
+    {
+        WideCharToMultiByte(CP_ACP, 0, path_outW, -1, path_outA, ARRAY_SIZE(path_outA), NULL, NULL);
+        ok(!lstrcmpA(path_outA, "C:a"), "path \"%s\" expect output path \"%s\", got \"%s\"\n", "C:a", "C:a", path_outA);
+    }
+}
+
+static void test_PathCchCanonicalizeEx(void)
+{
+    WCHAR path_inW[PATHCCH_MAX_CCH + 1], path_outW[PATHCCH_MAX_CCH];
+    CHAR path_outA[4096];
+    BOOL skip_new_flags = TRUE;
+    HRESULT hr;
+    INT i;
+
+    if (!pPathCchCanonicalizeEx)
+    {
+        win_skip("PathCchCanonicalizeEx() is not available.\n");
+        return;
+    }
+
+    /* No NULL check for path pointers on Windows */
+    if (0)
+    {
+        hr = pPathCchCanonicalizeEx(NULL, ARRAY_SIZE(path_outW), path_inW, 0);
+        ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+
+        /* MSDN says NULL path_in result in a backslash added to path_out, but the fact is that it would crash */
+        hr = pPathCchCanonicalizeEx(path_outW, ARRAY_SIZE(path_outW), NULL, 0);
+        ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+    }
+
+    path_outW[0] = 0xff;
+    hr = pPathCchCanonicalizeEx(path_outW, 0, path_inW, 0);
+    ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+    ok(path_outW[0] = 0xff, "expect path_outW unchanged\n");
+
+    /* Test path length */
+    for (i = 0; i < ARRAY_SIZE(path_inW) - 1; i++) path_inW[i] = 'a';
+    path_inW[PATHCCH_MAX_CCH] = '\0';
+    hr = pPathCchCanonicalizeEx(path_outW, ARRAY_SIZE(path_outW), path_inW, PATHCCH_ALLOW_LONG_PATHS);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE), "expect hr %#x, got %#x\n",
+       HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE), hr);
+
+    path_inW[PATHCCH_MAX_CCH - 1] = '\0';
+    hr = pPathCchCanonicalizeEx(path_outW, ARRAY_SIZE(path_outW), path_inW, PATHCCH_ALLOW_LONG_PATHS);
+    ok(hr == S_OK, "expect hr %#x, got %#x\n", S_OK, hr);
+
+    hr = pPathCchCanonicalizeEx(path_outW, 1, path_inW, PATHCCH_ALLOW_LONG_PATHS);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE), "expect hr %#x, got %#x\n",
+       HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE), hr);
+
+    /* No root and path > MAX_PATH - 4, return HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE) */
+    path_inW[MAX_PATH - 3] = '\0';
+    hr = pPathCchCanonicalizeEx(path_outW, 1, path_inW, 0);
+    ok(hr == HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE), "expect hr %#x, got %#x\n",
+       HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE), hr);
+
+    /* Has root and path > MAX_PATH - 4 */
+    path_inW[0] = 'C';
+    path_inW[1] = ':';
+    path_inW[2] = '\\';
+    hr = pPathCchCanonicalizeEx(path_outW, 1, path_inW, 0);
+    ok(hr == STRSAFE_E_INSUFFICIENT_BUFFER, "expect hr %#x, got %#x\n", STRSAFE_E_INSUFFICIENT_BUFFER, hr);
+
+    path_inW[0] = '\\';
+    path_inW[1] = path_inW[2] = 'a';
+    hr = pPathCchCanonicalizeEx(path_outW, 1, path_inW, 0);
+    ok(hr == STRSAFE_E_INSUFFICIENT_BUFFER, "expect hr %#x, got %#x\n", STRSAFE_E_INSUFFICIENT_BUFFER, hr);
+
+    path_inW[0] = path_inW[1] = '\\';
+    path_inW[2] = 'a';
+    hr = pPathCchCanonicalizeEx(path_outW, 1, path_inW, 0);
+    ok(hr == STRSAFE_E_INSUFFICIENT_BUFFER, "expect hr %#x, got %#x\n", STRSAFE_E_INSUFFICIENT_BUFFER, hr);
+
+    /* path <= MAX_PATH - 4 */
+    path_inW[0] = path_inW[1] = path_inW[2] = 'a';
+    path_inW[MAX_PATH - 4] = '\0';
+    hr = pPathCchCanonicalizeEx(path_outW, 1, path_inW, 0);
+    ok(hr == STRSAFE_E_INSUFFICIENT_BUFFER, "expect hr %#x, got %#x\n", STRSAFE_E_INSUFFICIENT_BUFFER, hr);
+
+    /* Check if flags added after Windows 10 1709 are supported */
+    MultiByteToWideChar(CP_ACP, 0, "C:\\", -1, path_inW, ARRAY_SIZE(path_inW));
+    hr = pPathCchCanonicalizeEx(path_outW, ARRAY_SIZE(path_outW), path_inW, PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS);
+    if (hr == E_INVALIDARG) skip_new_flags = FALSE;
+
+    for (i = 0; i < ARRAY_SIZE(alloccanonicalize_tests); i++)
+    {
+        const struct alloccanonicalize_test *t = alloccanonicalize_tests + i;
+
+        /* Skip testing X: path input, this case is different compared to PathAllocCanonicalize */
+        if (!lstrcmpA("C:", t->path_in)) continue;
+
+        if (((PATHCCH_FORCE_ENABLE_LONG_NAME_PROCESS | PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS
+              | PATHCCH_DO_NOT_NORMALIZE_SEGMENTS | PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH
+              | PATHCCH_ENSURE_TRAILING_SLASH)
+             & t->flags)
+            && skip_new_flags)
+        {
+            win_skip("Skip testing new flags added after Windows 10 1709\n");
+            return;
+        }
+
+        MultiByteToWideChar(CP_ACP, 0, t->path_in, -1, path_inW, ARRAY_SIZE(path_inW));
+        hr = pPathCchCanonicalizeEx(path_outW, ARRAY_SIZE(path_outW), path_inW, t->flags);
+        ok(hr == t->hr, "path %s expect result %#x, got %#x\n", t->path_in, t->hr, hr);
+        if (SUCCEEDED(hr))
+        {
+            WideCharToMultiByte(CP_ACP, 0, path_outW, -1, path_outA, ARRAY_SIZE(path_outA), NULL, NULL);
+            ok(!lstrcmpA(path_outA, t->path_out), "path \"%s\" expect output path \"%s\", got \"%s\"\n", t->path_in,
+               t->path_out, path_outA);
+        }
+    }
+
+    /* X: path input */
+    /* Fill a \ at the end of X: if there is enough space */
+    MultiByteToWideChar(CP_ACP, 0, "C:", -1, path_inW, ARRAY_SIZE(path_inW));
+    hr = pPathCchCanonicalizeEx(path_outW, ARRAY_SIZE(path_outW), path_inW, 0);
+    ok(hr == S_OK, "path %s expect result %#x, got %#x\n", "C:", S_OK, hr);
+    if (SUCCEEDED(hr))
+    {
+        WideCharToMultiByte(CP_ACP, 0, path_outW, -1, path_outA, ARRAY_SIZE(path_outA), NULL, NULL);
+        ok(!lstrcmpA(path_outA, "C:\\"), "path \"%s\" expect output path \"%s\", got \"%s\"\n", "C:", "C:\\",
+           path_outA);
+    }
+
+    /* Don't fill a \ at the end of X: if there isn't enough space */
+    MultiByteToWideChar(CP_ACP, 0, "C:", -1, path_inW, ARRAY_SIZE(path_inW));
+    hr = pPathCchCanonicalizeEx(path_outW, 3, path_inW, 0);
+    ok(hr == S_OK, "path %s expect result %#x, got %#x\n", "C:", S_OK, hr);
+    if (SUCCEEDED(hr))
+    {
+        WideCharToMultiByte(CP_ACP, 0, path_outW, -1, path_outA, ARRAY_SIZE(path_outA), NULL, NULL);
+        ok(!lstrcmpA(path_outA, "C:"), "path \"%s\" expect output path \"%s\", got \"%s\"\n", "C:", "C:\\", path_outA);
+    }
+
+    /* Don't fill a \ at the end of X: if there is character following X: */
+    MultiByteToWideChar(CP_ACP, 0, "C:a", -1, path_inW, ARRAY_SIZE(path_inW));
+    hr = pPathCchCanonicalizeEx(path_outW, ARRAY_SIZE(path_outW), path_inW, 0);
+    ok(hr == S_OK, "path %s expect result %#x, got %#x\n", "C:a", S_OK, hr);
+    if (SUCCEEDED(hr))
+    {
+        WideCharToMultiByte(CP_ACP, 0, path_outW, -1, path_outA, ARRAY_SIZE(path_outA), NULL, NULL);
+        ok(!lstrcmpA(path_outA, "C:a"), "path \"%s\" expect output path \"%s\", got \"%s\"\n", "C:a", "C:a", path_outA);
+    }
+}
+
 struct findextension_test
 {
     const CHAR *path;
@@ -544,6 +1435,165 @@ static void test_PathCchIsRoot(void)
     }
 }
 
+struct removebackslashex_test
+{
+    const CHAR *path_in;
+    const CHAR *path_out;
+    int end_offset;
+    SIZE_T free_size;
+    HRESULT hr;
+};
+
+static const struct removebackslashex_test removebackslashex_tests [] =
+{
+    {"", "", 0, 1, S_FALSE},
+    {"C", "C", 1, 1, S_FALSE},
+    {"C\\", "C", 1, 2, S_OK},
+    {"C:", "C:", 2, 1, S_FALSE},
+    {"C:\\", "C:\\", 2, 2, S_FALSE},
+    {"C:\\\\", "C:\\", 3, 2, S_OK},
+    {"C:\\a\\", "C:\\a", 4, 2, S_OK},
+    {"C:\\a\\\\", "C:\\a\\", 5, 2, S_OK},
+    {"\\", "\\", 0, 2, S_FALSE},
+    {"\\\\", "\\\\", 1, 2, S_FALSE},
+    {"\\?\\", "\\?", 2, 2, S_OK},
+    {"\\?\\\\", "\\?\\", 3, 2, S_OK},
+    {"\\a\\", "\\a", 2, 2, S_OK},
+    {"\\a\\\\", "\\a\\", 3, 2, S_OK},
+    {"\\\\a\\", "\\\\a", 3, 2, S_OK},
+    {"\\\\a\\b\\", "\\\\a\\b", 5, 2, S_OK},
+    {"\\\\a\\\\", "\\\\a\\", 4, 2, S_OK},
+    {"\\\\?\\", "\\\\?", 3, 2, S_OK},
+    {"\\\\?\\\\", "\\\\?\\", 4, 2, S_OK},
+    {"\\\\?\\C:", "\\\\?\\C:", 6, 1, S_FALSE},
+    {"\\\\?\\C:\\", "\\\\?\\C:\\", 6, 2, S_FALSE},
+    {"\\?\\UNC\\", "\\?\\UNC", 6, 2, S_OK},
+    {"\\\\?\\UNC", "\\\\?\\UNC", 7, 1, S_FALSE},
+    {"\\\\?\\UNC\\", "\\\\?\\UNC\\", 7, 2, S_FALSE},
+    {"\\\\?\\UNC\\a", "\\\\?\\UNC\\a", 9, 1, S_FALSE},
+    {"\\\\?\\UNC\\a\\", "\\\\?\\UNC\\a", 9, 2, S_OK},
+    {"\\\\?\\UNC\\a\\b\\", "\\\\?\\UNC\\a\\b", 11, 2, S_OK},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}", 48, 1, S_FALSE},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\", 48, 2, S_FALSE},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a", 50, 1, S_FALSE},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a\\",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a", 50, 2, S_OK}
+};
+
+static void test_PathCchRemoveBackslash(void)
+{
+    WCHAR pathW[PATHCCH_MAX_CCH];
+    CHAR pathA[PATHCCH_MAX_CCH];
+    HRESULT hr;
+    SIZE_T path_size;
+    INT i;
+
+    if (!pPathCchRemoveBackslash)
+    {
+        win_skip("PathCchRemoveBackslash() is not available.\n");
+        return;
+    }
+
+    /* No NULL check for path on Windows */
+    if (0)
+    {
+        hr = pPathCchRemoveBackslash(NULL, PATHCCH_MAX_CCH);
+        ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+    }
+
+    MultiByteToWideChar(CP_ACP, 0, "C:\\a\\", -1, pathW, ARRAY_SIZE(pathW));
+    hr = pPathCchRemoveBackslash(pathW, 0);
+    ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+
+    hr = pPathCchRemoveBackslash(pathW, PATHCCH_MAX_CCH + 1);
+    ok(hr == S_OK, "expect hr %#x, got %#x\n", S_OK, hr);
+
+    hr = pPathCchRemoveBackslash(pathW, PATHCCH_MAX_CCH);
+    ok(hr == S_FALSE, "expect hr %#x, got %#x\n", S_FALSE, hr);
+
+    for (i = 0; i < ARRAY_SIZE(removebackslashex_tests); i++)
+    {
+        const struct removebackslashex_test *t = removebackslashex_tests + i;
+        path_size = MultiByteToWideChar(CP_ACP, 0, t->path_in, -1, pathW, ARRAY_SIZE(pathW));
+        hr = pPathCchRemoveBackslash(pathW, path_size);
+        ok(hr == t->hr, "path %s expect result %#x, got %#x\n", t->path_in, t->hr, hr);
+        if (SUCCEEDED(hr))
+        {
+            WideCharToMultiByte(CP_ACP, 0, pathW, -1, pathA, ARRAY_SIZE(pathA), NULL, NULL);
+            ok(!lstrcmpA(pathA, t->path_out), "path %s expect output path %s, got %s\n", t->path_in, t->path_out,
+               pathA);
+        }
+    }
+}
+
+static void test_PathCchRemoveBackslashEx(void)
+{
+    WCHAR pathW[PATHCCH_MAX_CCH];
+    CHAR pathA[PATHCCH_MAX_CCH];
+    WCHAR *path_end;
+    SIZE_T path_size, free_size;
+    HRESULT hr;
+    INT i;
+
+    if (!pPathCchRemoveBackslashEx)
+    {
+        win_skip("PathCchRemoveBackslashEx() is not available.\n");
+        return;
+    }
+
+    /* No NULL check for path on Windows */
+    if (0)
+    {
+        hr = pPathCchRemoveBackslashEx(NULL, 0, &path_end, &path_size);
+        ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+    }
+
+    path_size = MultiByteToWideChar(CP_ACP, 0, "C:\\a\\", -1, pathW, ARRAY_SIZE(pathW));
+    hr = pPathCchRemoveBackslashEx(pathW, 0, &path_end, &path_size);
+    ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+
+    free_size = 0xdeadbeef;
+    hr = pPathCchRemoveBackslashEx(pathW, path_size, NULL, &free_size);
+    ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+    ok(free_size == 0, "expect %d, got %lu\n", 0, free_size);
+
+    path_end = (WCHAR *)0xdeadbeef;
+    hr = pPathCchRemoveBackslashEx(pathW, path_size, &path_end, NULL);
+    ok(hr == E_INVALIDARG, "expect hr %#x, got %#x\n", E_INVALIDARG, hr);
+    ok(path_end == NULL, "expect null, got %p\n", path_end);
+
+    hr = pPathCchRemoveBackslashEx(pathW, PATHCCH_MAX_CCH + 1, &path_end, &free_size);
+    ok(hr == S_OK, "expect hr %#x, got %#x\n", S_OK, hr);
+
+    hr = pPathCchRemoveBackslashEx(pathW, PATHCCH_MAX_CCH, &path_end, &free_size);
+    ok(hr == S_FALSE, "expect hr %#x, got %#x\n", S_FALSE, hr);
+
+    /* Size < original path length + 1, don't read beyond size */
+    MultiByteToWideChar(CP_ACP, 0, "C:\\a", -1, pathW, ARRAY_SIZE(pathW));
+    hr = pPathCchRemoveBackslashEx(pathW, ARRAY_SIZE("C:\\a") - 1, &path_end, &free_size);
+    ok(hr == E_INVALIDARG, "expect result %#x, got %#x\n", E_INVALIDARG, hr);
+
+    for (i = 0; i < ARRAY_SIZE(removebackslashex_tests); i++)
+    {
+        const struct removebackslashex_test *t = removebackslashex_tests + i;
+        path_size = MultiByteToWideChar(CP_ACP, 0, t->path_in, -1, pathW, ARRAY_SIZE(pathW));
+        hr = pPathCchRemoveBackslashEx(pathW, path_size, &path_end, &free_size);
+        ok(hr == t->hr, "path %s expect result %#x, got %#x\n", t->path_in, t->hr, hr);
+        if (SUCCEEDED(hr))
+        {
+            ok(path_end - pathW == t->end_offset, "path %s expect end offset %d, got %d\n", t->path_in, t->end_offset,
+               path_end - pathW);
+            ok(free_size == t->free_size, "path %s expect free size %lu, got %lu\n", t->path_in, t->free_size, free_size);
+            WideCharToMultiByte(CP_ACP, 0, pathW, -1, pathA, ARRAY_SIZE(pathA), NULL, NULL);
+            ok(!lstrcmpA(pathA, t->path_out), "path %s expect output path %s, got %s\n", t->path_in, t->path_out,
+               pathA);
+        }
+    }
+}
+
 struct removeextension_test
 {
     const CHAR *path;
@@ -626,6 +1676,129 @@ static void test_PathCchRemoveExtension(void)
     }
 }
 
+struct removefilespec_test
+{
+    const CHAR *path;
+    const CHAR *expected;
+    HRESULT hr;
+    SIZE_T size;
+};
+
+static const struct removefilespec_test removefilespec_tests[] =
+{
+    {"", "", S_FALSE},
+    {"a", "", S_OK},
+    {"a\\", "a", S_OK},
+    {"a\\b", "a", S_OK},
+
+    {"\\", "\\", S_FALSE},
+    {"\\a", "\\", S_OK},
+    {"\\a\\", "\\a", S_OK},
+    {"\\a\\b", "\\a", S_OK},
+
+    {"\\\\", "\\\\", S_FALSE},
+    {"\\\\a", "\\\\a", S_FALSE},
+    {"\\\\a\\", "\\\\a", S_OK},
+    {"\\\\a\\b", "\\\\a\\b", S_FALSE},
+    {"\\\\a\\b\\", "\\\\a\\b", S_OK},
+    {"\\\\a\\b\\c", "\\\\a\\b", S_OK},
+
+    {"C:", "C:", S_FALSE},
+    {"C:a", "C:", S_OK},
+    {"C:a\\", "C:a", S_OK},
+    {"C:a\\b", "C:a", S_OK},
+
+    {"C:\\", "C:\\", S_FALSE},
+    {"C:\\a", "C:\\", S_OK},
+    {"C:\\a\\", "C:\\a", S_OK},
+    {"C:\\a\\b", "C:\\a", S_OK},
+
+    {"\\\\?\\", "\\\\?", S_OK},
+    {"\\\\?\\a", "\\\\?", S_OK},
+    {"\\\\?\\a\\", "\\\\?\\a", S_OK},
+    {"\\\\?\\a\\b", "\\\\?\\a", S_OK},
+
+    {"\\\\?\\C:", "\\\\?\\C:", S_FALSE},
+    {"\\\\?\\C:a", "\\\\?\\C:", S_OK},
+    {"\\\\?\\C:a\\", "\\\\?\\C:a", S_OK},
+    {"\\\\?\\C:a\\b", "\\\\?\\C:a", S_OK},
+
+    {"\\\\?\\C:\\", "\\\\?\\C:\\", S_FALSE},
+    {"\\\\?\\C:\\a", "\\\\?\\C:\\", S_OK},
+    {"\\\\?\\C:\\a\\", "\\\\?\\C:\\a", S_OK},
+    {"\\\\?\\C:\\a\\b", "\\\\?\\C:\\a", S_OK},
+
+    {"\\\\?\\UNC\\", "\\\\?\\UNC\\", S_FALSE},
+    {"\\\\?\\UNC\\a", "\\\\?\\UNC\\a", S_FALSE},
+    {"\\\\?\\UNC\\a\\", "\\\\?\\UNC\\a", S_OK},
+    {"\\\\?\\UNC\\a\\b", "\\\\?\\UNC\\a\\b", S_FALSE},
+    {"\\\\?\\UNC\\a\\b\\", "\\\\?\\UNC\\a\\b", S_OK},
+    {"\\\\?\\UNC\\a\\b\\c", "\\\\?\\UNC\\a\\b", S_OK},
+
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}", S_FALSE},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}a",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}", S_OK},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}a\\",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}a", S_OK},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}a\\b",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}a", S_OK},
+
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\", S_FALSE},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\", S_OK},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a\\",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a", S_OK},
+    {"\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a\\b",
+     "\\\\?\\Volume{e51a1864-6f2d-4019-b73d-f4e60e600c26}\\a", S_OK},
+
+    /* Size tests */
+    {"C:\\a", NULL, E_INVALIDARG, PATHCCH_MAX_CCH + 1},
+    {"C:\\a", "C:\\", S_OK, PATHCCH_MAX_CCH},
+    /* Size < original path length + 1, read beyond size */
+    {"C:\\a", "C:\\", S_OK, ARRAY_SIZE("C:\\a") - 1},
+    /* Size < result path length + 1 */
+    {"C:\\a", NULL, E_INVALIDARG, ARRAY_SIZE("C:\\") - 1}
+};
+
+static void test_PathCchRemoveFileSpec(void)
+{
+    WCHAR pathW[PATHCCH_MAX_CCH] = {0};
+    CHAR pathA[PATHCCH_MAX_CCH];
+    SIZE_T size;
+    HRESULT hr;
+    INT i;
+
+    if (!pPathCchRemoveFileSpec)
+    {
+        win_skip("PathCchRemoveFileSpec() is not available.\n");
+        return;
+    }
+
+    /* Null arguments */
+    hr = pPathCchRemoveFileSpec(NULL, ARRAY_SIZE(pathW));
+    ok(hr == E_INVALIDARG, "expect %#x, got %#x\n", E_INVALIDARG, hr);
+
+    hr = pPathCchRemoveFileSpec(pathW, 0);
+    ok(hr == E_INVALIDARG, "expect %#x, got %#x\n", E_INVALIDARG, hr);
+
+    for (i = 0; i < ARRAY_SIZE(removefilespec_tests); i++)
+    {
+        const struct removefilespec_test *t = removefilespec_tests + i;
+
+        MultiByteToWideChar(CP_ACP, 0, t->path, -1, pathW, ARRAY_SIZE(pathW));
+        size = t->size ? t->size : ARRAY_SIZE(pathW);
+        hr = pPathCchRemoveFileSpec(pathW, size);
+        ok(hr == t->hr, "path %s expect result %#x, got %#x\n", t->path, t->hr, hr);
+        if (SUCCEEDED(hr))
+        {
+            WideCharToMultiByte(CP_ACP, 0, pathW, -1, pathA, ARRAY_SIZE(pathA), NULL, NULL);
+            ok(!lstrcmpA(pathA, t->expected), "path %s expect stripped path %s, got %s\n", t->path, t->expected, pathA);
+        }
+    }
+}
+
 struct renameextension_test
 {
     const CHAR *path;
@@ -1101,26 +2274,46 @@ START_TEST(path)
 {
     HMODULE hmod = LoadLibraryA("kernelbase.dll");
 
-    pPathCchCombineEx = (void *)GetProcAddress(hmod, "PathCchCombineEx");
+    pPathAllocCanonicalize = (void *)GetProcAddress(hmod, "PathAllocCanonicalize");
+    pPathAllocCombine = (void *)GetProcAddress(hmod, "PathAllocCombine");
     pPathCchAddBackslash = (void *)GetProcAddress(hmod, "PathCchAddBackslash");
     pPathCchAddBackslashEx = (void *)GetProcAddress(hmod, "PathCchAddBackslashEx");
     pPathCchAddExtension = (void *)GetProcAddress(hmod, "PathCchAddExtension");
+    pPathCchAppend = (void *)GetProcAddress(hmod, "PathCchAppend");
+    pPathCchAppendEx = (void *)GetProcAddress(hmod, "PathCchAppendEx");
+    pPathCchCanonicalize = (void *)GetProcAddress(hmod, "PathCchCanonicalize");
+    pPathCchCanonicalizeEx = (void *)GetProcAddress(hmod, "PathCchCanonicalizeEx");
+    pPathCchCombine = (void *)GetProcAddress(hmod, "PathCchCombine");
+    pPathCchCombineEx = (void *)GetProcAddress(hmod, "PathCchCombineEx");
     pPathCchFindExtension = (void *)GetProcAddress(hmod, "PathCchFindExtension");
     pPathCchIsRoot = (void *)GetProcAddress(hmod, "PathCchIsRoot");
+    pPathCchRemoveBackslash = (void *)GetProcAddress(hmod, "PathCchRemoveBackslash");
+    pPathCchRemoveBackslashEx = (void *)GetProcAddress(hmod, "PathCchRemoveBackslashEx");
     pPathCchRemoveExtension = (void *)GetProcAddress(hmod, "PathCchRemoveExtension");
+    pPathCchRemoveFileSpec = (void *)GetProcAddress(hmod, "PathCchRemoveFileSpec");
     pPathCchRenameExtension = (void *)GetProcAddress(hmod, "PathCchRenameExtension");
     pPathCchSkipRoot = (void *)GetProcAddress(hmod, "PathCchSkipRoot");
     pPathCchStripPrefix = (void *)GetProcAddress(hmod, "PathCchStripPrefix");
     pPathCchStripToRoot = (void *)GetProcAddress(hmod, "PathCchStripToRoot");
     pPathIsUNCEx = (void *)GetProcAddress(hmod, "PathIsUNCEx");
 
-    test_PathCchCombineEx();
+    test_PathAllocCanonicalize();
+    test_PathAllocCombine();
     test_PathCchAddBackslash();
     test_PathCchAddBackslashEx();
     test_PathCchAddExtension();
+    test_PathCchAppend();
+    test_PathCchAppendEx();
+    test_PathCchCanonicalize();
+    test_PathCchCanonicalizeEx();
+    test_PathCchCombine();
+    test_PathCchCombineEx();
     test_PathCchFindExtension();
     test_PathCchIsRoot();
+    test_PathCchRemoveBackslash();
+    test_PathCchRemoveBackslashEx();
     test_PathCchRemoveExtension();
+    test_PathCchRemoveFileSpec();
     test_PathCchRenameExtension();
     test_PathCchSkipRoot();
     test_PathCchStripPrefix();
diff --git a/include/pathcch.h b/include/pathcch.h
index 443ccd3a4f..0c2dc63c41 100644
--- a/include/pathcch.h
+++ b/include/pathcch.h
@@ -22,16 +22,27 @@
 #define PATHCCH_FORCE_DISABLE_LONG_NAME_PROCESS 0x04
 #define PATHCCH_DO_NOT_NORMALIZE_SEGMENTS       0x08
 #define PATHCCH_ENSURE_IS_EXTENDED_LENGTH_PATH  0x10
+#define PATHCCH_ENSURE_TRAILING_SLASH           0x20
 
 #define PATHCCH_MAX_CCH 0x8000
 
+HRESULT WINAPI PathAllocCanonicalize(const WCHAR *path_in, DWORD flags, WCHAR **path_out);
+HRESULT WINAPI PathAllocCombine(const WCHAR *path1, const WCHAR *path2, DWORD flags, WCHAR **out);
 HRESULT WINAPI PathCchAddBackslash(WCHAR *path, SIZE_T size);
 HRESULT WINAPI PathCchAddBackslashEx(WCHAR *path, SIZE_T size, WCHAR **end, SIZE_T *remaining);
 HRESULT WINAPI PathCchAddExtension(WCHAR *path, SIZE_T size, const WCHAR *extension);
+HRESULT WINAPI PathCchAppend(WCHAR *path1, SIZE_T size, const WCHAR *path2);
+HRESULT WINAPI PathCchAppendEx(WCHAR *path1, SIZE_T size, const WCHAR *path2, DWORD flags);
+HRESULT WINAPI PathCchCanonicalize(WCHAR *out, SIZE_T size, const WCHAR *in);
+HRESULT WINAPI PathCchCanonicalizeEx(WCHAR *out, SIZE_T size, const WCHAR *in, DWORD flags);
+HRESULT WINAPI PathCchCombine(WCHAR *out, SIZE_T size, const WCHAR *path1, const WCHAR *path2);
 HRESULT WINAPI PathCchCombineEx(WCHAR *out, SIZE_T size, const WCHAR *path1, const WCHAR *path2, DWORD flags);
 HRESULT WINAPI PathCchFindExtension(const WCHAR *path, SIZE_T size, const WCHAR **extension);
 BOOL    WINAPI PathCchIsRoot(const WCHAR *path);
+HRESULT WINAPI PathCchRemoveBackslash(WCHAR *path, SIZE_T path_size);
+HRESULT WINAPI PathCchRemoveBackslashEx(WCHAR *path, SIZE_T path_size, WCHAR **path_end, SIZE_T *free_size);
 HRESULT WINAPI PathCchRemoveExtension(WCHAR *path, SIZE_T size);
+HRESULT WINAPI PathCchRemoveFileSpec(WCHAR *path, SIZE_T size);
 HRESULT WINAPI PathCchRenameExtension(WCHAR *path, SIZE_T size, const WCHAR *extension);
 HRESULT WINAPI PathCchSkipRoot(const WCHAR *path, const WCHAR **root_end);
 HRESULT WINAPI PathCchStripPrefix(WCHAR *path, SIZE_T size);
