From 41cf4093fa3819c9f1af2cb5c81d412176d2b725 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 14 Aug 2018 10:38:03 -0500
Subject: [PATCH 01/16] ffmpeg

---
 src/FAudio.c          | 62 +++++++++++++++++++++++++++++++++++++
 src/FAudio_internal.c | 71 +++++++++++++++++++++++++++++++++++++++++++
 src/FAudio_internal.h |  1 +
 3 files changed, 134 insertions(+)

diff --git a/src/FAudio.c b/src/FAudio.c
index 2973e5d..5824865 100644
--- a/src/FAudio.c
+++ b/src/FAudio.c
@@ -254,6 +254,68 @@ uint32_t FAudio_CreateSourceVoice(
 		(*ppSourceVoice)->src.decode = ((*ppSourceVoice)->src.format->nChannels == 2) ?
 			FAudio_INTERNAL_DecodeStereoMSADPCM :
 			FAudio_INTERNAL_DecodeMonoMSADPCM;
+	else if((*ppSourceVoice)->src.format->wFormatTag == FAUDIO_FORMAT_WMAUDIO2)
+	{
+		enum AVCodecID cid;
+		AVCodec *codec;
+
+		(*ppSourceVoice)->src.decode = FAudio_INTERNAL_DecodeFFMPEG;
+
+		/* initialize ffmpeg state */
+		codec = avcodec_find_decoder(AV_CODEC_ID_WMAV2);
+		if(!codec){
+			FAudio_free((*ppSourceVoice)->src.format);
+			FAudio_free(*ppSourceVoice);
+			return FAUDIO_E_UNSUPPORTED_FORMAT;
+		}
+
+		src->conv_ctx = avcodec_alloc_context3(codec);
+		if(!src->conv_ctx){
+			FAudio_free((*ppSourceVoice)->src.format);
+			FAudio_free(*ppSourceVoice);
+			return FAUDIO_E_UNSUPPORTED_FORMAT;
+		}
+
+		src->conv_ctx->bit_rate = (*ppSourceVoice)->src.format->Format.nAvgBytesPerSec * 8;
+		src->conv_ctx->channels = (*ppSourceVoice)->src.format->Format.nChannels;
+		src->conv_ctx->sample_rate = (*ppSourceVoice)->src.format->Format.nSamplesPerSec;
+		src->conv_ctx->block_align = (*ppSourceVoice)->src.format->Format.nBlockAlign;
+		src->conv_ctx->bits_per_coded_sample = (*ppSourceVoice)->src.format->Format.wBitsPerSample;
+		src->conv_ctx->extradata_size = (*ppSourceVoice)->src.format->Format.cbSize;
+		src->conv_ctx->request_sample_fmt = AV_SAMPLE_FMT_FLT;
+		if((*ppSourceVoice)->src.format->Format.cbSize){
+			src->conv_ctx->extradata = HeapAlloc(GetProcessHeap(), 0, (*ppSourceVoice)->src.format->Format.cbSize + AV_INPUT_BUFFER_PADDING_SIZE);
+			memcpy(src->conv_ctx->extradata, (&(*ppSourceVoice)->src.format->Format.cbSize) + 1, (*ppSourceVoice)->src.format->Format.cbSize);
+		}else{
+			/* xWMA doesn't provide the extradata info that FFmpeg needs to
+			 * decode WMA data, so we create some fake extradata. This is taken
+			 * from <ffmpeg/libavformat/xwma.c>. */
+			src->conv_ctx->extradata_size = 6;
+			src->conv_ctx->extradata = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, AV_INPUT_BUFFER_PADDING_SIZE);
+			src->conv_ctx->extradata[4] = 31;
+		}
+
+		if(avcodec_open2(src->conv_ctx, codec, NULL) < 0){
+			FAudio_free((*ppSourceVoice)->src.conv_ctx->extradata);
+			av_free(src->conv_ctx);
+			FAudio_free((*ppSourceVoice)->src.format);
+			FAudio_free(*ppSourceVoice);
+			return AUDCLNT_E_UNSUPPORTED_FORMAT;
+		}
+
+		src->conv_frame = av_frame_alloc();
+		if(!src->conv_ctx){
+			avcodec_close(src->conv_ctx);
+			FAudio_free((*ppSourceVoice)->src.conv_ctx->extradata);
+			av_free(src->conv_ctx);
+			FAudio_free((*ppSourceVoice)->src.format);
+			FAudio_free(*ppSourceVoice);
+			return AUDCLNT_E_UNSUPPORTED_FORMAT;
+		}
+
+		if(src->conv_ctx->sample_fmt != AV_SAMPLE_FMT_FLT){
+			FAudio_assert(0 && "Got non-float format!!!");
+		}
 	}
 	else if ((*ppSourceVoice)->src.format->wFormatTag == FAUDIO_FORMAT_WMAUDIO2)
 	{
diff --git a/src/FAudio_internal.c b/src/FAudio_internal.c
index 3e618ae..a8e3428 100644
--- a/src/FAudio_internal.c
+++ b/src/FAudio_internal.c
@@ -1277,3 +1277,74 @@ void FAudio_INTERNAL_DecodeStereoMSADPCM(
 
 	*samples = done;
 }
+
+uint32_t FAudio_INTERNAL_DecodeFFMPEG(
+	FAudioVoice *voice,
+	FAudioBuffer *buffer,
+	uint32_t *samples,
+	uint32_t end,
+	float *decodeCache
+) {
+	AVPacket avpkt = {0};
+	int averr;
+
+	avpkt.size = format->nBlockAlign;
+	avpkt.data = (unsigned char *)buffer->pAudioData + curOffset;
+
+	while (samples > 0)
+	{
+		averr = avcodec_receive_frame(src->conv_ctx, src->conv_frame);
+		if(averr == AVERROR(EAGAIN)){
+			/* ffmpeg needs more data to decode */
+			avpkt.pts = avpkt.dts = AV_NOPTS_VALUE;
+
+			if(buf->offs_bytes >= buf->cur_end_bytes)
+				/* no more data in this buffer */
+				break;
+
+			if(buf->offs_bytes + avpkt.size + AV_INPUT_BUFFER_PADDING_SIZE > buf->cur_end_bytes){
+				UINT32 remain = buf->cur_end_bytes - buf->offs_bytes;
+				/* Unfortunately, the FFmpeg API requires that a number of
+				 * extra bytes must be available past the end of the buffer.
+				 * The xaudio2 client probably hasn't done this, so we have to
+				 * perform a copy near the end of the buffer. */
+				TRACE("hitting end of buffer. copying %u + %u bytes into %u buffer\n",
+						remain, AV_INPUT_BUFFER_PADDING_SIZE, src->convert_bytes);
+				if(src->convert_bytes < remain + AV_INPUT_BUFFER_PADDING_SIZE){
+					src->convert_bytes = remain + AV_INPUT_BUFFER_PADDING_SIZE;
+					TRACE("buffer too small, expanding to %u\n", src->convert_bytes);
+					src->convert_buf = HeapReAlloc(GetProcessHeap(), 0, src->convert_buf, src->convert_bytes);
+				}
+				memcpy(src->convert_buf, buf->xa2buffer.pAudioData + buf->offs_bytes, remain);
+				memset(src->convert_buf + remain, 0, AV_INPUT_BUFFER_PADDING_SIZE);
+				avpkt.data = src->convert_buf;
+			}
+
+			averr = avcodec_send_packet(src->conv_ctx, &avpkt);
+			if(averr){
+				WARN("avcodec_send_packet failed: %s\n", av_err2str(averr));
+				break;
+			}
+
+			buf->offs_bytes += avpkt.size;
+			avpkt.data += avpkt.size;
+
+			/* data sent, try receive again */
+			continue;
+		}
+
+		if(averr){
+			WARN("avcodec_receive_frame failed: %s\n", av_err2str(averr));
+			return TRUE;
+		}
+
+		to_copy_bytes = src->conv_frame->nb_samples * src->conv_ctx->channels * src->submit_blocksize;
+
+		while(scratch_offs_bytes + to_copy_bytes >= src->scratch_bytes){
+			src->scratch_bytes *= 2;
+			src->scratch_buf = HeapReAlloc(GetProcessHeap(), 0, src->scratch_buf, src->scratch_bytes);
+		}
+	}
+
+	return curOffset;
+}
diff --git a/src/FAudio_internal.h b/src/FAudio_internal.h
index a2155bb..a2a9b21 100644
--- a/src/FAudio_internal.h
+++ b/src/FAudio_internal.h
@@ -445,6 +445,7 @@ DECODE_FUNC(PCM16)
 DECODE_FUNC(PCM32F)
 DECODE_FUNC(MonoMSADPCM)
 DECODE_FUNC(StereoMSADPCM)
+DECODE_FUNC(FFMPEG)
 #undef DECODE_FUNC
 
 /* Platform Functions */

From f25936201b9b5781ceb82c5339a52fc7c27ac786 Mon Sep 17 00:00:00 2001
From: Johan Smet <johan.smet@justcode.be>
Date: Thu, 11 Oct 2018 22:00:16 +0200
Subject: [PATCH 02/16] Move Andrew's work to a separate file and get it to
 compile.

---
 Makefile              |  18 +++++
 src/FAudio.c          |  76 ++++----------------
 src/FAudio_ffmpeg.c   | 161 ++++++++++++++++++++++++++++++++++++++++++
 src/FAudio_internal.c |  70 ------------------
 src/FAudio_internal.h |  11 +++
 5 files changed, 202 insertions(+), 134 deletions(-)
 create mode 100644 src/FAudio_ffmpeg.c

diff --git a/Makefile b/Makefile
index 9110368..e340797 100644
--- a/Makefile
+++ b/Makefile
@@ -61,6 +61,24 @@ ifneq ($(COM_WRAPPER), 1)
 	FAUDIOSRC += src/XNA_Song.c
 endif
 
+# FFmpeg for WMA decoding
+ifeq ($(FAUDIO_FFMPEG), 1)
+	ifdef FAUDIO_FFMPEG_PREFIX
+		FFMPEG_CFLAGS = -I$(FAUDIO_FFMPEG_PREFIX)/include 
+		FFMPEG_LDFLAGS = -L$(FAUDIO_FFMPEG_PREFIX)/lib -lavcodec -lavutil
+	else
+		FFMPEG_CFLAGS = `pkg-config libavcodec --cflags` `pkg-config libavutil --cflags`
+		FFMPEG_LDFLAGS = `pkg-config libavcodec --libs` `pkg-config libavutil --libs`
+	endif
+
+	FAUDIOSRC += src/FAudio_ffmpeg.c
+	FFMPEG_CFLAGS += -DHAVE_FFMPEG=1
+
+	CFLAGS += $(FFMPEG_CFLAGS)
+	LDFLAGS += $(FFMPEG_LDFLAGS)
+endif
+
+
 # Object code lists
 FAUDIOOBJ = $(FAUDIOSRC:%.c=%.o)
 
diff --git a/src/FAudio.c b/src/FAudio.c
index 5824865..a3482e2 100644
--- a/src/FAudio.c
+++ b/src/FAudio.c
@@ -254,72 +254,20 @@ uint32_t FAudio_CreateSourceVoice(
 		(*ppSourceVoice)->src.decode = ((*ppSourceVoice)->src.format->nChannels == 2) ?
 			FAudio_INTERNAL_DecodeStereoMSADPCM :
 			FAudio_INTERNAL_DecodeMonoMSADPCM;
-	else if((*ppSourceVoice)->src.format->wFormatTag == FAUDIO_FORMAT_WMAUDIO2)
-	{
-		enum AVCodecID cid;
-		AVCodec *codec;
-
-		(*ppSourceVoice)->src.decode = FAudio_INTERNAL_DecodeFFMPEG;
-
-		/* initialize ffmpeg state */
-		codec = avcodec_find_decoder(AV_CODEC_ID_WMAV2);
-		if(!codec){
-			FAudio_free((*ppSourceVoice)->src.format);
-			FAudio_free(*ppSourceVoice);
-			return FAUDIO_E_UNSUPPORTED_FORMAT;
-		}
-
-		src->conv_ctx = avcodec_alloc_context3(codec);
-		if(!src->conv_ctx){
-			FAudio_free((*ppSourceVoice)->src.format);
-			FAudio_free(*ppSourceVoice);
-			return FAUDIO_E_UNSUPPORTED_FORMAT;
-		}
-
-		src->conv_ctx->bit_rate = (*ppSourceVoice)->src.format->Format.nAvgBytesPerSec * 8;
-		src->conv_ctx->channels = (*ppSourceVoice)->src.format->Format.nChannels;
-		src->conv_ctx->sample_rate = (*ppSourceVoice)->src.format->Format.nSamplesPerSec;
-		src->conv_ctx->block_align = (*ppSourceVoice)->src.format->Format.nBlockAlign;
-		src->conv_ctx->bits_per_coded_sample = (*ppSourceVoice)->src.format->Format.wBitsPerSample;
-		src->conv_ctx->extradata_size = (*ppSourceVoice)->src.format->Format.cbSize;
-		src->conv_ctx->request_sample_fmt = AV_SAMPLE_FMT_FLT;
-		if((*ppSourceVoice)->src.format->Format.cbSize){
-			src->conv_ctx->extradata = HeapAlloc(GetProcessHeap(), 0, (*ppSourceVoice)->src.format->Format.cbSize + AV_INPUT_BUFFER_PADDING_SIZE);
-			memcpy(src->conv_ctx->extradata, (&(*ppSourceVoice)->src.format->Format.cbSize) + 1, (*ppSourceVoice)->src.format->Format.cbSize);
-		}else{
-			/* xWMA doesn't provide the extradata info that FFmpeg needs to
-			 * decode WMA data, so we create some fake extradata. This is taken
-			 * from <ffmpeg/libavformat/xwma.c>. */
-			src->conv_ctx->extradata_size = 6;
-			src->conv_ctx->extradata = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, AV_INPUT_BUFFER_PADDING_SIZE);
-			src->conv_ctx->extradata[4] = 31;
-		}
-
-		if(avcodec_open2(src->conv_ctx, codec, NULL) < 0){
-			FAudio_free((*ppSourceVoice)->src.conv_ctx->extradata);
-			av_free(src->conv_ctx);
-			FAudio_free((*ppSourceVoice)->src.format);
-			FAudio_free(*ppSourceVoice);
-			return AUDCLNT_E_UNSUPPORTED_FORMAT;
-		}
-
-		src->conv_frame = av_frame_alloc();
-		if(!src->conv_ctx){
-			avcodec_close(src->conv_ctx);
-			FAudio_free((*ppSourceVoice)->src.conv_ctx->extradata);
-			av_free(src->conv_ctx);
-			FAudio_free((*ppSourceVoice)->src.format);
-			FAudio_free(*ppSourceVoice);
-			return AUDCLNT_E_UNSUPPORTED_FORMAT;
-		}
-
-		if(src->conv_ctx->sample_fmt != AV_SAMPLE_FMT_FLT){
-			FAudio_assert(0 && "Got non-float format!!!");
-		}
 	}
-	else if ((*ppSourceVoice)->src.format->wFormatTag == FAUDIO_FORMAT_WMAUDIO2)
+	else if((*ppSourceVoice)->src.format->wFormatTag == FAUDIO_FORMAT_WMAUDIO2)
 	{
-		FAudio_assert(0 && "xWMA is not supported!");
+		#ifdef HAVE_FFMPEG
+			i = FAudio_FFMPEG_init(*ppSourceVoice);	
+			if (i != 0)
+			{
+				FAudio_free((*ppSourceVoice)->src.format);
+				FAudio_free(*ppSourceVoice);
+				return i;	
+			}
+		#else
+			FAudio_assert(0 && "xWMA is not supported!");
+		#endif
 	}
 	else
 	{
diff --git a/src/FAudio_ffmpeg.c b/src/FAudio_ffmpeg.c
new file mode 100644
index 0000000..458ec78
--- /dev/null
+++ b/src/FAudio_ffmpeg.c
@@ -0,0 +1,161 @@
+#ifdef HAVE_FFMPEG
+
+#include "FAudio_internal.h"
+#include <libavcodec/avcodec.h>
+
+#include <stdio.h>
+
+#define TRACE(msg,...)  fprintf(stderr, "TRACE: " msg, __VA_ARGS__)
+#define WARN(msg,...)  fprintf(stderr, "WARN:  " msg, __VA_ARGS__)
+
+uint32_t FAudio_FFMPEG_init(FAudioSourceVoice *pSourceVoice)
+{
+    AVCodecContext *conv_ctx;
+    AVFrame *conv_frame;
+	AVCodec *codec;
+
+	pSourceVoice->src.decode = FAudio_INTERNAL_DecodeFFMPEG;
+
+	/* initialize ffmpeg state */
+	codec = avcodec_find_decoder(AV_CODEC_ID_WMAV2);
+	if (!codec)
+    {
+	    return FAUDIO_E_UNSUPPORTED_FORMAT;
+	}
+
+	conv_ctx = avcodec_alloc_context3(codec);
+	if(!conv_ctx)
+    {
+        return FAUDIO_E_UNSUPPORTED_FORMAT;
+    }
+
+	conv_ctx->bit_rate = pSourceVoice->src.format->nAvgBytesPerSec * 8;
+	conv_ctx->channels = pSourceVoice->src.format->nChannels;
+	conv_ctx->sample_rate = pSourceVoice->src.format->nSamplesPerSec;
+	conv_ctx->block_align = pSourceVoice->src.format->nBlockAlign;
+	conv_ctx->bits_per_coded_sample = pSourceVoice->src.format->wBitsPerSample;
+	conv_ctx->extradata_size = pSourceVoice->src.format->cbSize;
+	conv_ctx->request_sample_fmt = AV_SAMPLE_FMT_FLT;
+
+	if (pSourceVoice->src.format->cbSize)
+    {
+		conv_ctx->extradata = (uint8_t *) FAudio_malloc(pSourceVoice->src.format->cbSize + AV_INPUT_BUFFER_PADDING_SIZE);
+		FAudio_memcpy(conv_ctx->extradata, (&pSourceVoice->src.format->cbSize) + 1, pSourceVoice->src.format->cbSize);
+	}
+    else
+    {
+		/* xWMA doesn't provide the extradata info that FFmpeg needs to
+		 * decode WMA data, so we create some fake extradata. This is taken
+		 * from <ffmpeg/libavformat/xwma.c>. */
+		conv_ctx->extradata_size = 6;
+		conv_ctx->extradata = (uint8_t *) FAudio_malloc(AV_INPUT_BUFFER_PADDING_SIZE);
+        FAudio_zero(conv_ctx->extradata, AV_INPUT_BUFFER_PADDING_SIZE);
+		conv_ctx->extradata[4] = 31;
+	}
+
+	if (avcodec_open2(conv_ctx, codec, NULL) < 0)
+    {
+		FAudio_free(pSourceVoice->src.conv_ctx->extradata);
+		av_free(conv_ctx);
+        return FAUDIO_E_UNSUPPORTED_FORMAT;
+	}
+
+	conv_frame = av_frame_alloc();
+	if (!conv_frame) {
+		avcodec_close(conv_ctx);
+		FAudio_free(conv_ctx->extradata);
+		av_free(conv_ctx);
+        return FAUDIO_E_UNSUPPORTED_FORMAT;
+	}
+
+	if(conv_ctx->sample_fmt != AV_SAMPLE_FMT_FLT)
+    {
+		FAudio_assert(0 && "Got non-float format!!!");
+	}
+
+	pSourceVoice->src.conv_ctx = conv_ctx;
+    pSourceVoice->src.conv_frame = conv_frame;
+    pSourceVoice->src.convert_bytes = 0;
+    pSourceVoice->src.convert_buf = NULL;
+    return 0;
+}
+
+void FAudio_INTERNAL_DecodeFFMPEG(
+	FAudioVoice *voice,
+	FAudioBuffer *buffer,
+	uint32_t *samples,
+	uint32_t end,
+	float *decodeCache
+) {
+	AVPacket avpkt = {0};
+	int averr;
+    uint32_t done = 0, to_copy_bytes;
+
+	avpkt.size = voice->src.format->nBlockAlign;
+	avpkt.data = (unsigned char *) buffer->pAudioData + voice->src.curBufferOffset;
+
+	while (done < *samples) 
+	{
+		averr = avcodec_receive_frame(voice->src.conv_ctx, voice->src.conv_frame);
+		if (averr == AVERROR(EAGAIN))
+        {
+			/* ffmpeg needs more data to decode */
+			avpkt.pts = avpkt.dts = AV_NOPTS_VALUE;
+
+            if (voice->src.curBufferOffset >= buffer->AudioBytes)
+            {
+				/* no more data in this buffer */
+				break;
+            }
+
+			if (voice->src.curBufferOffset + avpkt.size + AV_INPUT_BUFFER_PADDING_SIZE > buffer->AudioBytes)
+            {
+				size_t remain = buffer->AudioBytes - voice->src.curBufferOffset;
+				/* Unfortunately, the FFmpeg API requires that a number of
+				 * extra bytes must be available past the end of the buffer.
+				 * The xaudio2 client probably hasn't done this, so we have to
+				 * perform a copy near the end of the buffer. */
+				TRACE("hitting end of buffer. copying %lu + %u bytes into %lu buffer\n",
+						remain, AV_INPUT_BUFFER_PADDING_SIZE, voice->src.convert_bytes);
+
+				if(voice->src.convert_bytes < remain + AV_INPUT_BUFFER_PADDING_SIZE)
+                {
+					voice->src.convert_bytes = remain + AV_INPUT_BUFFER_PADDING_SIZE;
+					TRACE("buffer too small, expanding to %lu\n", voice->src.convert_bytes);
+                    voice->src.convert_buf = (uint8_t *) FAudio_realloc(voice->src.convert_buf, voice->src.convert_bytes);
+				}
+				FAudio_memcpy(voice->src.convert_buf, buffer->pAudioData + voice->src.curBufferOffset, remain);
+				FAudio_memset(voice->src.convert_buf + remain, 0, AV_INPUT_BUFFER_PADDING_SIZE);
+				avpkt.data = voice->src.convert_buf;
+			}
+
+			averr = avcodec_send_packet(voice->src.conv_ctx, &avpkt);
+			if (averr)
+            {
+				WARN("avcodec_send_packet failed: %d\n", averr);
+				break;
+			}
+
+			voice->src.curBufferOffset += avpkt.size;
+			avpkt.data += avpkt.size;
+
+			/* data sent, try receive again */
+			continue;
+		}
+
+		if (averr) 
+        {
+            WARN("avcodec_receive_frame failed: %d\n", averr);
+            return; 
+		}
+
+        done += voice->src.conv_frame->nb_samples;
+		to_copy_bytes = done * voice->src.conv_ctx->channels * voice->src.format->nBlockAlign;
+
+        FAudio_memcpy(decodeCache, voice->src.conv_frame->data, to_copy_bytes);
+	}
+
+    *samples = done;
+}
+
+#endif
\ No newline at end of file
diff --git a/src/FAudio_internal.c b/src/FAudio_internal.c
index a8e3428..d66ad77 100644
--- a/src/FAudio_internal.c
+++ b/src/FAudio_internal.c
@@ -1278,73 +1278,3 @@ void FAudio_INTERNAL_DecodeStereoMSADPCM(
 	*samples = done;
 }
 
-uint32_t FAudio_INTERNAL_DecodeFFMPEG(
-	FAudioVoice *voice,
-	FAudioBuffer *buffer,
-	uint32_t *samples,
-	uint32_t end,
-	float *decodeCache
-) {
-	AVPacket avpkt = {0};
-	int averr;
-
-	avpkt.size = format->nBlockAlign;
-	avpkt.data = (unsigned char *)buffer->pAudioData + curOffset;
-
-	while (samples > 0)
-	{
-		averr = avcodec_receive_frame(src->conv_ctx, src->conv_frame);
-		if(averr == AVERROR(EAGAIN)){
-			/* ffmpeg needs more data to decode */
-			avpkt.pts = avpkt.dts = AV_NOPTS_VALUE;
-
-			if(buf->offs_bytes >= buf->cur_end_bytes)
-				/* no more data in this buffer */
-				break;
-
-			if(buf->offs_bytes + avpkt.size + AV_INPUT_BUFFER_PADDING_SIZE > buf->cur_end_bytes){
-				UINT32 remain = buf->cur_end_bytes - buf->offs_bytes;
-				/* Unfortunately, the FFmpeg API requires that a number of
-				 * extra bytes must be available past the end of the buffer.
-				 * The xaudio2 client probably hasn't done this, so we have to
-				 * perform a copy near the end of the buffer. */
-				TRACE("hitting end of buffer. copying %u + %u bytes into %u buffer\n",
-						remain, AV_INPUT_BUFFER_PADDING_SIZE, src->convert_bytes);
-				if(src->convert_bytes < remain + AV_INPUT_BUFFER_PADDING_SIZE){
-					src->convert_bytes = remain + AV_INPUT_BUFFER_PADDING_SIZE;
-					TRACE("buffer too small, expanding to %u\n", src->convert_bytes);
-					src->convert_buf = HeapReAlloc(GetProcessHeap(), 0, src->convert_buf, src->convert_bytes);
-				}
-				memcpy(src->convert_buf, buf->xa2buffer.pAudioData + buf->offs_bytes, remain);
-				memset(src->convert_buf + remain, 0, AV_INPUT_BUFFER_PADDING_SIZE);
-				avpkt.data = src->convert_buf;
-			}
-
-			averr = avcodec_send_packet(src->conv_ctx, &avpkt);
-			if(averr){
-				WARN("avcodec_send_packet failed: %s\n", av_err2str(averr));
-				break;
-			}
-
-			buf->offs_bytes += avpkt.size;
-			avpkt.data += avpkt.size;
-
-			/* data sent, try receive again */
-			continue;
-		}
-
-		if(averr){
-			WARN("avcodec_receive_frame failed: %s\n", av_err2str(averr));
-			return TRUE;
-		}
-
-		to_copy_bytes = src->conv_frame->nb_samples * src->conv_ctx->channels * src->submit_blocksize;
-
-		while(scratch_offs_bytes + to_copy_bytes >= src->scratch_bytes){
-			src->scratch_bytes *= 2;
-			src->scratch_buf = HeapReAlloc(GetProcessHeap(), 0, src->scratch_buf, src->scratch_bytes);
-		}
-	}
-
-	return curOffset;
-}
diff --git a/src/FAudio_internal.h b/src/FAudio_internal.h
index a2a9b21..04ce1f6 100644
--- a/src/FAudio_internal.h
+++ b/src/FAudio_internal.h
@@ -313,6 +313,14 @@ struct FAudioVoice
 			uint64_t curBufferOffsetDec;
 			uint32_t curBufferOffset;
 
+			/* FFmpeg */
+			#ifdef HAVE_FFMPEG
+				struct AVCodecContext *conv_ctx;
+				struct AVFrame *conv_frame;
+				size_t convert_bytes;
+				uint8_t *convert_buf;
+			#endif /* HAVE_FFMPEG*/
+
 			/* Read-only */
 			float maxFreqRatio;
 			FAudioWaveFormatEx *format;
@@ -477,6 +485,9 @@ uint32_t FAudio_PlatformResample(
 	uint32_t outLen
 );
 
+/* FFmpeg */
+uint32_t FAudio_FFMPEG_init(FAudioSourceVoice *pSourceVoice);
+
 /* Threading */
 
 FAudioThread FAudio_PlatformCreateThread(

From 001d145148a64409039e1a34a4e58e808f0dbe5f Mon Sep 17 00:00:00 2001
From: Johan Smet <johan.smet@justcode.be>
Date: Fri, 12 Oct 2018 18:25:37 +0200
Subject: [PATCH 03/16] Planar float format's are also okay

---
 src/FAudio_ffmpeg.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/FAudio_ffmpeg.c b/src/FAudio_ffmpeg.c
index 458ec78..50cc3ab 100644
--- a/src/FAudio_ffmpeg.c
+++ b/src/FAudio_ffmpeg.c
@@ -68,7 +68,7 @@ uint32_t FAudio_FFMPEG_init(FAudioSourceVoice *pSourceVoice)
         return FAUDIO_E_UNSUPPORTED_FORMAT;
 	}
 
-	if(conv_ctx->sample_fmt != AV_SAMPLE_FMT_FLT)
+	if(conv_ctx->sample_fmt != AV_SAMPLE_FMT_FLT && conv_ctx->sample_fmt != AV_SAMPLE_FMT_FLTP)
     {
 		FAudio_assert(0 && "Got non-float format!!!");
 	}

From 8091f87a51f6fd6f5d20f624848b7d7dbf98dd38 Mon Sep 17 00:00:00 2001
From: Johan Smet <johan.smet@justcode.be>
Date: Fri, 12 Oct 2018 18:26:35 +0200
Subject: [PATCH 04/16] Buffer the WMA packet decoded by FFmpeg and give it to
 FAudio piece by piece

---
 src/FAudio_ffmpeg.c   | 83 ++++++++++++++++++++++++++++++++++++-------
 src/FAudio_internal.h |  5 +++
 2 files changed, 76 insertions(+), 12 deletions(-)

diff --git a/src/FAudio_ffmpeg.c b/src/FAudio_ffmpeg.c
index 50cc3ab..0dd7b2a 100644
--- a/src/FAudio_ffmpeg.c
+++ b/src/FAudio_ffmpeg.c
@@ -80,21 +80,28 @@ uint32_t FAudio_FFMPEG_init(FAudioSourceVoice *pSourceVoice)
     return 0;
 }
 
-void FAudio_INTERNAL_DecodeFFMPEG(
-	FAudioVoice *voice,
-	FAudioBuffer *buffer,
-	uint32_t *samples,
-	uint32_t end,
-	float *decodeCache
-) {
+void FAudio_INTERNAL_ResizeConvertCache(FAudioVoice *voice, uint32_t samples)
+{
+	if (samples > voice->src.convertCapacity)
+	{
+		voice->src.convertCapacity = samples;
+		voice->src.convertCache = (float*) FAudio_realloc(
+			voice->src.convertCache,
+			sizeof(float) * voice->src.convertCapacity
+		);
+	}
+}
+
+void FAudio_INTERNAL_FillConvertCache(FAudioVoice *voice, FAudioBuffer *buffer)
+{
 	AVPacket avpkt = {0};
 	int averr;
-    uint32_t done = 0, to_copy_bytes;
+	uint32_t total_samples;
 
 	avpkt.size = voice->src.format->nBlockAlign;
 	avpkt.data = (unsigned char *) buffer->pAudioData + voice->src.curBufferOffset;
 
-	while (done < *samples) 
+	for(;;)
 	{
 		averr = avcodec_receive_frame(voice->src.conv_ctx, voice->src.conv_frame);
 		if (averr == AVERROR(EAGAIN))
@@ -148,11 +155,63 @@ void FAudio_INTERNAL_DecodeFFMPEG(
             WARN("avcodec_receive_frame failed: %d\n", averr);
             return; 
 		}
+		else
+		{
+			break;
+		}
+	}
+
+    total_samples = voice->src.conv_frame->nb_samples * voice->src.conv_ctx->channels;
+
+	FAudio_INTERNAL_ResizeConvertCache(voice, total_samples);
+
+	if (av_sample_fmt_is_planar(voice->src.conv_ctx->sample_fmt))
+	{
+		int32_t s, c;
+		uint8_t **src = voice->src.conv_frame->data;
+		uint32_t *dst = (uint32_t *) voice->src.convertCache;
 
-        done += voice->src.conv_frame->nb_samples;
-		to_copy_bytes = done * voice->src.conv_ctx->channels * voice->src.format->nBlockAlign;
+		for(s = 0; s < voice->src.conv_frame->nb_samples; ++s)
+			for(c = 0; c < voice->src.conv_ctx->channels; ++c)
+				*dst++ = ((uint32_t*)(src[c]))[s];
+	}
+	else
+	{
+		FAudio_memcpy(voice->src.convertCache, voice->src.conv_frame->data[0], total_samples * sizeof(float));
+	}
+
+	voice->src.convertSamples = total_samples;
+	voice->src.convertOffset = 0;
+}
+
+void FAudio_INTERNAL_DecodeFFMPEG(
+	FAudioVoice *voice,
+	FAudioBuffer *buffer,
+	uint32_t *samples,
+	uint32_t end,
+	float *decodeCache
+) {
+    uint32_t done = 0, available, todo;
+
+	while (done < *samples) 
+	{	
+		available = (voice->src.convertSamples - voice->src.convertOffset) / voice->src.format->nChannels;
+
+		if (available <= 0) 
+		{
+			FAudio_INTERNAL_FillConvertCache(voice, buffer);
+			available = (voice->src.convertSamples - voice->src.convertOffset) / voice->src.format->nChannels;
+
+			if (available <= 0)
+			{
+				break;
+			}
+		}
 
-        FAudio_memcpy(decodeCache, voice->src.conv_frame->data, to_copy_bytes);
+		todo = FAudio_min(available, *samples - done);
+		FAudio_memcpy(decodeCache + (done * voice->src.format->nChannels), voice->src.convertCache + voice->src.convertOffset, todo * voice->src.format->nChannels * sizeof(float));
+		done += todo;
+		voice->src.convertOffset += todo * voice->src.format->nChannels;
 	}
 
     *samples = done;
diff --git a/src/FAudio_internal.h b/src/FAudio_internal.h
index 04ce1f6..6e15044 100644
--- a/src/FAudio_internal.h
+++ b/src/FAudio_internal.h
@@ -319,6 +319,11 @@ struct FAudioVoice
 				struct AVFrame *conv_frame;
 				size_t convert_bytes;
 				uint8_t *convert_buf;
+
+				uint32_t convertCapacity;
+				uint32_t convertSamples;
+				uint32_t convertOffset;
+				float *convertCache;
 			#endif /* HAVE_FFMPEG*/
 
 			/* Read-only */

From 11e7a45b11a4c54acb1c6a68318c2884055267cd Mon Sep 17 00:00:00 2001
From: Johan Smet <johan.smet@justcode.be>
Date: Fri, 12 Oct 2018 22:58:19 +0200
Subject: [PATCH 05/16] SubmitSourceBuffer: require pBufferWMA for WMA
 formatted voices

---
 src/FAudio.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/FAudio.c b/src/FAudio.c
index a3482e2..751cbbc 100644
--- a/src/FAudio.c
+++ b/src/FAudio.c
@@ -1378,7 +1378,8 @@ uint32_t FAudioSourceVoice_SubmitSourceBuffer(
 	uint32_t playBegin, playLength, loopBegin, loopLength;
 	FAudioBufferEntry *entry, *list;
 	FAudio_assert(voice->type == FAUDIO_VOICE_SOURCE);
-	FAudio_assert(pBufferWMA == NULL);
+	FAudio_assert((voice->src.format->wFormatTag == FAUDIO_FORMAT_WMAUDIO2 && pBufferWMA != NULL) ||
+				  (voice->src.format->wFormatTag != FAUDIO_FORMAT_WMAUDIO2 && pBufferWMA == NULL));
 
 	/* Start off with whatever they just sent us... */
 	playBegin = pBuffer->PlayBegin;

From f54273e6cd8e584dae018a4b24432f9a5bdee253 Mon Sep 17 00:00:00 2001
From: Johan Smet <johan.smet@justcode.be>
Date: Sun, 14 Oct 2018 21:17:06 +0200
Subject: [PATCH 06/16]  WAVEFORMATEXTENSIBLE is used by games to create
 WMAUDIO2 voices

---
 src/FAudio.c        | 42 ++++++++++++++++++++++++------------------
 src/FAudio_ffmpeg.c |  9 ++++++---
 2 files changed, 30 insertions(+), 21 deletions(-)

diff --git a/src/FAudio.c b/src/FAudio.c
index 751cbbc..a192501 100644
--- a/src/FAudio.c
+++ b/src/FAudio.c
@@ -46,6 +46,7 @@
 MAKE_SUBFORMAT_GUID(PCM, 1);
 MAKE_SUBFORMAT_GUID(ADPCM, 2);
 MAKE_SUBFORMAT_GUID(IEEE_FLOAT, 3);
+MAKE_SUBFORMAT_GUID(WMAUDIO2, FAUDIO_FORMAT_WMAUDIO2);
 #undef MAKE_SUBFORMAT_GUID
 
 /* FAudio Interface */
@@ -184,8 +185,9 @@ uint32_t FAudio_CreateSourceVoice(
 	FAudio_assert(MaxFrequencyRatio <= FAUDIO_MAX_FREQ_RATIO);
 	(*ppSourceVoice)->src.maxFreqRatio = MaxFrequencyRatio;
 
-	if (	pSourceFormat->wFormatTag == FAUDIO_FORMAT_PCM ||
-		pSourceFormat->wFormatTag == FAUDIO_FORMAT_IEEE_FLOAT	)
+	if (pSourceFormat->wFormatTag == FAUDIO_FORMAT_PCM ||
+		pSourceFormat->wFormatTag == FAUDIO_FORMAT_IEEE_FLOAT ||
+		pSourceFormat->wFormatTag == FAUDIO_FORMAT_WMAUDIO2) 
 	{
 		FAudioWaveFormatExtensible *fmtex = (FAudioWaveFormatExtensible*) FAudio_malloc(
 			sizeof(FAudioWaveFormatExtensible)
@@ -208,6 +210,10 @@ uint32_t FAudio_CreateSourceVoice(
 		{
 			FAudio_memcpy(&fmtex->SubFormat, &DATAFORMAT_SUBTYPE_IEEE_FLOAT, sizeof(FAudioGUID));
 		}
+		else if (pSourceFormat->wFormatTag == FAUDIO_FORMAT_WMAUDIO2)
+		{
+			FAudio_memcpy(&fmtex->SubFormat, &DATAFORMAT_SUBTYPE_WMAUDIO2, sizeof(FAudioGUID));
+		}
 		(*ppSourceVoice)->src.format = &fmtex->Format;
 	}
 	else
@@ -244,6 +250,20 @@ uint32_t FAudio_CreateSourceVoice(
 		{
 			(*ppSourceVoice)->src.decode = FAudio_INTERNAL_DecodePCM32F;
 		}
+		else if (FAudio_memcmp(&fmtex->SubFormat, &DATAFORMAT_SUBTYPE_WMAUDIO2, sizeof(FAudioGUID)) == 0)
+		{
+			#ifdef HAVE_FFMPEG
+				i = FAudio_FFMPEG_init(*ppSourceVoice);	
+				if (i != 0)
+				{
+					FAudio_free((*ppSourceVoice)->src.format);
+					FAudio_free(*ppSourceVoice);
+					return i;	
+				}
+			#else
+				FAudio_assert(0 && "xWMA is not supported!");
+			#endif
+		}
 		else
 		{
 			FAudio_assert(0 && "Unsupported WAVEFORMATEXTENSIBLE subtype!");
@@ -255,20 +275,6 @@ uint32_t FAudio_CreateSourceVoice(
 			FAudio_INTERNAL_DecodeStereoMSADPCM :
 			FAudio_INTERNAL_DecodeMonoMSADPCM;
 	}
-	else if((*ppSourceVoice)->src.format->wFormatTag == FAUDIO_FORMAT_WMAUDIO2)
-	{
-		#ifdef HAVE_FFMPEG
-			i = FAudio_FFMPEG_init(*ppSourceVoice);	
-			if (i != 0)
-			{
-				FAudio_free((*ppSourceVoice)->src.format);
-				FAudio_free(*ppSourceVoice);
-				return i;	
-			}
-		#else
-			FAudio_assert(0 && "xWMA is not supported!");
-		#endif
-	}
 	else
 	{
 		FAudio_assert(0 && "Unsupported format tag!");
@@ -1378,8 +1384,8 @@ uint32_t FAudioSourceVoice_SubmitSourceBuffer(
 	uint32_t playBegin, playLength, loopBegin, loopLength;
 	FAudioBufferEntry *entry, *list;
 	FAudio_assert(voice->type == FAUDIO_VOICE_SOURCE);
-	FAudio_assert((voice->src.format->wFormatTag == FAUDIO_FORMAT_WMAUDIO2 && pBufferWMA != NULL) ||
-				  (voice->src.format->wFormatTag != FAUDIO_FORMAT_WMAUDIO2 && pBufferWMA == NULL));
+	FAudio_assert((voice->src.conv_ctx != NULL && pBufferWMA != NULL) ||
+				  (voice->src.conv_ctx == NULL && pBufferWMA == NULL));
 
 	/* Start off with whatever they just sent us... */
 	playBegin = pBuffer->PlayBegin;
diff --git a/src/FAudio_ffmpeg.c b/src/FAudio_ffmpeg.c
index 0dd7b2a..5601ba6 100644
--- a/src/FAudio_ffmpeg.c
+++ b/src/FAudio_ffmpeg.c
@@ -37,10 +37,13 @@ uint32_t FAudio_FFMPEG_init(FAudioSourceVoice *pSourceVoice)
 	conv_ctx->extradata_size = pSourceVoice->src.format->cbSize;
 	conv_ctx->request_sample_fmt = AV_SAMPLE_FMT_FLT;
 
-	if (pSourceVoice->src.format->cbSize)
+	/* pSourceVoice->src.format is actually pointing to a WAVEFORMATEXTENSIBLE struct, not just a WAVEFORMATEX struct.
+	   That means there's always at least 22 bytes following the struct, I assume the WMA data is behind that.
+	   XXX-JS Need to verify! */
+	if (pSourceVoice->src.format->cbSize > 22)
     {
-		conv_ctx->extradata = (uint8_t *) FAudio_malloc(pSourceVoice->src.format->cbSize + AV_INPUT_BUFFER_PADDING_SIZE);
-		FAudio_memcpy(conv_ctx->extradata, (&pSourceVoice->src.format->cbSize) + 1, pSourceVoice->src.format->cbSize);
+		conv_ctx->extradata = (uint8_t *) FAudio_malloc(pSourceVoice->src.format->cbSize + AV_INPUT_BUFFER_PADDING_SIZE - 22);
+		FAudio_memcpy(conv_ctx->extradata, (&pSourceVoice->src.format->cbSize) + 23, pSourceVoice->src.format->cbSize - 22);
 	}
     else
     {

From a42a9e3bd2c9a010439fe45015f09bec26408543 Mon Sep 17 00:00:00 2001
From: Johan Smet <johan.smet@justcode.be>
Date: Mon, 15 Oct 2018 22:25:26 +0200
Subject: [PATCH 07/16] Move FFmpeg variables from FAudioVoice to private
 struct

---
 src/FAudio.c          |   4 +-
 src/FAudio_ffmpeg.c   | 139 ++++++++++++++++++++++++------------------
 src/FAudio_internal.h |  10 +--
 3 files changed, 83 insertions(+), 70 deletions(-)

diff --git a/src/FAudio.c b/src/FAudio.c
index a192501..d593b45 100644
--- a/src/FAudio.c
+++ b/src/FAudio.c
@@ -1384,8 +1384,8 @@ uint32_t FAudioSourceVoice_SubmitSourceBuffer(
 	uint32_t playBegin, playLength, loopBegin, loopLength;
 	FAudioBufferEntry *entry, *list;
 	FAudio_assert(voice->type == FAUDIO_VOICE_SOURCE);
-	FAudio_assert((voice->src.conv_ctx != NULL && pBufferWMA != NULL) ||
-				  (voice->src.conv_ctx == NULL && pBufferWMA == NULL));
+	FAudio_assert((voice->src.ffmpeg != NULL && pBufferWMA != NULL) ||
+				  (voice->src.ffmpeg == NULL && pBufferWMA == NULL));
 
 	/* Start off with whatever they just sent us... */
 	playBegin = pBuffer->PlayBegin;
diff --git a/src/FAudio_ffmpeg.c b/src/FAudio_ffmpeg.c
index 5601ba6..42d2d07 100644
--- a/src/FAudio_ffmpeg.c
+++ b/src/FAudio_ffmpeg.c
@@ -3,15 +3,30 @@
 #include "FAudio_internal.h"
 #include <libavcodec/avcodec.h>
 
-#include <stdio.h>
+typedef struct FAudioFFmpeg 
+{
+	AVCodecContext *av_ctx;
+	AVFrame *av_frame;
+
+	/* buffer used to decode the last frame */
+	size_t paddingBytes;
+	uint8_t *paddingBuffer;
 
+	/* buffer to receive an entire decoded frame */
+	uint32_t convertCapacity;
+	uint32_t convertSamples;
+	uint32_t convertOffset;
+	float *convertCache;
+} FAudioFFmpeg;
+
+#include <stdio.h>
 #define TRACE(msg,...)  fprintf(stderr, "TRACE: " msg, __VA_ARGS__)
 #define WARN(msg,...)  fprintf(stderr, "WARN:  " msg, __VA_ARGS__)
 
 uint32_t FAudio_FFMPEG_init(FAudioSourceVoice *pSourceVoice)
 {
-    AVCodecContext *conv_ctx;
-    AVFrame *conv_frame;
+    AVCodecContext *av_ctx;
+    AVFrame *av_frame;
 	AVCodec *codec;
 
 	pSourceVoice->src.decode = FAudio_INTERNAL_DecodeFFMPEG;
@@ -23,80 +38,82 @@ uint32_t FAudio_FFMPEG_init(FAudioSourceVoice *pSourceVoice)
 	    return FAUDIO_E_UNSUPPORTED_FORMAT;
 	}
 
-	conv_ctx = avcodec_alloc_context3(codec);
-	if(!conv_ctx)
+	av_ctx = avcodec_alloc_context3(codec);
+	if(!av_ctx)
     {
         return FAUDIO_E_UNSUPPORTED_FORMAT;
     }
 
-	conv_ctx->bit_rate = pSourceVoice->src.format->nAvgBytesPerSec * 8;
-	conv_ctx->channels = pSourceVoice->src.format->nChannels;
-	conv_ctx->sample_rate = pSourceVoice->src.format->nSamplesPerSec;
-	conv_ctx->block_align = pSourceVoice->src.format->nBlockAlign;
-	conv_ctx->bits_per_coded_sample = pSourceVoice->src.format->wBitsPerSample;
-	conv_ctx->extradata_size = pSourceVoice->src.format->cbSize;
-	conv_ctx->request_sample_fmt = AV_SAMPLE_FMT_FLT;
+	av_ctx->bit_rate = pSourceVoice->src.format->nAvgBytesPerSec * 8;
+	av_ctx->channels = pSourceVoice->src.format->nChannels;
+	av_ctx->sample_rate = pSourceVoice->src.format->nSamplesPerSec;
+	av_ctx->block_align = pSourceVoice->src.format->nBlockAlign;
+	av_ctx->bits_per_coded_sample = pSourceVoice->src.format->wBitsPerSample;
+	av_ctx->extradata_size = pSourceVoice->src.format->cbSize;
+	av_ctx->request_sample_fmt = AV_SAMPLE_FMT_FLT;
 
 	/* pSourceVoice->src.format is actually pointing to a WAVEFORMATEXTENSIBLE struct, not just a WAVEFORMATEX struct.
 	   That means there's always at least 22 bytes following the struct, I assume the WMA data is behind that.
 	   XXX-JS Need to verify! */
 	if (pSourceVoice->src.format->cbSize > 22)
     {
-		conv_ctx->extradata = (uint8_t *) FAudio_malloc(pSourceVoice->src.format->cbSize + AV_INPUT_BUFFER_PADDING_SIZE - 22);
-		FAudio_memcpy(conv_ctx->extradata, (&pSourceVoice->src.format->cbSize) + 23, pSourceVoice->src.format->cbSize - 22);
+		av_ctx->extradata = (uint8_t *) FAudio_malloc(pSourceVoice->src.format->cbSize + AV_INPUT_BUFFER_PADDING_SIZE - 22);
+		FAudio_memcpy(av_ctx->extradata, (&pSourceVoice->src.format->cbSize) + 23, pSourceVoice->src.format->cbSize - 22);
 	}
     else
     {
 		/* xWMA doesn't provide the extradata info that FFmpeg needs to
 		 * decode WMA data, so we create some fake extradata. This is taken
 		 * from <ffmpeg/libavformat/xwma.c>. */
-		conv_ctx->extradata_size = 6;
-		conv_ctx->extradata = (uint8_t *) FAudio_malloc(AV_INPUT_BUFFER_PADDING_SIZE);
-        FAudio_zero(conv_ctx->extradata, AV_INPUT_BUFFER_PADDING_SIZE);
-		conv_ctx->extradata[4] = 31;
+		av_ctx->extradata_size = 6;
+		av_ctx->extradata = (uint8_t *) FAudio_malloc(AV_INPUT_BUFFER_PADDING_SIZE);
+        FAudio_zero(av_ctx->extradata, AV_INPUT_BUFFER_PADDING_SIZE);
+		av_ctx->extradata[4] = 31;
 	}
 
-	if (avcodec_open2(conv_ctx, codec, NULL) < 0)
+	if (avcodec_open2(av_ctx, codec, NULL) < 0)
     {
-		FAudio_free(pSourceVoice->src.conv_ctx->extradata);
-		av_free(conv_ctx);
+		FAudio_free(av_ctx->extradata);
+		av_free(av_ctx);
         return FAUDIO_E_UNSUPPORTED_FORMAT;
 	}
 
-	conv_frame = av_frame_alloc();
-	if (!conv_frame) {
-		avcodec_close(conv_ctx);
-		FAudio_free(conv_ctx->extradata);
-		av_free(conv_ctx);
+	av_frame = av_frame_alloc();
+	if (!av_frame) {
+		avcodec_close(av_ctx);
+		FAudio_free(av_ctx->extradata);
+		av_free(av_ctx);
         return FAUDIO_E_UNSUPPORTED_FORMAT;
 	}
 
-	if(conv_ctx->sample_fmt != AV_SAMPLE_FMT_FLT && conv_ctx->sample_fmt != AV_SAMPLE_FMT_FLTP)
+	if(av_ctx->sample_fmt != AV_SAMPLE_FMT_FLT && av_ctx->sample_fmt != AV_SAMPLE_FMT_FLTP)
     {
 		FAudio_assert(0 && "Got non-float format!!!");
 	}
 
-	pSourceVoice->src.conv_ctx = conv_ctx;
-    pSourceVoice->src.conv_frame = conv_frame;
-    pSourceVoice->src.convert_bytes = 0;
-    pSourceVoice->src.convert_buf = NULL;
+	pSourceVoice->src.ffmpeg = (FAudioFFmpeg *) FAudio_malloc(sizeof(FAudioFFmpeg));
+	FAudio_zero(pSourceVoice->src.ffmpeg, sizeof(FAudioFFmpeg));
+
+	pSourceVoice->src.ffmpeg->av_ctx = av_ctx;
+    pSourceVoice->src.ffmpeg->av_frame = av_frame;
     return 0;
 }
 
 void FAudio_INTERNAL_ResizeConvertCache(FAudioVoice *voice, uint32_t samples)
 {
-	if (samples > voice->src.convertCapacity)
+	if (samples > voice->src.ffmpeg->convertCapacity)
 	{
-		voice->src.convertCapacity = samples;
-		voice->src.convertCache = (float*) FAudio_realloc(
-			voice->src.convertCache,
-			sizeof(float) * voice->src.convertCapacity
+		voice->src.ffmpeg->convertCapacity = samples;
+		voice->src.ffmpeg->convertCache = (float*) FAudio_realloc(
+			voice->src.ffmpeg->convertCache,
+			sizeof(float) * voice->src.ffmpeg->convertCapacity
 		);
 	}
 }
 
 void FAudio_INTERNAL_FillConvertCache(FAudioVoice *voice, FAudioBuffer *buffer)
 {
+	FAudioFFmpeg *ffmpeg = voice->src.ffmpeg;
 	AVPacket avpkt = {0};
 	int averr;
 	uint32_t total_samples;
@@ -106,7 +123,7 @@ void FAudio_INTERNAL_FillConvertCache(FAudioVoice *voice, FAudioBuffer *buffer)
 
 	for(;;)
 	{
-		averr = avcodec_receive_frame(voice->src.conv_ctx, voice->src.conv_frame);
+		averr = avcodec_receive_frame(ffmpeg->av_ctx, ffmpeg->av_frame);
 		if (averr == AVERROR(EAGAIN))
         {
 			/* ffmpeg needs more data to decode */
@@ -126,20 +143,23 @@ void FAudio_INTERNAL_FillConvertCache(FAudioVoice *voice, FAudioBuffer *buffer)
 				 * The xaudio2 client probably hasn't done this, so we have to
 				 * perform a copy near the end of the buffer. */
 				TRACE("hitting end of buffer. copying %lu + %u bytes into %lu buffer\n",
-						remain, AV_INPUT_BUFFER_PADDING_SIZE, voice->src.convert_bytes);
+						remain, AV_INPUT_BUFFER_PADDING_SIZE, ffmpeg->paddingBytes);
 
-				if(voice->src.convert_bytes < remain + AV_INPUT_BUFFER_PADDING_SIZE)
+				if(ffmpeg->paddingBytes < remain + AV_INPUT_BUFFER_PADDING_SIZE)
                 {
-					voice->src.convert_bytes = remain + AV_INPUT_BUFFER_PADDING_SIZE;
-					TRACE("buffer too small, expanding to %lu\n", voice->src.convert_bytes);
-                    voice->src.convert_buf = (uint8_t *) FAudio_realloc(voice->src.convert_buf, voice->src.convert_bytes);
+					ffmpeg->paddingBytes = remain + AV_INPUT_BUFFER_PADDING_SIZE;
+					TRACE("buffer too small, expanding to %lu\n", ffmpeg->paddingBytes);
+                    ffmpeg->paddingBuffer = (uint8_t *) FAudio_realloc(
+						ffmpeg->paddingBuffer, 
+						ffmpeg->paddingBytes
+					);
 				}
-				FAudio_memcpy(voice->src.convert_buf, buffer->pAudioData + voice->src.curBufferOffset, remain);
-				FAudio_memset(voice->src.convert_buf + remain, 0, AV_INPUT_BUFFER_PADDING_SIZE);
-				avpkt.data = voice->src.convert_buf;
+				FAudio_memcpy(ffmpeg->paddingBuffer, buffer->pAudioData + voice->src.curBufferOffset, remain);
+				FAudio_memset(ffmpeg->paddingBuffer + remain, 0, AV_INPUT_BUFFER_PADDING_SIZE);
+				avpkt.data = ffmpeg->paddingBuffer;
 			}
 
-			averr = avcodec_send_packet(voice->src.conv_ctx, &avpkt);
+			averr = avcodec_send_packet(ffmpeg->av_ctx, &avpkt);
 			if (averr)
             {
 				WARN("avcodec_send_packet failed: %d\n", averr);
@@ -164,27 +184,27 @@ void FAudio_INTERNAL_FillConvertCache(FAudioVoice *voice, FAudioBuffer *buffer)
 		}
 	}
 
-    total_samples = voice->src.conv_frame->nb_samples * voice->src.conv_ctx->channels;
+    total_samples = ffmpeg->av_frame->nb_samples * ffmpeg->av_ctx->channels;
 
 	FAudio_INTERNAL_ResizeConvertCache(voice, total_samples);
 
-	if (av_sample_fmt_is_planar(voice->src.conv_ctx->sample_fmt))
+	if (av_sample_fmt_is_planar(ffmpeg->av_ctx->sample_fmt))
 	{
 		int32_t s, c;
-		uint8_t **src = voice->src.conv_frame->data;
-		uint32_t *dst = (uint32_t *) voice->src.convertCache;
+		uint8_t **src = ffmpeg->av_frame->data;
+		uint32_t *dst = (uint32_t *) ffmpeg->convertCache;
 
-		for(s = 0; s < voice->src.conv_frame->nb_samples; ++s)
-			for(c = 0; c < voice->src.conv_ctx->channels; ++c)
+		for(s = 0; s < ffmpeg->av_frame->nb_samples; ++s)
+			for(c = 0; c < ffmpeg->av_ctx->channels; ++c)
 				*dst++ = ((uint32_t*)(src[c]))[s];
 	}
 	else
 	{
-		FAudio_memcpy(voice->src.convertCache, voice->src.conv_frame->data[0], total_samples * sizeof(float));
+		FAudio_memcpy(ffmpeg->convertCache, ffmpeg->av_frame->data[0], total_samples * sizeof(float));
 	}
 
-	voice->src.convertSamples = total_samples;
-	voice->src.convertOffset = 0;
+	ffmpeg->convertSamples = total_samples;
+	ffmpeg->convertOffset = 0;
 }
 
 void FAudio_INTERNAL_DecodeFFMPEG(
@@ -194,16 +214,17 @@ void FAudio_INTERNAL_DecodeFFMPEG(
 	uint32_t end,
 	float *decodeCache
 ) {
+	FAudioFFmpeg *ffmpeg = voice->src.ffmpeg;
     uint32_t done = 0, available, todo;
 
 	while (done < *samples) 
 	{	
-		available = (voice->src.convertSamples - voice->src.convertOffset) / voice->src.format->nChannels;
+		available = (ffmpeg->convertSamples - ffmpeg->convertOffset) / voice->src.format->nChannels;
 
 		if (available <= 0) 
 		{
 			FAudio_INTERNAL_FillConvertCache(voice, buffer);
-			available = (voice->src.convertSamples - voice->src.convertOffset) / voice->src.format->nChannels;
+			available = (ffmpeg->convertSamples - ffmpeg->convertOffset) / voice->src.format->nChannels;
 
 			if (available <= 0)
 			{
@@ -212,9 +233,9 @@ void FAudio_INTERNAL_DecodeFFMPEG(
 		}
 
 		todo = FAudio_min(available, *samples - done);
-		FAudio_memcpy(decodeCache + (done * voice->src.format->nChannels), voice->src.convertCache + voice->src.convertOffset, todo * voice->src.format->nChannels * sizeof(float));
+		FAudio_memcpy(decodeCache + (done * voice->src.format->nChannels), ffmpeg->convertCache + ffmpeg->convertOffset, todo * voice->src.format->nChannels * sizeof(float));
 		done += todo;
-		voice->src.convertOffset += todo * voice->src.format->nChannels;
+		ffmpeg->convertOffset += todo * voice->src.format->nChannels;
 	}
 
     *samples = done;
diff --git a/src/FAudio_internal.h b/src/FAudio_internal.h
index 6e15044..e82efac 100644
--- a/src/FAudio_internal.h
+++ b/src/FAudio_internal.h
@@ -315,15 +315,7 @@ struct FAudioVoice
 
 			/* FFmpeg */
 			#ifdef HAVE_FFMPEG
-				struct AVCodecContext *conv_ctx;
-				struct AVFrame *conv_frame;
-				size_t convert_bytes;
-				uint8_t *convert_buf;
-
-				uint32_t convertCapacity;
-				uint32_t convertSamples;
-				uint32_t convertOffset;
-				float *convertCache;
+				struct FAudioFFmpeg *ffmpeg;
 			#endif /* HAVE_FFMPEG*/
 
 			/* Read-only */

From eea5975fab61098d94eac26edb541eab4713f59a Mon Sep 17 00:00:00 2001
From: Johan Smet <johan.smet@justcode.be>
Date: Mon, 15 Oct 2018 22:35:22 +0200
Subject: [PATCH 08/16] Don't use voice->src.curBufferOffset to store position
 in encoded stream.

---
 src/FAudio_ffmpeg.c | 16 +++++++++-------
 1 file changed, 9 insertions(+), 7 deletions(-)

diff --git a/src/FAudio_ffmpeg.c b/src/FAudio_ffmpeg.c
index 42d2d07..cc6b892 100644
--- a/src/FAudio_ffmpeg.c
+++ b/src/FAudio_ffmpeg.c
@@ -8,6 +8,8 @@ typedef struct FAudioFFmpeg
 	AVCodecContext *av_ctx;
 	AVFrame *av_frame;
 
+	uint32_t encOffset;	/* current position in encoded stream (in bytes) */
+
 	/* buffer used to decode the last frame */
 	size_t paddingBytes;
 	uint8_t *paddingBuffer;
@@ -119,7 +121,7 @@ void FAudio_INTERNAL_FillConvertCache(FAudioVoice *voice, FAudioBuffer *buffer)
 	uint32_t total_samples;
 
 	avpkt.size = voice->src.format->nBlockAlign;
-	avpkt.data = (unsigned char *) buffer->pAudioData + voice->src.curBufferOffset;
+	avpkt.data = (unsigned char *) buffer->pAudioData + ffmpeg->encOffset;
 
 	for(;;)
 	{
@@ -129,15 +131,15 @@ void FAudio_INTERNAL_FillConvertCache(FAudioVoice *voice, FAudioBuffer *buffer)
 			/* ffmpeg needs more data to decode */
 			avpkt.pts = avpkt.dts = AV_NOPTS_VALUE;
 
-            if (voice->src.curBufferOffset >= buffer->AudioBytes)
+            if (ffmpeg->encOffset >= buffer->AudioBytes)
             {
 				/* no more data in this buffer */
 				break;
             }
 
-			if (voice->src.curBufferOffset + avpkt.size + AV_INPUT_BUFFER_PADDING_SIZE > buffer->AudioBytes)
+			if (ffmpeg->encOffset + avpkt.size + AV_INPUT_BUFFER_PADDING_SIZE > buffer->AudioBytes)
             {
-				size_t remain = buffer->AudioBytes - voice->src.curBufferOffset;
+				size_t remain = buffer->AudioBytes - ffmpeg->encOffset;
 				/* Unfortunately, the FFmpeg API requires that a number of
 				 * extra bytes must be available past the end of the buffer.
 				 * The xaudio2 client probably hasn't done this, so we have to
@@ -145,7 +147,7 @@ void FAudio_INTERNAL_FillConvertCache(FAudioVoice *voice, FAudioBuffer *buffer)
 				TRACE("hitting end of buffer. copying %lu + %u bytes into %lu buffer\n",
 						remain, AV_INPUT_BUFFER_PADDING_SIZE, ffmpeg->paddingBytes);
 
-				if(ffmpeg->paddingBytes < remain + AV_INPUT_BUFFER_PADDING_SIZE)
+				if (ffmpeg->paddingBytes < remain + AV_INPUT_BUFFER_PADDING_SIZE)
                 {
 					ffmpeg->paddingBytes = remain + AV_INPUT_BUFFER_PADDING_SIZE;
 					TRACE("buffer too small, expanding to %lu\n", ffmpeg->paddingBytes);
@@ -154,7 +156,7 @@ void FAudio_INTERNAL_FillConvertCache(FAudioVoice *voice, FAudioBuffer *buffer)
 						ffmpeg->paddingBytes
 					);
 				}
-				FAudio_memcpy(ffmpeg->paddingBuffer, buffer->pAudioData + voice->src.curBufferOffset, remain);
+				FAudio_memcpy(ffmpeg->paddingBuffer, buffer->pAudioData + ffmpeg->encOffset, remain);
 				FAudio_memset(ffmpeg->paddingBuffer + remain, 0, AV_INPUT_BUFFER_PADDING_SIZE);
 				avpkt.data = ffmpeg->paddingBuffer;
 			}
@@ -166,7 +168,7 @@ void FAudio_INTERNAL_FillConvertCache(FAudioVoice *voice, FAudioBuffer *buffer)
 				break;
 			}
 
-			voice->src.curBufferOffset += avpkt.size;
+			ffmpeg->encOffset += avpkt.size;
 			avpkt.data += avpkt.size;
 
 			/* data sent, try receive again */

From 962e460e28659065eced30c3a2298a9326b7df35 Mon Sep 17 00:00:00 2001
From: Johan Smet <johan.smet@justcode.be>
Date: Mon, 15 Oct 2018 22:41:51 +0200
Subject: [PATCH 09/16] Free FFmpeg resources when destroying a SourceVoice

---
 src/FAudio.c          |  6 ++++++
 src/FAudio_ffmpeg.c   | 12 ++++++++++++
 src/FAudio_internal.h |  3 +++
 3 files changed, 21 insertions(+)

diff --git a/src/FAudio.c b/src/FAudio.c
index d593b45..cb4f1d8 100644
--- a/src/FAudio.c
+++ b/src/FAudio.c
@@ -1249,6 +1249,12 @@ void FAudioVoice_DestroyVoice(FAudioVoice *voice)
 		);
 		FAudio_free(voice->src.format);
 		FAudio_PlatformDestroyMutex(voice->src.bufferLock);
+		#ifdef HAVE_FFMPEG
+			if (voice->src.ffmpeg) 
+			{
+				FAudio_FFMPEG_free(voice);
+			}
+		#endif /* HAVE_FFMPEG */
 	}
 	else if (voice->type == FAUDIO_VOICE_SUBMIX)
 	{
diff --git a/src/FAudio_ffmpeg.c b/src/FAudio_ffmpeg.c
index cc6b892..d7f64cb 100644
--- a/src/FAudio_ffmpeg.c
+++ b/src/FAudio_ffmpeg.c
@@ -101,6 +101,18 @@ uint32_t FAudio_FFMPEG_init(FAudioSourceVoice *pSourceVoice)
     return 0;
 }
 
+void FAudio_FFMPEG_free(FAudioSourceVoice *voice)
+{
+	FAudioFFmpeg *ffmpeg = voice->src.ffmpeg;
+
+	avcodec_close(ffmpeg->av_ctx);
+	FAudio_free(ffmpeg->av_ctx->extradata);
+	av_free(ffmpeg->av_ctx);
+
+	FAudio_free(ffmpeg);
+	voice->src.ffmpeg = NULL;
+}
+
 void FAudio_INTERNAL_ResizeConvertCache(FAudioVoice *voice, uint32_t samples)
 {
 	if (samples > voice->src.ffmpeg->convertCapacity)
diff --git a/src/FAudio_internal.h b/src/FAudio_internal.h
index e82efac..ce9eaa0 100644
--- a/src/FAudio_internal.h
+++ b/src/FAudio_internal.h
@@ -483,7 +483,10 @@ uint32_t FAudio_PlatformResample(
 );
 
 /* FFmpeg */
+#ifdef HAVE_FFMPEG
 uint32_t FAudio_FFMPEG_init(FAudioSourceVoice *pSourceVoice);
+void FAudio_FFMPEG_free(FAudioSourceVoice *voice);
+#endif /* HAVE_FFMPEG */
 
 /* Threading */
 

From 9e84e289d4df03b671a993b6959d34555f6df110 Mon Sep 17 00:00:00 2001
From: Johan Smet <johan.smet@justcode.be>
Date: Mon, 15 Oct 2018 22:54:29 +0200
Subject: [PATCH 10/16] Save pBufferWMA, if supplied, so it can be usec by the
 decoder.

---
 src/FAudio.c          | 6 ++++++
 src/FAudio_internal.h | 3 +++
 2 files changed, 9 insertions(+)

diff --git a/src/FAudio.c b/src/FAudio.c
index cb4f1d8..38716a5 100644
--- a/src/FAudio.c
+++ b/src/FAudio.c
@@ -1474,6 +1474,12 @@ uint32_t FAudioSourceVoice_SubmitSourceBuffer(
 	entry->buffer.PlayLength = playLength;
 	entry->buffer.LoopBegin = loopBegin;
 	entry->buffer.LoopLength = loopLength;
+	#ifdef HAVE_FFMPEG
+	if (pBufferWMA != NULL)
+	{
+		FAudio_memcpy(&entry->bufferWMA, pBufferWMA, sizeof(FAudioBufferWMA));
+	}
+	#endif /* HAVE_FFMPEG */
 	entry->next = NULL;
 
 	if (	voice->audio->version <= 7 && (
diff --git a/src/FAudio_internal.h b/src/FAudio_internal.h
index ce9eaa0..7561ff6 100644
--- a/src/FAudio_internal.h
+++ b/src/FAudio_internal.h
@@ -205,6 +205,9 @@ typedef struct FAudioBufferEntry FAudioBufferEntry;
 struct FAudioBufferEntry
 {
 	FAudioBuffer buffer;
+	#ifdef HAVE_FFMPEG
+	FAudioBufferWMA bufferWMA;
+	#endif /* HAVE_FFMPEG */
 	FAudioBufferEntry *next;
 };
 

From 1d79237017dfb0a8318058dff9c56b9e253fa5dc Mon Sep 17 00:00:00 2001
From: Johan Smet <johan.smet@justcode.be>
Date: Mon, 15 Oct 2018 23:29:49 +0200
Subject: [PATCH 11/16] Support for PlayBegin/PlayLength

---
 src/FAudio.c        |  7 +++++++
 src/FAudio_ffmpeg.c | 27 +++++++++++++++++++++++++++
 2 files changed, 34 insertions(+)

diff --git a/src/FAudio.c b/src/FAudio.c
index 38716a5..dea2742 100644
--- a/src/FAudio.c
+++ b/src/FAudio.c
@@ -1416,6 +1416,13 @@ uint32_t FAudioSourceVoice_SubmitSourceBuffer(
 				(((voice->src.format->nBlockAlign / voice->src.format->nChannels) - 6) * 2)
 			) - playBegin;
 		}
+		else if (voice->src.ffmpeg != NULL)		/* XXX-JS ugh, this is ugly */
+		{
+			playLength = (
+				pBufferWMA->pDecodedPacketCumulativeBytes[pBufferWMA->PacketCount - 1] /
+				(voice->src.format->nChannels * voice->src.format->wBitsPerSample / 8)
+			) - playBegin;
+		}
 		else
 		{
 			playLength = (
diff --git a/src/FAudio_ffmpeg.c b/src/FAudio_ffmpeg.c
index d7f64cb..dd55501 100644
--- a/src/FAudio_ffmpeg.c
+++ b/src/FAudio_ffmpeg.c
@@ -9,6 +9,7 @@ typedef struct FAudioFFmpeg
 	AVFrame *av_frame;
 
 	uint32_t encOffset;	/* current position in encoded stream (in bytes) */
+	uint32_t decOffset;	/* current position in decoded stream (in samples) */
 
 	/* buffer used to decode the last frame */
 	size_t paddingBytes;
@@ -229,8 +230,32 @@ void FAudio_INTERNAL_DecodeFFMPEG(
 	float *decodeCache
 ) {
 	FAudioFFmpeg *ffmpeg = voice->src.ffmpeg;
+	uint32_t decSampleSize = voice->src.format->nChannels * voice->src.format->wBitsPerSample / 8;
+	uint32_t outSampleSize = voice->src.format->nChannels * sizeof(float);
     uint32_t done = 0, available, todo;
 
+	/* check if we need to reposition in the stream */
+	if (voice->src.curBufferOffset != ffmpeg->decOffset)
+	{
+		FAudioBufferWMA *bufferWMA = &voice->src.bufferList->bufferWMA;
+		uint32_t byteOffset = voice->src.curBufferOffset * decSampleSize;
+		uint32_t packetIdx = bufferWMA->PacketCount - 1;
+
+		/* figure out in which encoded packet has this position */
+		while (packetIdx > 0 && bufferWMA->pDecodedPacketCumulativeBytes[packetIdx] > byteOffset)
+		{
+			packetIdx -= 1;
+		}
+
+		/* seek to the wanted position in the stream */
+		ffmpeg->encOffset = packetIdx * voice->src.format->nBlockAlign;
+		FAudio_INTERNAL_FillConvertCache(voice, buffer);
+		ffmpeg->convertOffset = (byteOffset - (packetIdx > 0) ? bufferWMA->pDecodedPacketCumulativeBytes[packetIdx-1] : 0) / outSampleSize;
+		ffmpeg->decOffset = voice->src.curBufferOffset;
+	}
+
+	*samples = FAudio_min(*samples, end - voice->src.curBufferOffset);
+
 	while (done < *samples) 
 	{	
 		available = (ffmpeg->convertSamples - ffmpeg->convertOffset) / voice->src.format->nChannels;
@@ -253,6 +278,8 @@ void FAudio_INTERNAL_DecodeFFMPEG(
 	}
 
     *samples = done;
+	voice->src.curBufferOffset += *samples;
+	ffmpeg->decOffset += *samples;
 }
 
 #endif
\ No newline at end of file

From fe330ba8db2e4b58d23ca9c3341a628509b0a0ae Mon Sep 17 00:00:00 2001
From: Johan Smet <johan.smet@justcode.be>
Date: Fri, 12 Oct 2018 18:25:11 +0200
Subject: [PATCH 12/16] Test utility to play xWMA files with FAudio

---
 Makefile                    |  12 +-
 src/FAudio_ffmpeg.c         |   6 +
 utils/testxwma/testxwma.cpp | 232 ++++++++++++++++++++++++++++++++++++
 3 files changed, 247 insertions(+), 3 deletions(-)
 create mode 100644 utils/testxwma/testxwma.cpp

diff --git a/Makefile b/Makefile
index e340797..8f3677b 100644
--- a/Makefile
+++ b/Makefile
@@ -93,7 +93,7 @@ all: $(FAUDIOOBJ)
 clean:
 	rm -f $(FAUDIOOBJ) $(TARGET_PREFIX)FAudio.$(TARGET_SUFFIX) testparse$(UTIL_SUFFIX) facttool$(UTIL_SUFFIX) testreverb$(UTIL_SUFFIX) testvolumemeter$(UTIL_SUFFIX) testfilter$(UTIL_SUFFIX)
 
-.PHONY: testparse facttool testreverb testvolumemeter testfilter
+.PHONY: testparse facttool testreverb testvolumemeter testfilter testxwma
 
 testparse:
 	$(CC) -g -Wall -pedantic -o testparse$(UTIL_SUFFIX) \
@@ -102,10 +102,10 @@ testparse:
 		-Isrc `sdl2-config --cflags --libs`
 
 facttool:
-	$(CXX) -g -Wall -o facttool$(UTIL_SUFFIX) \
+	$(CXX) -g -Wall $(FFMPEG_CFLAGS) -o facttool$(UTIL_SUFFIX) \
 		utils/facttool/facttool.cpp \
 		utils/uicommon/*.cpp src/F*.c \
-		-Isrc `sdl2-config --cflags --libs`
+		-Isrc `sdl2-config --cflags --libs` $(FFMPEG_LDFLAGS)
 
 testreverb:
 	$(CXX) -g -Wall -o testreverb$(UTIL_SUFFIX) \
@@ -121,6 +121,12 @@ testvolumemeter:
 		utils/uicommon/*.cpp src/F*.c \
 		-Isrc `sdl2-config --cflags --libs`
 
+testxwma:
+	$(CXX) -g -Wall $(FFMPEG_CFLAGS) -o testxwma$(UTIL_SUFFIX) \
+		utils/testxwma/*.cpp \
+		src/F*.c \
+		-Isrc `sdl2-config --cflags --libs` $(FFMPEG_LDFLAGS)
+
 testfilter:
 	$(CXX) -g -Wall -o testfilter$(UTIL_SUFFIX) \
 		utils/testfilter/*.cpp \
diff --git a/src/FAudio_ffmpeg.c b/src/FAudio_ffmpeg.c
index dd55501..45252e0 100644
--- a/src/FAudio_ffmpeg.c
+++ b/src/FAudio_ffmpeg.c
@@ -1,7 +1,13 @@
 #ifdef HAVE_FFMPEG
 
 #include "FAudio_internal.h"
+#ifdef __cplusplus
+extern "C" {
+#endif
 #include <libavcodec/avcodec.h>
+#ifdef __cplusplus
+}
+#endif
 
 typedef struct FAudioFFmpeg 
 {
diff --git a/utils/testxwma/testxwma.cpp b/utils/testxwma/testxwma.cpp
new file mode 100644
index 0000000..16633b4
--- /dev/null
+++ b/utils/testxwma/testxwma.cpp
@@ -0,0 +1,232 @@
+#include <stdio.h>
+#include <SDL.h>
+
+#include <FAudio.h>
+
+float argPlayBegin = 0.0f;
+float argPlayLength = 0.0f;
+float argLoopBegin = 0.0f;
+float argLoopLength = 0.0f;
+uint32_t argLoopCount = 0;
+
+FAudio *faudio = NULL;
+FAudioMasteringVoice *mastering_voice = NULL;
+FAudioSourceVoice *source_voice = NULL;
+
+FAudioWaveFormatExtensible wfx = {0};
+FAudioBuffer buffer = {0};
+FAudioBufferWMA buffer_wma = {0};
+
+/* based on https://docs.microsoft.com/en-us/windows/desktop/xaudio2/how-to--load-audio-data-files-in-xaudio2 */
+#define fourccRIFF *((uint32_t *) "RIFF")
+#define fourccDATA *((uint32_t *) "data")
+#define fourccFMT  *((uint32_t *) "fmt ")
+#define fourccWAVE *((uint32_t *) "WAVE")
+#define fourccXWMA *((uint32_t *) "XWMA")
+#define fourccDPDS *((uint32_t *) "dpds")
+
+uint32_t FindChunk(FILE *hFile, uint32_t fourcc, uint32_t *dwChunkSize, uint32_t *dwChunkDataPosition)
+{
+    uint32_t hr = 0;
+
+	if (fseek(hFile, 0, SEEK_SET) != 0)
+	{ 
+		return -1;
+	}
+
+    uint32_t dwChunkType;
+    uint32_t dwChunkDataSize;
+    uint32_t dwRIFFDataSize = 0;
+    uint32_t dwFileType;
+    uint32_t bytesRead = 0;
+    uint32_t dwOffset = 0;
+
+    while (hr == 0)
+    {
+		if (fread(&dwChunkType, sizeof(uint32_t), 1, hFile) < 1)
+			hr = 1;
+
+		if (fread(&dwChunkDataSize, sizeof(uint32_t), 1, hFile) < 1)
+			hr = 1;
+
+        if (dwChunkType == fourccRIFF)
+        {
+            dwRIFFDataSize = dwChunkDataSize;
+            dwChunkDataSize = 4;
+
+			if (fread(&dwFileType, sizeof(uint32_t), 1, hFile) < 1)
+				hr = 1;
+		}
+		else
+		{
+			if (fseek(hFile, dwChunkDataSize, SEEK_CUR) != 0)
+				return 1;
+        }
+
+        dwOffset += sizeof(uint32_t) * 2;
+
+        if (dwChunkType == fourcc)
+        {
+            *dwChunkSize = dwChunkDataSize;
+            *dwChunkDataPosition = dwOffset;
+            return 0;
+        }
+
+        dwOffset += dwChunkDataSize;
+
+        if (bytesRead >= dwRIFFDataSize) 
+			return 1;
+
+    }
+
+    return 1;
+}
+
+uint32_t ReadChunkData(FILE *hFile, void * buffer, uint32_t buffersize, uint32_t bufferoffset)
+{
+    uint32_t hr = 0;
+
+	if (fseek(hFile, bufferoffset, SEEK_SET) != 0)
+		return 1;
+
+	if (fread(buffer, buffersize, 1, hFile) < 1)
+		hr = 1;
+
+    return hr;
+}
+
+uint32_t load_data(const char *filename)
+{
+	/* open the audio file */
+	FILE *hFile = fopen(filename, "rb");
+	if (!hFile)
+		return 1;
+
+	fseek(hFile, 0, SEEK_SET);
+
+	/* Locate the 'RIFF' chunk in the audio file, and check the file type. */
+	uint32_t dwChunkSize;
+	uint32_t dwChunkPosition;
+	uint32_t filetype;
+
+	FindChunk(hFile,fourccRIFF, &dwChunkSize, &dwChunkPosition);
+	ReadChunkData(hFile, &filetype, sizeof(uint32_t), dwChunkPosition);
+	
+	if (filetype != fourccWAVE && filetype != fourccXWMA)
+		return 1;
+
+	/* Locate the 'fmt ' chunk, and copy its contents into a WAVEFORMATEXTENSIBLE structure. */
+	FindChunk(hFile,fourccFMT, &dwChunkSize, &dwChunkPosition );
+	ReadChunkData(hFile, &wfx, dwChunkSize, dwChunkPosition );
+
+	/* Locate the 'data' chunk, and read its contents into a buffer. */
+	FindChunk(hFile, fourccDATA, &dwChunkSize, &dwChunkPosition);
+	uint8_t *pDataBuffer = (uint8_t *) malloc(dwChunkSize);
+	ReadChunkData(hFile, pDataBuffer, dwChunkSize, dwChunkPosition);
+
+	buffer.AudioBytes = dwChunkSize;  //buffer containing audio data
+	buffer.pAudioData = pDataBuffer;  //size of the audio buffer in bytes
+	buffer.Flags = FAUDIO_END_OF_STREAM; // tell the source voice not to expect any data after this buffer
+
+	/* Locate the 'dpds' chunk, and read its contents into a buffer. */
+	if (FindChunk(hFile, fourccDPDS, &dwChunkSize, &dwChunkPosition) == 0) 
+	{
+		uint32_t *cumulBytes = (uint32_t *) malloc(dwChunkSize);
+		ReadChunkData(hFile, cumulBytes, dwChunkSize, dwChunkPosition);
+
+		buffer_wma.pDecodedPacketCumulativeBytes = cumulBytes;
+		buffer_wma.PacketCount = dwChunkSize / sizeof(uint32_t);
+	}
+
+	fclose(hFile);
+
+	return 0;
+}
+
+void faudio_setup() {
+	uint32_t hr = FAudioCreate(&faudio, 0, FAUDIO_DEFAULT_PROCESSOR);
+	if (hr != 0) {
+		return;
+	}
+
+	hr = FAudio_CreateMasteringVoice(faudio, &mastering_voice, 2, 44100, 0, 0, NULL);
+	if (hr != 0) {
+		return;
+	}
+
+	hr = FAudio_CreateSourceVoice(
+		faudio, 
+		&source_voice, 
+		(FAudioWaveFormatEx *) &wfx, 
+		FAUDIO_VOICE_USEFILTER, 
+		FAUDIO_MAX_FREQ_RATIO, 
+		NULL, NULL, NULL
+	);
+}
+
+void play(void) {
+
+	buffer.PlayBegin = argPlayBegin * wfx.Format.nSamplesPerSec;
+	buffer.PlayLength = argPlayLength * wfx.Format.nSamplesPerSec;
+
+	buffer.LoopBegin = argLoopBegin * wfx.Format.nSamplesPerSec;
+	buffer.LoopLength = argLoopLength * wfx.Format.nSamplesPerSec;
+	buffer.LoopCount = argLoopCount;
+
+	if (buffer_wma.pDecodedPacketCumulativeBytes != NULL)
+		FAudioSourceVoice_SubmitSourceBuffer(source_voice, &buffer, &buffer_wma);
+	else
+		FAudioSourceVoice_SubmitSourceBuffer(source_voice, &buffer, NULL);
+
+	uint32_t hr = FAudioSourceVoice_Start(source_voice, 0, FAUDIO_COMMIT_NOW);
+
+	int is_running = 1;
+	while (hr == 0 && is_running) {
+		FAudioVoiceState state;
+		FAudioSourceVoice_GetState(source_voice, &state, 0);
+		is_running = (state.BuffersQueued > 0) != 0;
+		SDL_Delay(10);
+	}
+
+	FAudioVoice_DestroyVoice(source_voice);
+}
+
+int main(int argc, char *argv[]) {
+	
+	/* process command line arguments. This is just a test program, didn't go too nuts with validation. */
+	if (argc < 2 || (argc > 4 && argc != 7)) {
+		printf("Usage: %s filename [PlayBegin] [PlayLength] [LoopBegin LoopLength LoopCount]\n", argv[0]);
+		printf(" - filename (required): can be either a WAV or XMWA audio file.\n");
+		printf(" - PlayBegin (optional): start playing at this offset. (in seconds)\n");
+		printf(" - PlayLength (optional): duration of the region to be played. (in seconds)\n");
+		printf(" - LoopBegin (optional): start looping at this offset. (in seconds)\n");
+		printf(" - LoopLength (optional): duration of the loop (in seconds)\n");
+		printf(" - LoopCount (optional): number of times to loop\n");
+		return -1;
+	}
+
+	switch (argc) 
+	{
+		case 7:
+			sscanf(argv[6], "%d", &argLoopCount);
+			sscanf(argv[5], "%f", &argLoopLength);
+			sscanf(argv[4], "%f", &argLoopBegin);
+		
+		case 4:
+			sscanf(argv[3], "%f", &argPlayLength);
+
+		case 3:
+			sscanf(argv[2], "%f", &argPlayBegin);
+	}
+
+	if (load_data(argv[1]) != 0)
+	{
+		printf("Error loading data\n");
+		return -1;
+	}
+
+	faudio_setup();
+	play();
+
+	return 0;
+}
\ No newline at end of file

From f3bdc84d41e7a55a67fbb455f7de735db5d4baa3 Mon Sep 17 00:00:00 2001
From: Johan Smet <johan.smet@justcode.be>
Date: Wed, 17 Oct 2018 23:22:48 +0200
Subject: [PATCH 13/16] Refactoring and cleanup ffmpeg support

---
 src/FAudio.c        |  4 +++-
 src/FAudio_ffmpeg.c | 46 ++++++++++++++++++++++++---------------------
 2 files changed, 28 insertions(+), 22 deletions(-)

diff --git a/src/FAudio.c b/src/FAudio.c
index dea2742..48f8249 100644
--- a/src/FAudio.c
+++ b/src/FAudio.c
@@ -1390,8 +1390,10 @@ uint32_t FAudioSourceVoice_SubmitSourceBuffer(
 	uint32_t playBegin, playLength, loopBegin, loopLength;
 	FAudioBufferEntry *entry, *list;
 	FAudio_assert(voice->type == FAUDIO_VOICE_SOURCE);
+#ifdef HAVE_FFMPEG
 	FAudio_assert((voice->src.ffmpeg != NULL && pBufferWMA != NULL) ||
 				  (voice->src.ffmpeg == NULL && pBufferWMA == NULL));
+#endif
 
 	/* Start off with whatever they just sent us... */
 	playBegin = pBuffer->PlayBegin;
@@ -1416,7 +1418,7 @@ uint32_t FAudioSourceVoice_SubmitSourceBuffer(
 				(((voice->src.format->nBlockAlign / voice->src.format->nChannels) - 6) * 2)
 			) - playBegin;
 		}
-		else if (voice->src.ffmpeg != NULL)		/* XXX-JS ugh, this is ugly */
+		else if (pBufferWMA != NULL)
 		{
 			playLength = (
 				pBufferWMA->pDecodedPacketCumulativeBytes[pBufferWMA->PacketCount - 1] /
diff --git a/src/FAudio_ffmpeg.c b/src/FAudio_ffmpeg.c
index 45252e0..fa61890 100644
--- a/src/FAudio_ffmpeg.c
+++ b/src/FAudio_ffmpeg.c
@@ -28,10 +28,6 @@ typedef struct FAudioFFmpeg
 	float *convertCache;
 } FAudioFFmpeg;
 
-#include <stdio.h>
-#define TRACE(msg,...)  fprintf(stderr, "TRACE: " msg, __VA_ARGS__)
-#define WARN(msg,...)  fprintf(stderr, "WARN:  " msg, __VA_ARGS__)
-
 uint32_t FAudio_FFMPEG_init(FAudioSourceVoice *pSourceVoice)
 {
     AVCodecContext *av_ctx;
@@ -44,12 +40,14 @@ uint32_t FAudio_FFMPEG_init(FAudioSourceVoice *pSourceVoice)
 	codec = avcodec_find_decoder(AV_CODEC_ID_WMAV2);
 	if (!codec)
     {
+		FAudio_assert(0 && "WMAv2 codec not supported!");
 	    return FAUDIO_E_UNSUPPORTED_FORMAT;
 	}
 
 	av_ctx = avcodec_alloc_context3(codec);
 	if(!av_ctx)
     {
+		FAudio_assert(0 && "WMAv2 codec not supported!");
         return FAUDIO_E_UNSUPPORTED_FORMAT;
     }
 
@@ -158,32 +156,29 @@ void FAudio_INTERNAL_FillConvertCache(FAudioVoice *voice, FAudioBuffer *buffer)
 
 			if (ffmpeg->encOffset + avpkt.size + AV_INPUT_BUFFER_PADDING_SIZE > buffer->AudioBytes)
             {
-				size_t remain = buffer->AudioBytes - ffmpeg->encOffset;
 				/* Unfortunately, the FFmpeg API requires that a number of
 				 * extra bytes must be available past the end of the buffer.
 				 * The xaudio2 client probably hasn't done this, so we have to
 				 * perform a copy near the end of the buffer. */
-				TRACE("hitting end of buffer. copying %lu + %u bytes into %lu buffer\n",
-						remain, AV_INPUT_BUFFER_PADDING_SIZE, ffmpeg->paddingBytes);
+				size_t remain = buffer->AudioBytes - ffmpeg->encOffset;
 
 				if (ffmpeg->paddingBytes < remain + AV_INPUT_BUFFER_PADDING_SIZE)
                 {
 					ffmpeg->paddingBytes = remain + AV_INPUT_BUFFER_PADDING_SIZE;
-					TRACE("buffer too small, expanding to %lu\n", ffmpeg->paddingBytes);
                     ffmpeg->paddingBuffer = (uint8_t *) FAudio_realloc(
 						ffmpeg->paddingBuffer, 
 						ffmpeg->paddingBytes
 					);
 				}
 				FAudio_memcpy(ffmpeg->paddingBuffer, buffer->pAudioData + ffmpeg->encOffset, remain);
-				FAudio_memset(ffmpeg->paddingBuffer + remain, 0, AV_INPUT_BUFFER_PADDING_SIZE);
+				FAudio_zero(ffmpeg->paddingBuffer + remain, AV_INPUT_BUFFER_PADDING_SIZE);
 				avpkt.data = ffmpeg->paddingBuffer;
 			}
 
 			averr = avcodec_send_packet(ffmpeg->av_ctx, &avpkt);
 			if (averr)
             {
-				WARN("avcodec_send_packet failed: %d\n", averr);
+				FAudio_assert(0 && "avcodec_send_packet failed" && averr);
 				break;
 			}
 
@@ -196,7 +191,7 @@ void FAudio_INTERNAL_FillConvertCache(FAudioVoice *voice, FAudioBuffer *buffer)
 
 		if (averr) 
         {
-            WARN("avcodec_receive_frame failed: %d\n", averr);
+            FAudio_assert(0 && "avcodec_receive_frame failed" && averr);
             return; 
 		}
 		else
@@ -205,6 +200,7 @@ void FAudio_INTERNAL_FillConvertCache(FAudioVoice *voice, FAudioBuffer *buffer)
 		}
 	}
 
+	/* copy decoded samples to internal buffer, reordering if necessary */
     total_samples = ffmpeg->av_frame->nb_samples * ffmpeg->av_ctx->channels;
 
 	FAudio_INTERNAL_ResizeConvertCache(voice, total_samples);
@@ -221,7 +217,11 @@ void FAudio_INTERNAL_FillConvertCache(FAudioVoice *voice, FAudioBuffer *buffer)
 	}
 	else
 	{
-		FAudio_memcpy(ffmpeg->convertCache, ffmpeg->av_frame->data[0], total_samples * sizeof(float));
+		FAudio_memcpy(
+			ffmpeg->convertCache, 
+			ffmpeg->av_frame->data[0], 
+			total_samples * sizeof(float)
+		);
 	}
 
 	ffmpeg->convertSamples = total_samples;
@@ -264,21 +264,25 @@ void FAudio_INTERNAL_DecodeFFMPEG(
 
 	while (done < *samples) 
 	{	
-		available = (ffmpeg->convertSamples - ffmpeg->convertOffset) / voice->src.format->nChannels;
-
-		if (available <= 0) 
+		/* check for available data in decoded cache, refill if necessary */
+		if (ffmpeg->convertOffset >= ffmpeg->convertSamples)
 		{
 			FAudio_INTERNAL_FillConvertCache(voice, buffer);
-			available = (ffmpeg->convertSamples - ffmpeg->convertOffset) / voice->src.format->nChannels;
+		}
 
-			if (available <= 0)
-			{
-				break;
-			}
+		available = (ffmpeg->convertSamples - ffmpeg->convertOffset) / voice->src.format->nChannels;
+		if (available <= 0)
+		{
+			break;
 		}
 
 		todo = FAudio_min(available, *samples - done);
-		FAudio_memcpy(decodeCache + (done * voice->src.format->nChannels), ffmpeg->convertCache + ffmpeg->convertOffset, todo * voice->src.format->nChannels * sizeof(float));
+		FAudio_memcpy(
+			decodeCache + (done * voice->src.format->nChannels), 
+			ffmpeg->convertCache + ffmpeg->convertOffset, 
+			todo * voice->src.format->nChannels * sizeof(float)
+		);
+
 		done += todo;
 		ffmpeg->convertOffset += todo * voice->src.format->nChannels;
 	}

From da6b37e482281777bf71575d979a8320c77d1ec9 Mon Sep 17 00:00:00 2001
From: Johan Smet <johan.smet@justcode.be>
Date: Thu, 18 Oct 2018 21:36:00 +0200
Subject: [PATCH 14/16] Copy ffmpeg dlls when cross compiling

---
 cpp/Makefile | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/cpp/Makefile b/cpp/Makefile
index 25857cf..a32d762 100644
--- a/cpp/Makefile
+++ b/cpp/Makefile
@@ -240,6 +240,10 @@ directories:
 	mkdir -p $(BUILD_DIR)
 	cp ../FAudio.dll $(BUILD_DIR)
 	cp `sdl2-config --prefix`/bin/SDL2.dll $(BUILD_DIR)
+	if [ -n "${FAUDIO_FFMPEG}" ] && [ -n "${FAUDIO_FFMPEG_PREFIX}" ]; then	\
+		cp $(FAUDIO_FFMPEG_PREFIX)/bin/avcodec*.dll $(BUILD_DIR);	\
+		cp $(FAUDIO_FFMPEG_PREFIX)/bin/avutil*.dll $(BUILD_DIR);	\
+	fi
 
 clean:
 	rm -f $(XAUDIO20_TARGET) $(XAUDIO21_TARGET) $(XAUDIO22_TARGET) $(XAUDIO23_TARGET) \

From 3542c6912b406b541bfa120b5ba1002612c29b37 Mon Sep 17 00:00:00 2001
From: Johan Smet <johan.smet@justcode.be>
Date: Thu, 18 Oct 2018 21:36:29 +0200
Subject: [PATCH 15/16] Fix empty translation unit warning when compiling utils

---
 src/FAudio_ffmpeg.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/src/FAudio_ffmpeg.c b/src/FAudio_ffmpeg.c
index fa61890..c62209b 100644
--- a/src/FAudio_ffmpeg.c
+++ b/src/FAudio_ffmpeg.c
@@ -292,4 +292,8 @@ void FAudio_INTERNAL_DecodeFFMPEG(
 	ffmpeg->decOffset += *samples;
 }
 
+#else
+
+extern int this_tu_is_empty;
+
 #endif
\ No newline at end of file

From a46b76325a693eaed517111630f63d89f210bc88 Mon Sep 17 00:00:00 2001
From: Johan Smet <johan.smet@justcode.be>
Date: Thu, 18 Oct 2018 21:48:10 +0200
Subject: [PATCH 16/16] Add small README to explain FFmpeg support

---
 README.ffmpeg | 23 +++++++++++++++++++++++
 1 file changed, 23 insertions(+)
 create mode 100644 README.ffmpeg

diff --git a/README.ffmpeg b/README.ffmpeg
new file mode 100644
index 0000000..3a4d28c
--- /dev/null
+++ b/README.ffmpeg
@@ -0,0 +1,23 @@
+FAudio has optional support for decoding xWMA resources using FFmpeg.
+
+Please note that enabling support for FFmpeg means your project has to comply
+with the FFmpeg license. For more information please consult the FFmpeg project at
+https://www.ffmpeg.org/legal.html
+
+Building with FFmpeg support on *nix platforms
+----------------------------------------------
+# to enable FFMPEG support
+export FAUDIO_FFMPEG=1         
+
+# to build against specific FFmpeg binaries (if not set `pkg-config` will be used)
+export FAUDIO_FFMPEG_PREFIX=/path/to/ffmpeg/binaries
+
+make
+
+Building with FFmpeg support on Windows
+---------------------------------------
+You'll need to modify the Visual Studio project for FAudio to enable support:
+- add HAVE_FFMPEG=1 to preprocessor defines
+- add the correct include and lib paths to the VisualC++ directories.
+- add avutil.lib and avcodec.lib to the linker input
+- add faudio_ffmpeg.c to the sources of the project 
\ No newline at end of file
